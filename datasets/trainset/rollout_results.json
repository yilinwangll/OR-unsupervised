[
  {
    "question": "A transportation company is planning to allocate its fleet of vehicles across three routes: $X, Y$, and $Z$. Each route requires a different type of vehicle with varying operating costs. The operating cost per vehicle for routes $X, Y$, and $Z$ are 10, 15, and 20 units respectively. The company aims to minimize the total operating cost while adhering to the following constraints:\\n\\n- Due to traffic restrictions and road capacity, the combined number of vehicles on routes X and Y cannot exceed 1000.\\n- Similarly, the combined number of vehicles on routes Y and Z cannot exceed 800 due to similar limitations.\\n- To maintain service levels across all regions served by these routes, the sum of vehicles on routes X and Z must be at least 500.\\n\\nThe allocation must also respect individual route capacity limits due to physical or regulatory restrictions: route X can accommodate up to 700 vehicles; route Y can have a maximum of 600 vehicles; while route Z can only handle up to 400 vehicles. Given that each route's allocation must be in whole numbers due to the indivisible nature of a vehicle,\\n\\nWhat is the minimum total operating cost for this scenario when optimal allocations are made for each route? Please provide your answer rounded to nearest whole number.",
    "pass_count": 5,
    "pass_rate": 0.625,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_s\\): Number of small buses.\n- \\(x_l\\): Number of large buses.\n\nObjective Function:\n- Minimize total number of buses: \\(Z = x_s + x_l\\).\n\nConstraints:\n1. Transportation capacity: \\(20x_s + 50x_l \\geq 500\\).\n2. Parking limitation: \\(x_l \\leq 0.2(x_s + x_l)\\).\n3. Non-negativity: \\(x_s, x_l \\geq 0\\), and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"FieldTripBusHiring\")\n\n# Add decision variables\nx_s = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_s\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(20*x_s + 50*x_l >= 500, name=\"TransportCapacity\")\nmodel.addConstr(x_l <= 0.2*(x_s + x_l), name=\"ParkingLimit\")\n\n# Set the objective function\nmodel.setObjective(x_s + x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimized total number of buses: {}\".format(model.objval))\n    print(\"Optimal solution: x_s = {}, x_l = {}\".format(x_s.x, x_l.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"FieldTripBusHiring\")\n\n# Add decision variables\nx_s = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_s\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(20*x_s + 50*x_l >= 500, name=\"TransportCapacity\")\nmodel.addConstr(x_l <= 0.2*(x_s + x_l), name=\"ParkingLimit\")\n\n# Set the objective function\nmodel.setObjective(x_s + x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimized total number of buses: {}\".format(model.objval))\n    print(\"Optimal solution: x_s = {}, x_l = {}\".format(x_s.x, x_l.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 88437a4d\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.01s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimized total number of buses: 20.0\nOptimal solution: x_s = 16.0, x_l = 4.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_s\\): the number of small buses hired.\n- \\(x_l\\): the number of large buses hired.\n\nObjective Function:\n- Minimize the total number of buses: \\(Z = x_s + x_l\\).\n\nConstraints:\n1. Transportation capacity: \\(20x_s + 50x_l \\geq 500\\).\n2. Maximum large buses: \\(x_l \\leq 0.2(x_s + x_l)\\).\n3. Non-negativity and integer: \\(x_s, x_l \\geq 0\\) and integers.\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_s\\): Number of small buses hired.\n- \\(x_l\\): Number of large buses hired.\n\nObjective Function:\n- Minimize the total number of buses: \\(Z = x_s + x_l\\)\n\nConstraints:\n1. The total number of students carried must be at least 500: \\(20x_s + 50x_l \\geq 500\\)\n2. The number of large buses cannot exceed 20% of the total number of buses: \\(x_l \\leq 0.2(x_s + x_l)\\)\n3. Non-negativity and integer constraints: \\(x_s, x_l \\geq 0\\) and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Add decision variables\nx_s = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_s\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(20*x_s + 50*x_l >= 500, name=\"StudentCapacity\")\nmodel.addConstr(x_l <= 0.2*(x_s + x_l), name=\"MaxLargeBuses\")\n\n# Set the objective function to minimize the total number of buses\nmodel.setObjective(x_s + x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {}\".format(model.objval))\n    print(\"Number of small buses: {}\".format(x_s.x))\n    print(\"Number of large buses: {}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Add decision variables\nx_s = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_s\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(20*x_s + 50*x_l >= 500, name=\"StudentCapacity\")\nmodel.addConstr(x_l <= 0.2*(x_s + x_l), name=\"MaxLargeBuses\")\n\n# Set the objective function to minimize the total number of buses\nmodel.setObjective(x_s + x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {}\".format(model.objval))\n    print(\"Number of small buses: {}\".format(x_s.x))\n    print(\"Number of large buses: {}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 88437a4d\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.01s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of buses: 20.0\nNumber of small buses: 16.0\nNumber of large buses: 4.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_s\\): The number of small buses to be hired.  \n- \\(x_l\\): The number of large buses to be hired.  \n\nObjective Function:  \nMinimize the total number of buses:  \n\\[\nZ = x_s + x_l\n\\]\n\nConstraints:  \n1. The total number of students transported must be at least 500:  \n\\[\n20x_s + 50x_l \\geq 500\n\\]  \n2. The maximum proportion of large buses is 20%:  \n\\[\nx_l \\leq 0.2(x_s + x_l)\n\\]  \n3. Non-negativity and integer constraints:  \n\\[\nx_s, x_l \\geq 0 \\text{ and integers}\n\\]\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: Number of small buses hired.\n- x2: Number of large buses hired.\n\nObjective Function:\nMinimize Z = x1 + x2\n\nConstraints:\n1. Student capacity requirement: 20*x1 + 50*x2 >= 500\n2. Large bus limit: x2 <= 0.2*(x1 + x2)\n3. Non-negativity and integer: x1, x2 >= 0 and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"FieldTrip\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of small buses\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of large buses\n\n# Add constraints\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"StudentCapacity\")  # Student capacity requirement\nmodel.addConstr(x2 <= 0.2*(x1 + x2), name=\"LargeBusLimit\")  # Large bus limit\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {}\".format(model.objval))\n    print(\"Number of small buses: {}\".format(x1.x))\n    print(\"Number of large buses: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"FieldTrip\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of small buses\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of large buses\n\n# Add constraints\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"StudentCapacity\")  # Student capacity requirement\nmodel.addConstr(x2 <= 0.2*(x1 + x2), name=\"LargeBusLimit\")  # Large bus limit\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {}\".format(model.objval))\n    print(\"Number of small buses: {}\".format(x1.x))\n    print(\"Number of large buses: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 88437a4d\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.01s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of buses: 20.0\nNumber of small buses: 16.0\nNumber of large buses: 4.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x: the number of small buses hired.\n- y: the number of large buses hired.\n\nObjective Function:\nMinimize Z = x + y (minimize the total number of buses)\n\nConstraints:\n1. Transportation capacity: 20x + 50y ≥ 500 (provide transportation for at least 500 students)\n2. Bus type limitation: y ≤ 0.2(x + y) (maximum of 20% of the buses can be large buses)\n3. Non-negativity: x, y ≥ 0 and integer (number of buses must be non-negative integers)\n\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")  # Number of small buses\ny = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y\")  # Number of large buses\n\n# Add constraints\nmodel.addConstr(20*x + 50*y >= 500, name=\"TransportationCapacity\")  # Provide transportation for at least 500 students\nmodel.addConstr(y <= 0.2*(x + y), name=\"BusTypeLimit\")  # Maximum of 20% of the buses can be large buses\n\n# Set the objective function to minimize the total number of buses\nmodel.setObjective(x + y, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimized total number of buses: {model.objval}\")\n    print(f\"Number of small buses: {x.x}\")\n    print(f\"Number of large buses: {y.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")  # Number of small buses\ny = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y\")  # Number of large buses\n\n# Add constraints\nmodel.addConstr(20*x + 50*y >= 500, name=\"TransportationCapacity\")  # Provide transportation for at least 500 students\nmodel.addConstr(y <= 0.2*(x + y), name=\"BusTypeLimit\")  # Maximum of 20% of the buses can be large buses\n\n# Set the objective function to minimize the total number of buses\nmodel.setObjective(x + y, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimized total number of buses: {model.objval}\")\n    print(f\"Number of small buses: {x.x}\")\n    print(f\"Number of large buses: {y.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 88437a4d\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.03s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.03s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.03s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.03s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.03\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimized total number of buses: 20.0\nNumber of small buses: 16.0\nNumber of large buses: 4.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x_s: number of small buses hired.\n- x_l: number of large buses hired.\n\nObjective Function:\n- Minimize the total number of buses: Z = x_s + x_l\n\nConstraints:\n1. Transportation capacity requirement: 20x_s + 50x_l ≥ 500\n2. Large bus limit: x_l ≤ 0.2(x_s + x_l)\n3. Non-negativity: x_s, x_l ≥ 0 and integers\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of small buses hired.\n- \\(x_2\\): Number of large buses hired.\n\nObjective Function:\nMinimize the total number of buses:  \n\\(Z = x_1 + x_2\\)\n\nConstraints:\n1. The total number of students carried must be at least 500:  \n   \\(20x_1 + 50x_2 \\geq 500\\)\n2. The maximum percentage of large buses is 20%:  \n   \\(x_2 \\leq 0.2(x_1 + x_2)\\)\n3. Non-negativity and integer:  \n   \\(x_1, x_2 \\geq 0\\) and integer\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"StudentConstraint\")\nmodel.addConstr(x2 <= 0.2*(x1 + x2), name=\"BusPercentageConstraint\")\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum number of buses: {}\".format(model.objval))\n    print(\"Number of small buses hired: {}\".format(x1.x))\n    print(\"Number of large buses hired: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"StudentConstraint\")\nmodel.addConstr(x2 <= 0.2*(x1 + x2), name=\"BusPercentageConstraint\")\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum number of buses: {}\".format(model.objval))\n    print(\"Number of small buses hired: {}\".format(x1.x))\n    print(\"Number of large buses hired: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 88437a4d\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.05s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.05s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.05s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.05s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.05\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum number of buses: 20.0\nNumber of small buses hired: 16.0\nNumber of large buses hired: 4.0",
        "pass": true
      }
    ],
    "answer": 5000.0,
    "cloze": "A transportation company is planning to allocate its fleet of vehicles across three routes: $X, Y$, and $Z$. Each route requires a different type of vehicle with varying operating costs. The operating cost per vehicle for routes $X, Y$, and $Z$ are ____, ____, and ____ units respectively. The company aims to ____ the total operating cost while adhering to the following constraints:\\n\\n- Due to traffic restrictions and road capacity, the combined number of vehicles on routes X and Y ____ ____.\\n- Similarly, the combined number of vehicles on routes Y and Z ____ ____ due to similar limitations.\\n- To maintain service levels across all regions served by these routes, the sum of vehicles on routes X and Z ____ ____.\\n\\nThe allocation must also respect individual route capacity limits due to physical or regulatory restrictions: route X can accommodate ____ ____ vehicles; route Y can have ____ ____ ____ vehicles; while route Z can only handle ____ ____ ____ vehicles. Given that each route's allocation must be in whole numbers due to the indivisible nature of a vehicle,\\n\\nWhat is the ____ total operating cost for this scenario when optimal allocations are made for each route? Please provide your answer rounded to nearest whole number."
  },
  {
    "question": "Gabriel is growing pumpkins and carrots on his farm. He has 100 acres available on which he must grow a minimum of 7 acres of pumpkins and a minimum of 12 acres of carrots to meet demands. The profit per pumpkin is $2.5 and the profit per carrot is $3.4. He prefers to grow more carrots than pumpkins but limitations in his workforce allow him to grow at most three times the amount of carrots as pumpkins. How many of each produce should Gabriel grow in order to maximize his profit?",
    "pass_count": 6,
    "pass_rate": 0.75,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- x1: Number of strawberry cookies produced per day.\n- x2: Number of sugar cookies produced per day.\n\nObjective Function:\nMaximize Z = 5.5 * x1 + 12 * x2\n\nConstraints:\n1. x1 <= 100 (Maximum demand for strawberry cookies)\n2. x2 <= 80 (Maximum demand for sugar cookies)\n3. x1 + x2 <= 100 (Maximum production capacity)\n4. x1 >= 0\n5. x2 >= 0\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakeryOptimization\")\n\n# Define decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced per day\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Maximum demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")  # Maximum demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"ProductionCapacity\")  # Maximum production capacity\n\n# Set the objective function\nmodel.setObjective(5.5 * x1 + 12 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total profit: $\", round(model.objval))\n    print(\"Optimal production plan:\")\n    print(f\"Strawberry cookies: {x1.x}\")\n    print(f\"Sugar cookies: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakeryOptimization\")\n\n# Define decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced per day\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Maximum demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")  # Maximum demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"ProductionCapacity\")  # Maximum production capacity\n\n# Set the objective function\nmodel.setObjective(5.5 * x1 + 12 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total profit: $\", round(model.objval))\n    print(\"Optimal production plan:\")\n    print(f\"Strawberry cookies: {x1.x}\")\n    print(f\"Sugar cookies: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.01s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.02s\nMaximized total profit: $ 1070\nOptimal production plan:\nStrawberry cookies: 20.0\nSugar cookies: 80.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): The number of strawberry cookies produced per day.\n- \\(x_2\\): The number of sugar cookies produced per day.\n\nObjective Function:\n- Maximize profit: \\(Z = 5.5x_1 + 12x_2\\)\n\nConstraints:\n1. Daily demand for strawberry cookies: \\(x_1 \\leq 100\\)\n2. Daily demand for sugar cookies: \\(x_2 \\leq 80\\)\n3. Maximum production per day: \\(x_1 + x_2 \\leq 100\\)\n4. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced per day\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Daily demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")  # Daily demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"MaxProduction\")  # Maximum production per day\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(f\"Number of strawberry cookies produced: {x1.x}\")\n    print(f\"Number of sugar cookies produced: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced per day\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Daily demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")  # Daily demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"MaxProduction\")  # Maximum production per day\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(f\"Number of strawberry cookies produced: {x1.x}\")\n    print(f\"Number of sugar cookies produced: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.02s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.03s\nMaximized profit: $1070.0\nNumber of strawberry cookies produced: 20.0\nNumber of sugar cookies produced: 80.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: The number of strawberry cookies made per day.\n- x2: The number of sugar cookies made per day.\n\nObjective Function:\nMaximize profit Z = 5.5*x1 + 12*x2\n\nConstraints:\n1. Daily demand for strawberry cookies: x1 ≤ 100\n2. Daily demand for sugar cookies: x2 ≤ 80\n3. Maximum production capacity: x1 + x2 ≤ 100\n4. Non-negativity: x1, x2 ≥ 0\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \nx1: The number of strawberry cookies made per day.  \nx2: The number of sugar cookies made per day.  \n\nObjective Function:  \nMaximize Z = 5.5 * x1 + 12 * x2  \n\nConstraints:  \n1. x1 <= 100 (Daily demand for strawberry cookies is at most 100).  \n2. x2 <= 80 (Daily demand for sugar cookies is at most 80).  \n3. x1 + x2 <= 100 (The bakery can make a maximum of 100 cookies per day).  \n4. x1 >= 0, x2 >= 0 (Non-negativity).  \n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\( x_1 \\): The number of strawberry cookies produced daily.  \n- \\( x_2 \\): The number of sugar cookies produced daily.  \n\nObjective Function:  \nMaximize profit:  \n\\[\nZ = 5.5x_1 + 12x_2\n\\]  \n\nConstraints:  \n1. Daily demand for strawberry cookies:  \n\\[\nx_1 \\leq 100\n\\]  \n2. Daily demand for sugar cookies:  \n\\[\nx_2 \\leq 80\n\\]  \n3. Maximum production capacity per day:  \n\\[\nx_1 + x_2 \\leq 100\n\\]  \n4. Non-negativity constraints:  \n\\[\nx_1 \\geq 0, \\quad x_2 \\geq 0\n\\]  \n</model>  \n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ZetaBakeryOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Daily demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")       # Daily demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"ProductionCapacity\")  # Maximum production capacity per day\n\n# Set the objective function\nmodel.setObjective(5.5 * x1 + 12 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(round(model.objval)))\n    print(\"Number of strawberry cookies to produce: {}\".format(x1.x))\n    print(\"Number of sugar cookies to produce: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ZetaBakeryOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Daily demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")       # Daily demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"ProductionCapacity\")  # Maximum production capacity per day\n\n# Set the objective function\nmodel.setObjective(5.5 * x1 + 12 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(round(model.objval)))\n    print(\"Number of strawberry cookies to produce: {}\".format(x1.x))\n    print(\"Number of sugar cookies to produce: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.00s\nMaximized profit: $1070\nNumber of strawberry cookies to produce: 20.0\nNumber of sugar cookies to produce: 80.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of strawberry cookies produced per day.\n- \\(x_2\\): Number of sugar cookies produced per day.\n\nObjective Function:\n- Maximize total profit: \\(Z = 5.5x_1 + 12x_2\\)\n\nConstraints:\n1. Daily demand for strawberry cookies: \\(x_1 \\leq 100\\)\n2. Daily demand for sugar cookies: \\(x_2 \\leq 80\\)\n3. Maximum production capacity: \\(x_1 + x_2 \\leq 100\\)\n4. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced per day\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Daily demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")  # Daily demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"ProductionCapacity\")  # Maximum production capacity\n\n# Set the objective function to maximize total profit\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total profit: ${}\".format(model.objval))\n    print(\"Number of strawberry cookies to produce: {}\".format(x1.x))\n    print(\"Number of sugar cookies to produce: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced per day\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Daily demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")  # Daily demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"ProductionCapacity\")  # Maximum production capacity\n\n# Set the objective function to maximize total profit\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total profit: ${}\".format(model.objval))\n    print(\"Number of strawberry cookies to produce: {}\".format(x1.x))\n    print(\"Number of sugar cookies to produce: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.01s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.02s\nMaximized total profit: $1070.0\nNumber of strawberry cookies to produce: 20.0\nNumber of sugar cookies to produce: 80.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: number of strawberry cookies made per day.\n- x2: number of sugar cookies made per day.\n\nObjective Function:\nMaximize profit, Z = 5.5x1 + 12x2\n\nConstraints:\n1. Demand for strawberry cookies: x1 ≤ 100\n2. Demand for sugar cookies: x2 ≤ 80\n3. Staffing constraint: x1 + x2 ≤ 100\n4. Non-negativity: x1 ≥ 0, x2 ≥ 0\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies made per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies made per day\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"DemandStrawberry\")  # Demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"DemandSugar\")  # Demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"Staffing\")  # Staffing constraint\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum profit: ${}\".format(model.objval))\n    print(\"Number of strawberry cookies to make: {}\".format(x1.x))\n    print(\"Number of sugar cookies to make: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies made per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies made per day\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"DemandStrawberry\")  # Demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"DemandSugar\")  # Demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"Staffing\")  # Staffing constraint\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum profit: ${}\".format(model.objval))\n    print(\"Number of strawberry cookies to make: {}\".format(x1.x))\n    print(\"Number of sugar cookies to make: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.00s\nMaximum profit: $1070.0\nNumber of strawberry cookies to make: 20.0\nNumber of sugar cookies to make: 80.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- x1: The number of strawberry cookies produced.  \n- x2: The number of sugar cookies produced.  \n\nObjective Function:  \n- Maximize profit: Z = 5.5*x1 + 12*x2  \n\nConstraints:  \n1. Daily demand for strawberry cookies: x1 ≤ 100  \n2. Daily demand for sugar cookies: x2 ≤ 80  \n3. Staff capacity constraint: x1 + x2 ≤ 100  \n4. Non-negativity: x1, x2 ≥ 0  \n</model>  \n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Daily demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")  # Daily demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"StaffCapacity\")  # Staff capacity constraint\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(f\"Number of strawberry cookies to produce: {x1.x}\")\n    print(f\"Number of sugar cookies to produce: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Daily demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")  # Daily demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"StaffCapacity\")  # Staff capacity constraint\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(f\"Number of strawberry cookies to produce: {x1.x}\")\n    print(f\"Number of sugar cookies to produce: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.00s\nMaximized profit: $1070.0\nNumber of strawberry cookies to produce: 20.0\nNumber of sugar cookies to produce: 80.0",
        "pass": true
      }
    ],
    "answer": 317.5,
    "cloze": "Gabriel is growing pumpkins and carrots on his farm. He has ____ acres available on which he must grow ____ ____ acres of pumpkins and ____ ____ acres of carrots to meet demands. The profit per pumpkin is $____ and the profit per carrot is $____. He prefers to grow more carrots than pumpkins but limitations in his workforce allow him to grow ____ ____ ____ the amount of carrots as pumpkins. How many of each produce should Gabriel grow in order to ____ his profit?"
  },
  {
    "question": "In a financial portfolio management scenario, an investment manager needs to allocate funds across four different assets: $X1, X2, X3$, and $X4$. These could represent investments in various financial instruments such as bonds, stocks, mutual funds or derivatives. The total investment across all four assets cannot exceed \\$100000 due to budget constraints. Asset $X1$ requires a minimum investment of \\$10000 and a maximum of \\$60000, while asset $X2$ has an allowable range from \\$20000 to \\$80000. Asset $X3$ requires an investment ranging between \\$15000 and \\$50000. For asset $X4$, the minimum investment is \\$200 with no upper limit.\\n\\nThe manager also needs to ensure that the following conditions are met:\\n- The difference between 60% of the investment in asset X1 and 40% of the investment in asset X2 must be non-negative.\\n- The sum of investments in assets X3 and X4 should not be less than the combined investments in assets X1 and X2 by more than \\$30000.\\n- The difference between 70% of the investment in asset X3 and 50% of the investment in asset X4 should not exceed \\$500.\\n\\nEach unit invested in assets $X1, X2, X3$, and $X4$ incurs costs at rates of 0.05 , 0.08 , 0.12 , and 0.15 respectively. Given these conditions, calculate the minimum total cost for managing this portfolio (round your answer to two decimal places), given that all investments are integer multiples of one dollar.",
    "pass_count": 6,
    "pass_rate": 0.75,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_p\\): Acres of pumpkins grown.\n- \\(x_c\\): Acres of carrots grown.\n\nObjective Function:\n- Maximize total profit: \\(Z = 2.5x_p + 3.4x_c\\)\n\nConstraints:\n1. Total available land: \\(x_p + x_c \\leq 100\\)\n2. Minimum acres of pumpkins: \\(x_p \\geq 7\\)\n3. Minimum acres of carrots: \\(x_c \\geq 12\\)\n4. Limitation on workforce: \\(x_c \\leq 3x_p\\)\n5. Non-negativity: \\(x_p, x_c \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarming\")\n\n# Add decision variables\nx_p = model.addVar(lb=0, name=\"x_p\")  # Acres of pumpkins grown\nx_c = model.addVar(lb=0, name=\"x_c\")  # Acres of carrots grown\n\n# Add constraints\nmodel.addConstr(x_p + x_c <= 100, name=\"TotalLand\")  # Total available land\nmodel.addConstr(x_p >= 7, name=\"MinPumpkins\")  # Minimum acres of pumpkins\nmodel.addConstr(x_c >= 12, name=\"MinCarrots\")  # Minimum acres of carrots\nmodel.addConstr(x_c <= 3 * x_p, name=\"WorkforceLimit\")  # Limitation on workforce\n\n# Set the objective function\nmodel.setObjective(2.5 * x_p + 3.4 * x_c, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${:.2f}\".format(model.objval))\n    print(\"Acres of pumpkins grown: {:.2f}\".format(x_p.x))\n    print(\"Acres of carrots grown: {:.2f}\".format(x_c.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarming\")\n\n# Add decision variables\nx_p = model.addVar(lb=0, name=\"x_p\")  # Acres of pumpkins grown\nx_c = model.addVar(lb=0, name=\"x_c\")  # Acres of carrots grown\n\n# Add constraints\nmodel.addConstr(x_p + x_c <= 100, name=\"TotalLand\")  # Total available land\nmodel.addConstr(x_p >= 7, name=\"MinPumpkins\")  # Minimum acres of pumpkins\nmodel.addConstr(x_c >= 12, name=\"MinCarrots\")  # Minimum acres of carrots\nmodel.addConstr(x_c <= 3 * x_p, name=\"WorkforceLimit\")  # Limitation on workforce\n\n# Set the objective function\nmodel.setObjective(2.5 * x_p + 3.4 * x_c, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${:.2f}\".format(model.objval))\n    print(\"Acres of pumpkins grown: {:.2f}\".format(x_p.x))\n    print(\"Acres of carrots grown: {:.2f}\".format(x_c.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 4afcaab\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\nThe presolved problem is empty\n\nPostsolving\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    3.1750000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 3.1750000000e+02  Iterations: 0  Time: 0.00s\nMaximized profit: $317.50\nAcres of pumpkins grown: 25.00\nAcres of carrots grown: 75.00",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x: The number of acres used to grow pumpkins.\n- y: The number of acres used to grow carrots.\n\nObjective Function:\nMaximize profit Z = 2.5x + 3.4y\n\nConstraints:\n1. Land availability: x + y ≤ 100\n2. Minimum pumpkin area: x ≥ 7\n3. Minimum carrot area: y ≥ 12\n4. Workforce limitation: y ≤ 3x\n5. Non-negativity: x, y ≥ 0 and integers\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarm\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")  # Acres used to grow pumpkins\ny = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y\")  # Acres used to grow carrots\n\n# Add constraints\nmodel.addConstr(x + y <= 100, name=\"LandAvailability\")  # Land availability constraint\nmodel.addConstr(x >= 7, name=\"MinPumpkin\")  # Minimum pumpkin area constraint\nmodel.addConstr(y >= 12, name=\"MinCarrot\")  # Minimum carrot area constraint\nmodel.addConstr(y <= 3 * x, name=\"WorkforceLimit\")  # Workforce limitation constraint\n\n# Set the objective function\nmodel.setObjective(2.5 * x + 3.4 * y, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: {:.2f}\".format(model.objval))\n    print(\"Optimal solution: Grow {:.0f} acres of pumpkins and {:.0f} acres of carrots\".format(x.x, y.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarm\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")  # Acres used to grow pumpkins\ny = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y\")  # Acres used to grow carrots\n\n# Add constraints\nmodel.addConstr(x + y <= 100, name=\"LandAvailability\")  # Land availability constraint\nmodel.addConstr(x >= 7, name=\"MinPumpkin\")  # Minimum pumpkin area constraint\nmodel.addConstr(y >= 12, name=\"MinCarrot\")  # Minimum carrot area constraint\nmodel.addConstr(y <= 3 * x, name=\"WorkforceLimit\")  # Workforce limitation constraint\n\n# Set the objective function\nmodel.setObjective(2.5 * x + 3.4 * y, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: {:.2f}\".format(model.objval))\n    print(\"Optimal solution: Grow {:.0f} acres of pumpkins and {:.0f} acres of carrots\".format(x.x, y.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 28edbc8a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 317.500000000\nBest bound      : 317.500000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized profit: 317.50\nOptimal solution: Grow 25 acres of pumpkins and 75 acres of carrots",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): The number of acres of pumpkins Gabriel grows.\n- \\(x_2\\): The number of acres of carrots Gabriel grows.\n\nObjective Function:\n- Maximize profit: \\(Z = 2.5x_1 + 3.4x_2\\)\n\nConstraints:\n1. Total land constraint: \\(x_1 + x_2 \\leq 100\\)\n2. Minimum pumpkin constraint: \\(x_1 \\geq 7\\)\n3. Minimum carrot constraint: \\(x_2 \\geq 12\\)\n4. Workforce limitation constraint: \\(x_2 \\leq 3x_1\\)\n5. Non-negativity constraints: \\(x_1, x_2 \\geq 0\\)\n6. Integer constraints: \\(x_1, x_2 \\in \\mathbb{Z}^+\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarming\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Acres of pumpkins\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Acres of carrots\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"LandConstraint\")  # Total land constraint\nmodel.addConstr(x1 >= 7, name=\"MinPumpkinConstraint\")  # Minimum pumpkin constraint\nmodel.addConstr(x2 >= 12, name=\"MinCarrotConstraint\")  # Minimum carrot constraint\nmodel.addConstr(x2 <= 3*x1, name=\"WorkforceConstraint\")  # Workforce limitation constraint\n\n# Set the objective function to maximize profit\nmodel.setObjective(2.5*x1 + 3.4*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Number of acres of pumpkins: {}\".format(x1.x))\n    print(\"Number of acres of carrots: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarming\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Acres of pumpkins\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Acres of carrots\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"LandConstraint\")  # Total land constraint\nmodel.addConstr(x1 >= 7, name=\"MinPumpkinConstraint\")  # Minimum pumpkin constraint\nmodel.addConstr(x2 >= 12, name=\"MinCarrotConstraint\")  # Minimum carrot constraint\nmodel.addConstr(x2 <= 3*x1, name=\"WorkforceConstraint\")  # Workforce limitation constraint\n\n# Set the objective function to maximize profit\nmodel.setObjective(2.5*x1 + 3.4*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Number of acres of pumpkins: {}\".format(x1.x))\n    print(\"Number of acres of carrots: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 28edbc8a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 317.500000000\nBest bound      : 317.500000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized profit: $317.5\nNumber of acres of pumpkins: 25.0\nNumber of acres of carrots: 75.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: Acres of pumpkins to be grown.\n- x2: Acres of carrots to be grown.\n\nObjective Function:\n- Maximize profit: Z = 2.5*x1 + 3.4*x2\n\nConstraints:\n1. Total area: x1 + x2 ≤ 100\n2. Minimum pumpkin area: x1 ≥ 7\n3. Minimum carrot area: x2 ≥ 12\n4. Carrot-pumpkin ratio: x2 ≤ 3*x1\n5. Non-negativity: x1, x2 ≥ 0\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarm\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Acres of pumpkins\nx2 = model.addVar(lb=0, name=\"x2\")  # Acres of carrots\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"TotalArea\")  # Total area constraint\nmodel.addConstr(x1 >= 7, name=\"MinPumpkins\")  # Minimum pumpkin area constraint\nmodel.addConstr(x2 >= 12, name=\"MinCarrots\")  # Minimum carrot area constraint\nmodel.addConstr(x2 <= 3*x1, name=\"CarrotPumpkinRatio\")  # Carrot-pumpkin ratio constraint\n\n# Set the objective function to maximize profit\nmodel.setObjective(2.5*x1 + 3.4*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized profit: ${model.objval}\")\n    print(f\"Optimal acres of pumpkins to grow: {x1.x}\")\n    print(f\"Optimal acres of carrots to grow: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarm\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Acres of pumpkins\nx2 = model.addVar(lb=0, name=\"x2\")  # Acres of carrots\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"TotalArea\")  # Total area constraint\nmodel.addConstr(x1 >= 7, name=\"MinPumpkins\")  # Minimum pumpkin area constraint\nmodel.addConstr(x2 >= 12, name=\"MinCarrots\")  # Minimum carrot area constraint\nmodel.addConstr(x2 <= 3*x1, name=\"CarrotPumpkinRatio\")  # Carrot-pumpkin ratio constraint\n\n# Set the objective function to maximize profit\nmodel.setObjective(2.5*x1 + 3.4*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized profit: ${model.objval}\")\n    print(f\"Optimal acres of pumpkins to grow: {x1.x}\")\n    print(f\"Optimal acres of carrots to grow: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 4afcaab\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\nThe presolved problem is empty\n\nPostsolving\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    3.1750000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 3.1750000000e+02  Iterations: 0  Time: 0.00s\nMaximized profit: $317.5\nOptimal acres of pumpkins to grow: 25.0\nOptimal acres of carrots to grow: 75.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x\\): acres of pumpkins to be grown.  \n- \\(y\\): acres of carrots to be grown.  \n\nObjective Function:  \nMaximize profit:  \n\\(Z = 2.5x + 3.4y\\)  \n\nConstraints:  \n1. Total available land: \\(x + y \\leq 100\\)  \n2. Minimum pumpkins: \\(x \\geq 7\\)  \n3. Minimum carrots: \\(y \\geq 12\\)  \n4. Workforce limitation: \\(y \\leq 3x\\)  \n5. Non-negativity: \\(x, y \\geq 0\\)  \n6. Integer: \\(x, y\\) are integers.  \n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of acres of pumpkins grown.\n- \\(x_2\\): Number of acres of carrots grown.\n\nObjective Function:\n- Maximize profit: \\(Z = 2.5x_1 + 3.4x_2\\)\n\nConstraints:\n1. Total land available: \\(x_1 + x_2 \\leq 100\\)\n2. Minimum land for pumpkins: \\(x_1 \\geq 7\\)\n3. Minimum land for carrots: \\(x_2 \\geq 12\\)\n4. Limitation in workforce: \\(x_2 \\leq 3x_1\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n6. Integer: \\(x_1, x_2 \\in \\mathbb{Z}^+\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarm\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"TotalLand\")\nmodel.addConstr(x1 >= 7, name=\"MinPumpkins\")\nmodel.addConstr(x2 >= 12, name=\"MinCarrots\")\nmodel.addConstr(x2 <= 3*x1, name=\"WorkforceLimit\")\n\n# Set the objective function to maximize profit\nmodel.setObjective(2.5*x1 + 3.4*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum profit: ${}\".format(round(model.objval)))\n    print(\"Number of acres of pumpkins: {}\".format(x1.x))\n    print(\"Number of acres of carrots: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarm\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"TotalLand\")\nmodel.addConstr(x1 >= 7, name=\"MinPumpkins\")\nmodel.addConstr(x2 >= 12, name=\"MinCarrots\")\nmodel.addConstr(x2 <= 3*x1, name=\"WorkforceLimit\")\n\n# Set the objective function to maximize profit\nmodel.setObjective(2.5*x1 + 3.4*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum profit: ${}\".format(round(model.objval)))\n    print(\"Number of acres of pumpkins: {}\".format(x1.x))\n    print(\"Number of acres of carrots: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 28edbc8a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 317.500000000\nBest bound      : 317.500000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximum profit: $318\nNumber of acres of pumpkins: 25.0\nNumber of acres of carrots: 75.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of acres planted with pumpkins.\n- \\(x_2\\): Number of acres planted with carrots.\n\nObjective Function:\n- Maximize profit: \\(Z = 2.5x_1 + 3.4x_2\\)\n\nConstraints:\n1. Total land available: \\(x_1 + x_2 \\leq 100\\)\n2. Minimum land for pumpkins: \\(x_1 \\geq 7\\)\n3. Minimum land for carrots: \\(x_2 \\geq 12\\)\n4. Workforce limitation: \\(x_2 \\leq 3x_1\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_p\\): Number of acres allocated to pumpkins.\n- \\(x_c\\): Number of acres allocated to carrots.\n\nObjective Function:\nMaximize profit: \\(Z = 2.5x_p + 3.4x_c\\)\n\nConstraints:\n1. Total land: \\(x_p + x_c \\leq 100\\)\n2. Minimum land for pumpkins: \\(x_p \\geq 7\\)\n3. Minimum land for carrots: \\(x_c \\geq 12\\)\n4. Workforce limitation: \\(x_c \\leq 3x_p\\)\n5. Non-negativity: \\(x_p, x_c \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"GabrielFarmerOptimization\")\n\n# Add decision variables\nx_p = model.addVar(lb=0, name=\"x_p\")  # Acres allocated to pumpkins\nx_c = model.addVar(lb=0, name=\"x_c\")  # Acres allocated to carrots\n\n# Set the objective function\nmodel.setObjective(2.5 * x_p + 3.4 * x_c, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x_p + x_c <= 100, name=\"LandLimitation\")  # Total land\nmodel.addConstr(x_p >= 7, name=\"MinimumPumpkinLand\")  # Minimum pumpkin land\nmodel.addConstr(x_c >= 12, name=\"MinimumCarrotLand\")  # Minimum carrot land\nmodel.addConstr(x_c <= 3 * x_p, name=\"WorkforceLimitation\")  # Workforce limitation\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Optimal solution: Grow {} acres of pumpkins and {} acres of carrots\".format(x_p.x, x_c.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"GabrielFarmerOptimization\")\n\n# Add decision variables\nx_p = model.addVar(lb=0, name=\"x_p\")  # Acres allocated to pumpkins\nx_c = model.addVar(lb=0, name=\"x_c\")  # Acres allocated to carrots\n\n# Set the objective function\nmodel.setObjective(2.5 * x_p + 3.4 * x_c, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x_p + x_c <= 100, name=\"LandLimitation\")  # Total land\nmodel.addConstr(x_p >= 7, name=\"MinimumPumpkinLand\")  # Minimum pumpkin land\nmodel.addConstr(x_c >= 12, name=\"MinimumCarrotLand\")  # Minimum carrot land\nmodel.addConstr(x_c <= 3 * x_p, name=\"WorkforceLimitation\")  # Workforce limitation\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Optimal solution: Grow {} acres of pumpkins and {} acres of carrots\".format(x_p.x, x_c.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 4afcaab\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\nThe presolved problem is empty\n\nPostsolving\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    3.1750000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 3.1750000000e+02  Iterations: 0  Time: 0.00s\nMaximized profit: $317.5\nOptimal solution: Grow 25.0 acres of pumpkins and 75.0 acres of carrots",
        "pass": true
      }
    ],
    "answer": 7066.7,
    "cloze": "In a financial portfolio management scenario, an investment manager needs to allocate funds across four different assets: $X1, X2, X3$, and $X4$. These could represent investments in various financial instruments such as bonds, stocks, mutual funds or derivatives. The total investment across all four assets ____ ____ $____ due to budget constraints. Asset $X1$ requires ____ ____ of $____ and ____ ____ of $____, while asset $X2$ has an allowable range from $____ to $____. Asset $X3$ requires an investment ranging between $____ and $____. For asset $X4$, ____ ____ is $____ with ____ ____ ____.\n\nThe manager also needs to ensure that the following conditions are met:\n- The difference between ____ of the investment in asset X1 and ____ of the investment in asset X2 must be ____.\n- The sum of investments in assets X3 and X4 should ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____.\n- The difference between ____ of the investment in asset X3 and ____ of the investment in asset X4 should ____ ____ $____.\n\nEach unit invested in assets $X1, X2, X3$, and $X4$ incurs costs at rates of ____ , ____ , ____ , and ____ respectively. Given these conditions, calculate the ____ total cost for managing this portfolio (round your answer to two decimal places), given that all investments are integer multiples of one dollar."
  },
  {
    "question": "Star Oil Company is considering five different investment opportunities. The cash outflows and net present values (NPVs) (in millions of dollars) for each opportunity are given in Table 7. Specifically, Investment 1 has a time 0 cash outflow of $11 million and a time 1 cash outflow of $3 million, with an NPV of $13 million. Investment 2 requires a time 0 outflow of $53 million and a time 1 outflow of $6 million, yielding an NPV of $16 million. Investment 3 has smaller outflows of $5 million at both time 0 and time 1 and also an NPV of $16 million. Investment 4 asks for a time 0 outflow of $5 million and a minimal $1 million at time 1, with an NPV of $14 million. Lastly, Investment 5 requires a $29 million outflow at time 0 and a significant $34 million at time 1, resulting in the highest NPV of $39 million. Star Oil has $40 million available for investment at time 0, and it estimates that $20 million will be available for investment at time 1. Star Oil may purchase any fraction of each investment, in which case, the cash outflows and NPV are adjusted proportionally. For example, if Star Oil purchases one-fifth of investment 3, then a cash outflow of (1/5)*5=1 million dollars or $1 million would be required at time 0, and a cash outflow of (1/5)*5=1 million dollars or $1 million would be required at time 1. The one-fifth share of investment 3 would yield an NPV of (1/5)*16=3.2 million dollars or $3.2 million. Star Oil wants to maximize the NPV that can be obtained by investing in investments 1-5. The goal is to formulate an LP that will help achieve this objective. Assume that any funds left over at time 0 cannot be used at time 1. Find the maximum NPV in million dollars.",
    "pass_count": 5,
    "pass_rate": 0.625,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of low-power air conditioners purchased.\n- \\(x_2\\): Number of high-power air conditioners purchased.\n\nObjective Function:\n- Minimize the total number of air conditioners: \\(Z = x_1 + x_2\\).\n\nConstraints:\n1. Cooling requirement: \\(12x_1 + 17x_2 \\geq 250\\).\n2. Electricity requirement: \\(150x_1 + 250x_2 \\leq 8000\\).\n3. Limit on low-power air conditioners: \\(x_1 \\leq 0.3x_2\\).\n4. Minimum number of high-power air conditioners: \\(x_2 \\geq 7\\).\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\).\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of low-power air conditioners\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of high-power air conditioners\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(12 * x1 + 17 * x2 >= 250, name=\"CoolingRequirement\")  # Cooling requirement constraint\nmodel.addConstr(150 * x1 + 250 * x2 <= 8000, name=\"ElectricityRequirement\")  # Electricity requirement constraint\nmodel.addConstr(x1 <= 0.3 * x2, name=\"LowPowerLimit\")  # Limit on low-power air conditioners\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimum\")  # Minimum number of high-power air conditioners\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-power air conditioners: {}\".format(x1.x))\n    print(\"Number of high-power air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of low-power air conditioners\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of high-power air conditioners\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(12 * x1 + 17 * x2 >= 250, name=\"CoolingRequirement\")  # Cooling requirement constraint\nmodel.addConstr(150 * x1 + 250 * x2 <= 8000, name=\"ElectricityRequirement\")  # Electricity requirement constraint\nmodel.addConstr(x1 <= 0.3 * x2, name=\"LowPowerLimit\")  # Limit on low-power air conditioners\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimum\")  # Minimum number of high-power air conditioners\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-power air conditioners: {}\".format(x1.x))\n    print(\"Number of high-power air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 2bcce11c\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 7 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    7.9169878987e+00            1           0       0.00s\nDual             1    1.4706023774e+01            0           0       0.00s\nPostsolving\nDual             1    1.4705882353e+01            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.4705882353e+01  Iterations: 1  Time: 0.00s\nMinimum total number of air conditioners: 14.705882352941176\nNumber of low-power air conditioners: 0.0\nNumber of high-power air conditioners: 14.705882352941176",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of low-powered air conditioners.\n- \\(x_2\\): Number of high-powered air conditioners.\n\nObjective Function:\n- Minimize the total number of air conditioners: \\(Z = x_1 + x_2\\).\n\nConstraints:\n1. Cooling requirement: \\(12x_1 + 17x_2 \\geq 250\\).\n2. Electricity requirement: \\(150x_1 + 250x_2 \\leq 8000\\).\n3. Low-powered air conditioner limit: \\(x_1 \\leq 0.30(x_1 + x_2)\\).\n4. Minimum high-powered air conditioners: \\(x_2 \\geq 7\\).\n5. Non-negativity and integer: \\(x_1, x_2 \\geq 0\\) and integers.\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- x: Number of low-power air conditioners purchased.\n- y: Number of high-power air conditioners purchased.\n\nObjective Function:\n- Minimize total number of air conditioners: Z = x + y\n\nConstraints:\n1. Cooling capacity requirement: 12x + 17y ≥ 250\n2. Electricity usage limit: 150x + 250y ≤ 8000\n3. Low-power model limit: x ≤ 0.30y\n4. High-power model requirement: y ≥ 7\n5. Non-negativity and integer: x, y ≥ 0 and integers\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"StrataAirConditionerModel\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")\ny = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y\")\n\n# Add constraints\nmodel.addConstr(12*x + 17*y >= 250, name=\"CoolingCapacity\")\nmodel.addConstr(150*x + 250*y <= 8000, name=\"ElectricityUsage\")\nmodel.addConstr(x <= 0.30*y, name=\"LowPowerModelLimit\")\nmodel.addConstr(y >= 7, name=\"HighPowerModelRequirement\")\n\n# Set the objective function\nmodel.setObjective(x + y, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {:.0f}\".format(model.objval))\n    print(\"Number of low-power air conditioners to purchase: {:.0f}\".format(x.x))\n    print(\"Number of high-power air conditioners to purchase: {:.0f}\".format(y.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"StrataAirConditionerModel\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")\ny = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y\")\n\n# Add constraints\nmodel.addConstr(12*x + 17*y >= 250, name=\"CoolingCapacity\")\nmodel.addConstr(150*x + 250*y <= 8000, name=\"ElectricityUsage\")\nmodel.addConstr(x <= 0.30*y, name=\"LowPowerModelLimit\")\nmodel.addConstr(y >= 7, name=\"HighPowerModelRequirement\")\n\n# Set the objective function\nmodel.setObjective(x + y, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {:.0f}\".format(model.objval))\n    print(\"Number of low-power air conditioners to purchase: {:.0f}\".format(x.x))\n    print(\"Number of high-power air conditioners to purchase: {:.0f}\".format(y.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: d058e560\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 7 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  9.000000e+00            --     Inf  0.01s\nH        0         1      --       0  9.000000e+00  3.000000e+01  70.00%  0.01s\nH        0         1      --       0  9.000000e+00  1.500000e+01  40.00%  0.02s\n         0         1      --       0  1.500000e+01  1.500000e+01  0.000%  0.02s\n         1         0     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.02s\n         1         0     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.02s\n\nBest solution   : 15.000000000\nBest bound      : 15.000000000\nBest gap        : 0.0000%\nSolve time      : 0.02\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of air conditioners: 15\nNumber of low-power air conditioners to purchase: 0\nNumber of high-power air conditioners to purchase: 15",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): The number of low-powered air conditioners.\n- \\(x_2\\): The number of high-powered air conditioners.\n\nObjective Function:\nMinimize \\(Z = x_1 + x_2\\)\n\nConstraints:\n1. Cooling capacity: \\(12x_1 + 17x_2 \\geq 250\\)\n2. Electricity usage: \\(150x_1 + 250x_2 \\leq 8000\\)\n3. Limit on low-powered air conditioners: \\(x_1 \\leq 0.3x_2\\)\n4. Minimum high-powered air conditioners: \\(x_2 \\geq 7\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\) and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerModel\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of low-powered air conditioners\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of high-powered air conditioners\n\n# Set the objective function to minimize the total number of air conditioners\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(12*x1 + 17*x2 >= 250, name=\"CoolingCapacity\")  # Cooling capacity constraint\nmodel.addConstr(150*x1 + 250*x2 <= 8000, name=\"ElectricityUsage\")  # Electricity usage constraint\nmodel.addConstr(x1 <= 0.3*x2, name=\"LowPowerLimit\")  # Limit on low-powered air conditioners\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimum\")  # Minimum high-powered air conditioners\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {:.0f}\".format(model.objval))\n    print(\"Number of low-powered air conditioners: {:.0f}\".format(x1.x))\n    print(\"Number of high-powered air conditioners: {:.0f}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerModel\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of low-powered air conditioners\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of high-powered air conditioners\n\n# Set the objective function to minimize the total number of air conditioners\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(12*x1 + 17*x2 >= 250, name=\"CoolingCapacity\")  # Cooling capacity constraint\nmodel.addConstr(150*x1 + 250*x2 <= 8000, name=\"ElectricityUsage\")  # Electricity usage constraint\nmodel.addConstr(x1 <= 0.3*x2, name=\"LowPowerLimit\")  # Limit on low-powered air conditioners\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimum\")  # Minimum high-powered air conditioners\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {:.0f}\".format(model.objval))\n    print(\"Number of low-powered air conditioners: {:.0f}\".format(x1.x))\n    print(\"Number of high-powered air conditioners: {:.0f}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: d058e560\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 7 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  9.000000e+00            --     Inf  0.00s\nH        0         1      --       0  9.000000e+00  3.000000e+01  70.00%  0.00s\nH        0         1      --       0  9.000000e+00  1.500000e+01  40.00%  0.01s\n         0         1      --       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         0     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         0     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n\nBest solution   : 15.000000000\nBest bound      : 15.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of air conditioners: 15\nNumber of low-powered air conditioners: 0\nNumber of high-powered air conditioners: 15",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of low-power air conditioners purchased.\n- \\(x_2\\): Number of high-power air conditioners purchased.\n\nObjective Function:\n- Minimize the total number of air conditioners:  \n  \\(Z = x_1 + x_2\\)\n\nConstraints:\n1. Cooling capacity requirement:  \n   \\(12x_1 + 17x_2 \\geq 250\\)\n2. Electricity usage limit:  \n   \\(150x_1 + 250x_2 \\leq 8000\\)\n3. Limit on low-power air conditioners:  \n   \\(x_1 \\leq 0.3x_2\\)\n4. Minimum number of high-power air conditioners:  \n   \\(x_2 \\geq 7\\)\n5. Non-negativity:  \n   \\(x_1, x_2 \\geq 0\\) and integers\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): the number of low-powered air conditioners.\n- \\(x_2\\): the number of high-powered air conditioners.\n\nObjective Function:\nMinimize the total number of air conditioners:\n- \\(Z = x_1 + x_2\\)\n\nConstraints:\n1. Cooling capacity requirement: \\(12x_1 + 17x_2 \\geq 250\\)\n2. Electricity requirement: \\(150x_1 + 250x_2 \\leq 8000\\)\n3. Limitation on low-powered air conditioners: \\(x_1 \\leq 0.3x_2\\)\n4. Minimum number of high-powered air conditioners: \\(x_2 \\geq 7\\)\n5. Non-negativity and integer: \\(x_1, x_2 \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"AirConditionerOptimization\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")  # Number of low-powered air conditioners\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")  # Number of high-powered air conditioners\n\n# Add constraints\nmodel.addConstr(12 * x1 + 17 * x2 >= 250, name=\"CoolingRequirement\")  # Cooling capacity requirement\nmodel.addConstr(150 * x1 + 250 * x2 <= 8000, name=\"ElectricityRequirement\")  # Electricity requirement\nmodel.addConstr(x1 <= 0.3 * x2, name=\"LowPowerLimit\")  # Limitation on low-powered air conditioners\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimum\")  # Minimum number of high-powered air conditioners\n\n# Set the objective function to minimize the total number of air conditioners\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-powered air conditioners: {}\".format(x1.x))\n    print(\"Number of high-powered air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"AirConditionerOptimization\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")  # Number of low-powered air conditioners\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")  # Number of high-powered air conditioners\n\n# Add constraints\nmodel.addConstr(12 * x1 + 17 * x2 >= 250, name=\"CoolingRequirement\")  # Cooling capacity requirement\nmodel.addConstr(150 * x1 + 250 * x2 <= 8000, name=\"ElectricityRequirement\")  # Electricity requirement\nmodel.addConstr(x1 <= 0.3 * x2, name=\"LowPowerLimit\")  # Limitation on low-powered air conditioners\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimum\")  # Minimum number of high-powered air conditioners\n\n# Set the objective function to minimize the total number of air conditioners\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-powered air conditioners: {}\".format(x1.x))\n    print(\"Number of high-powered air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: d058e560\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 7 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  9.000000e+00            --     Inf  0.00s\nH        0         1      --       0  9.000000e+00  3.000000e+01  70.00%  0.00s\nH        0         1      --       0  9.000000e+00  1.500000e+01  40.00%  0.01s\n         0         1      --       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         0     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         0     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n\nBest solution   : 15.000000000\nBest bound      : 15.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of air conditioners: 15.0\nNumber of low-powered air conditioners: 0.0\nNumber of high-powered air conditioners: 15.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): the number of low-power air conditioners.\n- \\(x_2\\): the number of high-power air conditioners.\n\nObjective Function:\nMinimize the total number of air conditioners: \\(Z = x_1 + x_2\\).\n\nConstraints:\n1. The total cooling capacity should be at least 250 housing units: \\(12x_1 + 17x_2 \\geq 250\\).\n2. The total electricity usage should not exceed 8000 units: \\(150x_1 + 250x_2 \\leq 8000\\).\n3. The number of low-power models should be limited to 30% of the total number of air conditioners: \\(x_1 \\leq 0.3(x_1 + x_2)\\).\n4. The number of high-power models should be at least 7: \\(x_2 \\geq 7\\).\n5. Non-negativity and integer constraints: \\(x_1, x_2 \\geq 0\\) and integers.\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of low-powered air conditioners purchased.\n- \\(x_2\\): Number of high-powered air conditioners purchased.\n\nObjective Function:\n- Minimize the total number of air conditioners: \\(Z = x_1 + x_2\\).\n\nConstraints:\n1. Cooling requirement: \\(12x_1 + 17x_2 \\geq 250\\).\n2. Electricity requirement: \\(150x_1 + 250x_2 \\leq 8000\\).\n3. Limitation on low-powered air conditioners: \\(x_1 \\leq 0.3(x_1 + x_2)\\).\n4. Minimum high-powered air conditioners: \\(x_2 \\geq 7\\).\n5. Non-negativity and integer: \\(x_1, x_2 \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerPurchasing\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of low-powered air conditioners\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of high-powered air conditioners\n\n# Add constraints\nmodel.addConstr(12*x1 + 17*x2 >= 250, name=\"CoolingRequirement\")  # Cooling requirement\nmodel.addConstr(150*x1 + 250*x2 <= 8000, name=\"ElectricityRequirement\")  # Electricity requirement\nmodel.addConstr(x1 <= 0.3*(x1 + x2), name=\"LowPowerLimitation\")  # Limitation on low-powered air conditioners\nmodel.addConstr(x2 >= 7, name=\"HighPowerMin\")  # Minimum high-powered air conditioners\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimized total number of air conditioners: {}\".format(model.objval))\n    print(\"Optimal solution:\")\n    print(\"Number of low-powered air conditioners: {}\".format(x1.x))\n    print(\"Number of high-powered air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerPurchasing\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of low-powered air conditioners\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of high-powered air conditioners\n\n# Add constraints\nmodel.addConstr(12*x1 + 17*x2 >= 250, name=\"CoolingRequirement\")  # Cooling requirement\nmodel.addConstr(150*x1 + 250*x2 <= 8000, name=\"ElectricityRequirement\")  # Electricity requirement\nmodel.addConstr(x1 <= 0.3*(x1 + x2), name=\"LowPowerLimitation\")  # Limitation on low-powered air conditioners\nmodel.addConstr(x2 >= 7, name=\"HighPowerMin\")  # Minimum high-powered air conditioners\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimized total number of air conditioners: {}\".format(model.objval))\n    print(\"Optimal solution:\")\n    print(\"Number of low-powered air conditioners: {}\".format(x1.x))\n    print(\"Number of high-powered air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 192fcc03\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 7 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  7.000000e+00            --     Inf  0.00s\nH        0         1      --       0  7.000000e+00  2.600000e+01  73.08%  0.00s\nH        0         1      --       0  7.000000e+00  1.600000e+01  56.25%  0.01s\nH        0         1      --       0  7.000000e+00  1.500000e+01  53.33%  0.01s\n         1         1     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         1     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n\nBest solution   : 15.000000000\nBest bound      : 15.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimized total number of air conditioners: 15.0\nOptimal solution:\nNumber of low-powered air conditioners: 0.0\nNumber of high-powered air conditioners: 15.0",
        "pass": true
      }
    ],
    "answer": 57.45,
    "cloze": "Star Oil Company is considering five different investment opportunities. The cash outflows and net present values (NPVs) (in millions of dollars) for each opportunity are given in Table 7. Specifically, Investment 1 has a time 0 cash outflow of $____ million and a time 1 cash outflow of $____ million, with an NPV of $____ million. Investment 2 requires a time 0 outflow of $____ million and a time 1 outflow of $____ million, yielding an NPV of $____ million. Investment 3 has smaller outflows of $____ million at both time 0 and time 1 and also an NPV of $____ million. Investment 4 asks for a time 0 outflow of $____ million and a minimal $____ million at time 1, with an NPV of $____ million. Lastly, Investment 5 requires a $____ million outflow at time 0 and a significant $____ million at time 1, resulting in the highest NPV of $____ million. Star Oil has $____ million available for investment at time 0, and it estimates that $____ million will be available for investment at time 1. Star Oil may purchase any fraction of each investment, in which case, the cash outflows and NPV are adjusted proportionally. For example, if Star Oil purchases one-fifth of investment 3, then a cash outflow of (1/5)*5=1 million dollars or $1 million would be required at time 0, and a cash outflow of (1/5)*5=1 million dollars or $1 million would be required at time 1. The one-fifth share of investment 3 would yield an NPV of (1/5)*16=3.2 million dollars or $3.2 million. Star Oil wants to ____ the NPV that can be obtained by investing in investments 1-5. The goal is to formulate an LP that will help achieve this objective. Assume that any funds left over at time 0 cannot be used at time 1. Find the ____ NPV in million dollars."
  },
  {
    "question": "Zeta Bakery sells two types of cookies. They sell a strawberry cookie and a sugar cookie. Let's say they make x1 strawberry cookies, at a profit of $5.5 each, and x2 sugar cookies, at a profit of $12 each (x1 and x2 are unknowns both greater than or equal to 0). The daily demand for these cookies is at most 100 strawberry cookies and at most 80 sugar cookies. The bakery is short staffed and can make a maximum of 100 cookies of either type per day. How much of each cookie should the bakery make in order to maximize profit?",
    "pass_count": 4,
    "pass_rate": 0.5,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_1\\): The number of units of product type 1 produced daily.  \n- \\(x_2\\): The number of units of product type 2 produced daily.  \n- \\(o_1\\): The number of overtime hours for assembly labor.  \n\nObjective Function:  \nMaximize daily profit:  \n\\[\nZ = (9 - 1.2)x_1 + (8 - 0.9)x_2 - 7o_1\n\\]\n\nConstraints:  \n1. Assembly labor limit:  \n\\[\n\\frac{1}{4}x_1 + \\frac{1}{3}x_2 + o_1 \\leq 90\n\\]  \n2. Testing labor limit:  \n\\[\n\\frac{1}{8}x_1 + \\frac{1}{3}x_2 \\leq 80\n\\]  \n3. Overtime limit:  \n\\[\no_1 \\leq 50\n\\]  \n4. Non-negativity:  \n\\[\nx_1, x_2, o_1 \\geq 0\n\\]  \n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_1\\): Number of units of product 1 produced daily.  \n- \\(x_2\\): Number of units of product 2 produced daily.  \n\nObjective Function:  \nMaximize the daily profit:  \n\\[\nZ = 9x_1 + 8x_2 - 7\\left(\\frac{1}{4}x_1 + \\frac{1}{3}x_2\\right)\n\\]  \nSimplify:  \n\\[\nZ = 9x_1 + 8x_2 - 1.75x_1 - 2.33x_2 = 7.25x_1 + 5.67x_2\n\\]  \n\nConstraints:  \n1. Assembly labor constraint:  \n   \\[\n   \\frac{1}{4}x_1 + \\frac{1}{3}x_2 \\leq 90\n   \\]  \n2. Testing constraint:  \n   \\[\n   \\frac{1}{8}x_1 + \\frac{1}{3}x_2 \\leq 80\n   \\]  \n3. Overtime labor constraint:  \n   \\[\n   \\frac{1}{4}x_1 + \\frac{1}{3}x_2 \\leq 50\n   \\]  \n4. Non-negativity and integer:  \n   \\[\n   x_1, x_2 \\geq 0 \\text{ and integer}\n   \\]\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of units of product 1 produced per day.\n- \\(x_2\\): Number of units of product 2 produced per day.\n- \\(o_1\\): Overtime hours for assembly labor.\n\nObjective Function:\nMaximize daily profit:  \n\\(Z = 9x_1 + 8x_2 - 7o_1\\)\n\nConstraints:\n1. Assembly labor: \\(0.25x_1 + 0.3333x_2 \\leq 90\\)\n2. Testing: \\(0.125x_1 + 0.3333x_2 \\leq 80\\)\n3. Overtime: \\(o_1 \\leq 50\\)\n4. Non-negativity and integer: \\(x_1, x_2, o_1 \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"MaximizeProfit\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Units of product 1 produced per day\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Units of product 2 produced per day\no1 = model.addVar(lb=0, ub=50, vtype=COPT.INTEGER, name=\"o1\")  # Overtime hours for assembly labor\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*o1, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(0.25*x1 + 0.3333*x2 <= 90, name=\"AssemblyLabor\")  # Assembly labor constraint\nmodel.addConstr(0.125*x1 + 0.3333*x2 <= 80, name=\"Testing\")  # Testing constraint\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${}\".format(round(model.objval)))\n    print(\"Number of units of product 1 produced per day: {}\".format(x1.x))\n    print(\"Number of units of product 2 produced per day: {}\".format(x2.x))\n    print(\"Overtime hours for assembly labor: {}\".format(o1.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"MaximizeProfit\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Units of product 1 produced per day\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Units of product 2 produced per day\no1 = model.addVar(lb=0, ub=50, vtype=COPT.INTEGER, name=\"o1\")  # Overtime hours for assembly labor\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*o1, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(0.25*x1 + 0.3333*x2 <= 90, name=\"AssemblyLabor\")  # Assembly labor constraint\nmodel.addConstr(0.125*x1 + 0.3333*x2 <= 80, name=\"Testing\")  # Testing constraint\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${}\".format(round(model.objval)))\n    print(\"Number of units of product 1 produced per day: {}\".format(x1.x))\n    print(\"Number of units of product 2 produced per day: {}\".format(x2.x))\n    print(\"Overtime hours for assembly labor: {}\".format(o1.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 59197f15\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    2 rows, 3 columns and 4 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 3240.000000000\nBest bound      : 3240.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized daily profit: $3240\nNumber of units of product 1 produced per day: 360.0\nNumber of units of product 2 produced per day: 0.0\nOvertime hours for assembly labor: 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of units of product of the first type produced daily.\n- \\(x_2\\): Number of units of product of the second type produced daily.\n- \\(o_1\\): Number of overtime hours for assembly labor used daily.\n- \\(o_2\\): Number of overtime hours for testing used daily.\n\nObjective Function:\nMaximize daily profit:\n\\[\nZ = 9x_1 + 8x_2 - 7o_1\n\\]\n\nConstraints:\n1. Assembly labor hours: \\(0.25x_1 + 0.33x_2 + o_1 \\leq 90\\)\n2. Testing hours: \\(0.125x_1 + 0.33x_2 + o_2 \\leq 80\\)\n3. Overtime assembly labor hours: \\(o_1 \\leq 50\\)\n4. Non-negativity: \\(x_1, x_2, o_1, o_2 \\geq 0\\)\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_1\\): Number of products of the first type produced per day.  \n- \\(x_2\\): Number of products of the second type produced per day.  \n\nObjective Function:  \nMaximize daily profit:  \n\\[\nZ = 9x_1 + 8x_2 - 7 \\cdot \\max(0, \\frac{x_1}{4} + \\frac{x_2}{3} - 90)\n\\]\n\nConstraints:  \n1. Assembly labor:  \n\\[\n\\frac{x_1}{4} + \\frac{x_2}{3} \\leq 90\n\\]  \n2. Testing labor:  \n\\[\n\\frac{x_1}{8} + \\frac{x_2}{3} \\leq 80\n\\]  \n3. Non-negativity:  \n\\[\nx_1, x_2 \\geq 0\n\\]  \n4. Integer:  \n\\[\nx_1, x_2 \\in \\mathbb{Z}\n\\]  \n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- x1: Number of units of product 1 produced daily.  \n- x2: Number of units of product 2 produced daily.  \n\nObjective Function:  \nMaximize daily profit:  \nZ = (9 - 1.2 - 7*(1/4)) * x1 + (8 - 0.9 - 7*(1/3)) * x2  \n\nConstraints:  \n1. Assembly labor constraint: (1/4)*x1 + (1/3)*x2 ≤ 90  \n2. Testing labor constraint: (1/8)*x1 + (1/3)*x2 ≤ 80  \n3. Overtime assembly labor constraint: (1/4)*x1 + (1/3)*x2 ≤ 90 + 50  \n4. Non-negativity: x1, x2 ≥ 0 and integer.  \n</model>  \n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Units of product 1 produced daily\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Units of product 2 produced daily\n\n# Set the objective function\nprofit = (9 - 1.2 - 7 * (1/4)) * x1 + (8 - 0.9 - 7 * (1/3)) * x2\nmodel.setObjective(profit, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr((1/4)*x1 + (1/3)*x2 <= 90, name=\"AssemblyLabor\")  # Assembly labor constraint\nmodel.addConstr((1/8)*x1 + (1/3)*x2 <= 80, name=\"TestingLabor\")  # Testing labor constraint\nmodel.addConstr((1/4)*x1 + (1/3)*x2 <= 90 + 50, name=\"OvertimeAssembly\")  # Overtime assembly labor constraint\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${}\".format(round(model.objval)))\n    print(\"Optimal production plan:\")\n    print(\"Product 1: {} units\".format(x1.x))\n    print(\"Product 2: {} units\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Units of product 1 produced daily\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Units of product 2 produced daily\n\n# Set the objective function\nprofit = (9 - 1.2 - 7 * (1/4)) * x1 + (8 - 0.9 - 7 * (1/3)) * x2\nmodel.setObjective(profit, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr((1/4)*x1 + (1/3)*x2 <= 90, name=\"AssemblyLabor\")  # Assembly labor constraint\nmodel.addConstr((1/8)*x1 + (1/3)*x2 <= 80, name=\"TestingLabor\")  # Testing labor constraint\nmodel.addConstr((1/4)*x1 + (1/3)*x2 <= 90 + 50, name=\"OvertimeAssembly\")  # Overtime assembly labor constraint\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${}\".format(round(model.objval)))\n    print(\"Optimal production plan:\")\n    print(\"Product 1: {} units\".format(x1.x))\n    print(\"Product 2: {} units\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: d5ef2585\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 2178.000000000\nBest bound      : 2178.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized daily profit: $2178\nOptimal production plan:\nProduct 1: 360.0 units\nProduct 2: 0.0 units",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: the number of products of the first type produced per day.\n- x2: the number of products of the second type produced per day.\n- y1: the number of hours of overtime assembly labor used per day.\n- y2: the number of hours of overtime testing labor used per day.\n\nObjective Function:\nMaximize the daily profit:\nZ = 9*x1 + 8*x2 - 7*y1 - 7*y2\n\nConstraints:\n1. Assembly labor constraint: (1/4)*x1 + (1/3)*x2 ≤ 90\n2. Testing labor constraint: (1/8)*x1 + (1/3)*x2 ≤ 80\n3. Overtime assembly labor constraint: y1 ≤ 50\n4. Non-negativity and integer constraints: x1, x2, y1, y2 ≥ 0 and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionPlanning\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\ny1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y1\")\ny2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y2\")\n\n# Add constraints\nmodel.addConstr((1/4)*x1 + (1/3)*x2 <= 90, name=\"AssemblyLaborConstraint\")\nmodel.addConstr((1/8)*x1 + (1/3)*x2 <= 80, name=\"TestingLaborConstraint\")\nmodel.addConstr(y1 <= 50, name=\"OvertimeAssemblyLaborConstraint\")\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*y1 - 7*y2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${:.0f}\".format(model.objval))\n    print(\"Optimal production plan:\")\n    print(\"Product of the first type: {} units\".format(x1.x))\n    print(\"Product of the second type: {} units\".format(x2.x))\n    print(\"Overtime assembly labor used: {} hours\".format(y1.x))\n    print(\"Overtime testing labor used: {} hours\".format(y2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionPlanning\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\ny1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y1\")\ny2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y2\")\n\n# Add constraints\nmodel.addConstr((1/4)*x1 + (1/3)*x2 <= 90, name=\"AssemblyLaborConstraint\")\nmodel.addConstr((1/8)*x1 + (1/3)*x2 <= 80, name=\"TestingLaborConstraint\")\nmodel.addConstr(y1 <= 50, name=\"OvertimeAssemblyLaborConstraint\")\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*y1 - 7*y2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${:.0f}\".format(model.objval))\n    print(\"Optimal production plan:\")\n    print(\"Product of the first type: {} units\".format(x1.x))\n    print(\"Product of the second type: {} units\".format(x2.x))\n    print(\"Overtime assembly labor used: {} hours\".format(y1.x))\n    print(\"Overtime testing labor used: {} hours\".format(y2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: c2c8e318\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    3 rows, 4 columns and 5 non-zero elements\n    4 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 3240.000000000\nBest bound      : 3240.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized daily profit: $3240\nOptimal production plan:\nProduct of the first type: 360.0 units\nProduct of the second type: 0.0 units\nOvertime assembly labor used: 0.0 hours\nOvertime testing labor used: 0.0 hours",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of units of product 1 produced per day.\n- \\(x_2\\): Number of units of product 2 produced per day.\n- \\(o_1\\): Overtime hours for assembly labor per day.\n\nObjective Function:\n- Maximize daily profit: \\(Z = 9x_1 + 8x_2 - 7o_1\\)\n\nConstraints:\n1. Assembly labor: \\(\\frac{1}{4}x_1 + \\frac{1}{3}x_2 + o_1 \\leq 90\\)\n2. Testing labor: \\(\\frac{1}{8}x_1 + \\frac{1}{3}x_2 \\leq 80\\)\n3. Overtime assembly labor: \\(o_1 \\leq 50\\)\n4. Non-negativity: \\(x_1, x_2, o_1 \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"CompanyProductionOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")\nx2 = model.addVar(lb=0, name=\"x2\")\no1 = model.addVar(lb=0, name=\"o1\")\n\n# Add constraints\nmodel.addConstr((x1 / 4) + (x2 / 3) + o1 <= 90, name=\"AssemblyConstraint\")\nmodel.addConstr((x1 / 8) + (x2 / 3) <= 80, name=\"TestingConstraint\")\nmodel.addConstr(o1 <= 50, name=\"OvertimeConstraint\")\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*o1, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${}\".format(round(model.objval)))\n    print(\"Optimal production plan:\")\n    print(f\"Product 1 units: {x1.x}\")\n    print(f\"Product 2 units: {x2.x}\")\n    print(f\"Overtime assembly hours: {o1.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"CompanyProductionOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")\nx2 = model.addVar(lb=0, name=\"x2\")\no1 = model.addVar(lb=0, name=\"o1\")\n\n# Add constraints\nmodel.addConstr((x1 / 4) + (x2 / 3) + o1 <= 90, name=\"AssemblyConstraint\")\nmodel.addConstr((x1 / 8) + (x2 / 3) <= 80, name=\"TestingConstraint\")\nmodel.addConstr(o1 <= 50, name=\"OvertimeConstraint\")\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*o1, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${}\".format(round(model.objval)))\n    print(\"Optimal production plan:\")\n    print(f\"Product 1 units: {x1.x}\")\n    print(f\"Product 2 units: {x2.x}\")\n    print(f\"Overtime assembly hours: {o1.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 9b73de44\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 3 columns and 6 non-zero elements\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    5.1704556072e+03            2           0       0.00s\nDual             1    3.2400506719e+03            0           0       0.00s\nPostsolving\nDual             1    3.2400000000e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 3.2400000000e+03  Iterations: 1  Time: 0.00s\nMaximized daily profit: $3240\nOptimal production plan:\nProduct 1 units: 360.0\nProduct 2 units: 0.0\nOvertime assembly hours: 0.0",
        "pass": true
      }
    ],
    "answer": 1070.0,
    "cloze": "Zeta Bakery sells two types of cookies. They sell a strawberry cookie and a sugar cookie. Let's say they make x1 strawberry cookies, at a profit of $____ each, and x2 sugar cookies, at a profit of $____ each (x1 and x2 are unknowns both greater than or equal to ____). The daily demand for these cookies is ____ ____ strawberry cookies and ____ ____ sugar cookies. The bakery is short staffed and can make ____ ____ ____ cookies of either type per day. How much of each cookie should the bakery make in order to ____ profit?"
  },
  {
    "question": "A strata-management company is looking into purchasing two types of air conditioners, a low-power and a high-power model. A low-powered air conditioner can cool down 12 housing units and uses 150 units of electricity every day. A high-power model can cool down 17 housing units and uses 250 units of electricity every day. Since the low-powered model is not good for the aesthetics, the strata decided to limit the number of low-powered models to only 30% and at least 7 high-powered models must be used. If the apartment needs to condition at least 250 housing units and has 8000 units of electricity available, how many of each air conditioner should the strata company buy to minimize the total number of air conditioners?",
    "pass_count": 6,
    "pass_rate": 0.75,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_m\\): Number of mango bubble teas made.\n- \\(x_l\\): Number of lychee bubble teas made.\n\nObjective Function:\n- Minimize the total amount of tea needed: \\(Z = 8x_m + 6x_l\\).\n\nConstraints:\n1. Mango juice constraint: \\(4x_m \\leq 2000\\).\n2. Lychee juice constraint: \\(6x_l \\leq 3000\\).\n3. At least 40% of the bubble teas must be lychee flavored: \\(x_l \\geq 0.4(x_m + x_l)\\).\n4. Mango bubble tea must be made in larger quantity than lychee bubble tea: \\(x_m \\geq x_l + 1\\).\n5. Non-negativity and integer constraints: \\(x_m, x_l \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Define decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")  # Number of mango bubble teas made\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuiceConstraint\")  # Mango juice constraint\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuiceConstraint\")  # Lychee juice constraint\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"LycheePercentageConstraint\")  # At least 40% of the bubble teas must be lychee flavored\nmodel.addConstr(x_m >= x_l + 1, name=\"MangoMoreThanLycheeConstraint\")  # Mango bubble tea must be made in larger quantity than lychee bubble tea\n\n# Set the objective function\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total amount of tea needed: {model.objval}\")\n    print(f\"Number of mango bubble teas made: {x_m.x}\")\n    print(f\"Number of lychee bubble teas made: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Define decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")  # Number of mango bubble teas made\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuiceConstraint\")  # Mango juice constraint\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuiceConstraint\")  # Lychee juice constraint\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"LycheePercentageConstraint\")  # At least 40% of the bubble teas must be lychee flavored\nmodel.addConstr(x_m >= x_l + 1, name=\"MangoMoreThanLycheeConstraint\")  # Mango bubble tea must be made in larger quantity than lychee bubble tea\n\n# Set the objective function\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total amount of tea needed: {model.objval}\")\n    print(f\"Number of mango bubble teas made: {x_m.x}\")\n    print(f\"Number of lychee bubble teas made: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: afeef2b8\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 36.000000000\nBest bound      : 36.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :  2.22045e-16  2.22045e-16\n  integrality   :            0\nMinimum total amount of tea needed: 36.0\nNumber of mango bubble teas made: 3.0\nNumber of lychee bubble teas made: 2.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x_m: The number of mango bubble teas made.\n- x_l: The number of lychee bubble teas made.\n\nObjective Function:\nMinimize Z = 8*x_m + 6*x_l (total amount of tea needed)\n\nConstraints:\n1. Mango juice constraint: 4*x_m ≤ 2000\n2. Lychee juice constraint: 6*x_l ≤ 3000\n3. At least 40% of the bubble teas made must be lychee flavored: x_l ≥ 0.4*(x_m + x_l)\n4. Mango bubble tea sells better and thus the number of mango bubble teas made must be larger than the number of lychee bubble teas made: x_m ≥ x_l\n5. Non-negativity constraints: x_m ≥ 0, x_l ≥ 0\n6. Integer constraints: x_m and x_l are integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(4*x_m <= 2000, name=\"MangoJuiceConstraint\")\nmodel.addConstr(6*x_l <= 3000, name=\"LycheeJuiceConstraint\")\nmodel.addConstr(x_l >= 0.4*(x_m + x_l), name=\"LycheeFlavorConstraint\")\nmodel.addConstr(x_m >= x_l, name=\"MangoFlavorConstraint\")\n\n# Set the objective function\nmodel.setObjective(8*x_m + 6*x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total amount of tea needed: {model.objval}\")\n    print(f\"Number of mango bubble teas made: {x_m.x}\")\n    print(f\"Number of lychee bubble teas made: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(4*x_m <= 2000, name=\"MangoJuiceConstraint\")\nmodel.addConstr(6*x_l <= 3000, name=\"LycheeJuiceConstraint\")\nmodel.addConstr(x_l >= 0.4*(x_m + x_l), name=\"LycheeFlavorConstraint\")\nmodel.addConstr(x_m >= x_l, name=\"MangoFlavorConstraint\")\n\n# Set the objective function\nmodel.setObjective(8*x_m + 6*x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total amount of tea needed: {model.objval}\")\n    print(f\"Number of mango bubble teas made: {x_m.x}\")\n    print(f\"Number of lychee bubble teas made: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 14ac7f83\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 0.000000000\nBest bound      : 0.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total amount of tea needed: 0.0\nNumber of mango bubble teas made: 0.0\nNumber of lychee bubble teas made: 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_m\\): Number of mango bubble teas made.\n- \\(x_l\\): Number of lychee bubble teas made.\n\nObjective Function:\nMinimize the total amount of tea needed:\n\\[\nZ = 8x_m + 6x_l\n\\]\n\nConstraints:\n1. Mango juice availability:\n\\[\n4x_m \\leq 2000\n\\]\n2. Lychee juice availability:\n\\[\n6x_l \\leq 3000\n\\]\n3. At least 40% of the bubble teas made must be lychee flavored:\n\\[\nx_l \\geq 0.4(x_m + x_l)\n\\]\n4. Mango bubble tea must be more than the number of lychee bubble teas made:\n\\[\nx_m \\geq x_l\n\\]\n5. Non-negativity:\n\\[\nx_m \\geq 0, \\quad x_l \\geq 0\n\\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, name=\"x_m\")  # Number of mango bubble teas made\nx_l = model.addVar(lb=0, name=\"x_l\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4*x_m <= 2000, name=\"MangoJuiceConstraint\")\nmodel.addConstr(6*x_l <= 3000, name=\"LycheeJuiceConstraint\")\nmodel.addConstr(x_l >= 0.4*(x_m + x_l), name=\"LycheeFlavorConstraint\")\nmodel.addConstr(x_m >= x_l, name=\"MangoFlavorConstraint\")\n\n# Set the objective function\nmodel.setObjective(8*x_m + 6*x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {}\".format(x_m.x))\n    print(\"Number of lychee bubble teas made: {}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, name=\"x_m\")  # Number of mango bubble teas made\nx_l = model.addVar(lb=0, name=\"x_l\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4*x_m <= 2000, name=\"MangoJuiceConstraint\")\nmodel.addConstr(6*x_l <= 3000, name=\"LycheeJuiceConstraint\")\nmodel.addConstr(x_l >= 0.4*(x_m + x_l), name=\"LycheeFlavorConstraint\")\nmodel.addConstr(x_m >= x_l, name=\"MangoFlavorConstraint\")\n\n# Set the objective function\nmodel.setObjective(8*x_m + 6*x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {}\".format(x_m.x))\n    print(\"Number of lychee bubble teas made: {}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 4a627289\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\nThe presolved problem is empty\n\nPostsolving\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    0.0000000000e+00            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 0.0000000000e+00  Iterations: 0  Time: 0.00s\nMinimum total amount of tea needed: 0.00\nNumber of mango bubble teas made: 0.0\nNumber of lychee bubble teas made: 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_m\\): Number of mango bubble teas made.\n- \\(x_l\\): Number of lychee bubble teas made.\n\nObjective Function:\n- Minimize the total amount of tea needed: \\(Z = 8x_m + 6x_l\\)\n\nConstraints:\n1. Availability of mango juice: \\(4x_m \\leq 2000\\)\n2. Availability of lychee juice: \\(6x_l \\leq 3000\\)\n3. At least 40% of the bubble teas must be lychee flavored: \\(x_l \\geq 0.4(x_m + x_l)\\)\n4. Mango bubble tea must be more than the number of lychee bubble teas made: \\(x_m \\geq x_l + 1\\)\n5. Non-negativity: \\(x_m, x_l \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuiceAvailability\")\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuiceAvailability\")\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"LycheeFlavorRequirement\")\nmodel.addConstr(x_m >= x_l + 1, name=\"MangoBubbleTeaRequirement\")\n\n# Set the objective function\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {}\".format(x_m.x))\n    print(\"Number of lychee bubble teas made: {}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuiceAvailability\")\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuiceAvailability\")\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"LycheeFlavorRequirement\")\nmodel.addConstr(x_m >= x_l + 1, name=\"MangoBubbleTeaRequirement\")\n\n# Set the objective function\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {}\".format(x_m.x))\n    print(\"Number of lychee bubble teas made: {}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: afeef2b8\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 36.000000000\nBest bound      : 36.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :  2.22045e-16  2.22045e-16\n  integrality   :            0\nMinimum total amount of tea needed: 36.00\nNumber of mango bubble teas made: 3.0\nNumber of lychee bubble teas made: 2.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_m\\): The number of mango bubble teas made.\n- \\(x_l\\): The number of lychee bubble teas made.\n\nObjective Function:\n- Minimize the total amount of tea needed: \\(Z = 8x_m + 6x_l\\).\n\nConstraints:\n1. Availability of mango juice: \\(4x_m \\leq 2000\\).\n2. Availability of lychee juice: \\(6x_l \\leq 3000\\).\n3. At least 40% of the bubble teas made must be lychee flavored: \\(x_l \\geq 0.4(x_m + x_l)\\).\n4. Mango bubble tea sells better and thus the number of mango bubble teas made must be larger than the number of lychee bubble teas made: \\(x_m \\geq x_l + 1\\).\n5. Non-negativity and integer constraints: \\(x_m, x_l \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")  # Number of mango bubble teas made\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuice\")  # Availability of mango juice\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuice\")  # Availability of lychee juice\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"LycheeFlavor\")  # At least 40% of the bubble teas made must be lychee flavored\nmodel.addConstr(x_m >= x_l + 1, name=\"MangoSellBetter\")  # Mango bubble tea sells better and thus the number of mango bubble teas made must be larger than the number of lychee bubble teas made\n\n# Set the objective function\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {}\".format(x_m.x))\n    print(\"Number of lychee bubble teas made: {}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")  # Number of mango bubble teas made\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuice\")  # Availability of mango juice\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuice\")  # Availability of lychee juice\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"LycheeFlavor\")  # At least 40% of the bubble teas made must be lychee flavored\nmodel.addConstr(x_m >= x_l + 1, name=\"MangoSellBetter\")  # Mango bubble tea sells better and thus the number of mango bubble teas made must be larger than the number of lychee bubble teas made\n\n# Set the objective function\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {}\".format(x_m.x))\n    print(\"Number of lychee bubble teas made: {}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: afeef2b8\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 36.000000000\nBest bound      : 36.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :  2.22045e-16  2.22045e-16\n  integrality   :            0\nMinimum total amount of tea needed: 36.0\nNumber of mango bubble teas made: 3.0\nNumber of lychee bubble teas made: 2.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_m\\): The number of mango bubble teas produced.\n- \\(x_l\\): The number of lychee bubble teas produced.\n\nObjective Function:\n- Minimize total tea needed: \\(Z = 8x_m + 6x_l\\)\n\nConstraints:\n1. Mango juice requirement: \\(4x_m \\leq 2000\\)\n2. Lychee juice requirement: \\(6x_l \\leq 3000\\)\n3. At least 40% of bubble teas made must be lychee flavored: \\(x_l \\geq 0.4(x_m + x_l)\\)\n4. Mango bubble teas must be more than the number of lychee bubble teas made: \\(x_m > x_l\\)\n5. Non-negativity: \\(x_m, x_l \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, name=\"x_m\")  # Number of mango bubble teas made\nx_l = model.addVar(lb=0, name=\"x_l\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4*x_m <= 2000, name=\"MangoJuiceConstraint\")\nmodel.addConstr(6*x_l <= 3000, name=\"LycheeJuiceConstraint\")\nmodel.addConstr(x_l >= 0.4*(x_m + x_l), name=\"LycheePercentageConstraint\")\nmodel.addConstr(x_m > x_l, name=\"MangoMoreThanLycheeConstraint\")\n\n# Set the objective function\nmodel.setObjective(8*x_m + 6*x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total tea needed: {:.2f}\".format(model.objval))\n    print(\"Optimal solution:\")\n    print(\"Number of mango bubble teas made: {:.2f}\".format(x_m.x))\n    print(\"Number of lychee bubble teas made: {:.2f}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, name=\"x_m\")  # Number of mango bubble teas made\nx_l = model.addVar(lb=0, name=\"x_l\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4*x_m <= 2000, name=\"MangoJuiceConstraint\")\nmodel.addConstr(6*x_l <= 3000, name=\"LycheeJuiceConstraint\")\nmodel.addConstr(x_l >= 0.4*(x_m + x_l), name=\"LycheePercentageConstraint\")\nmodel.addConstr(x_m > x_l, name=\"MangoMoreThanLycheeConstraint\")\n\n# Set the objective function\nmodel.setObjective(8*x_m + 6*x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total tea needed: {:.2f}\".format(model.objval))\n    print(\"Optimal solution:\")\n    print(\"Number of mango bubble teas made: {:.2f}\".format(x_m.x))\n    print(\"Number of lychee bubble teas made: {:.2f}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "'>' not supported between instances of 'Var' and 'Var'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_m\\): The number of mango bubble teas made.\n- \\(x_l\\): The number of lychee bubble teas made.\n\nObjective Function:\n- Minimize total tea required: \\(Z = 8x_m + 6x_l\\)\n\nConstraints:\n1. Mango juice availability: \\(4x_m \\leq 2000\\)\n2. Lychee juice availability: \\(6x_l \\leq 3000\\)\n3. Minimum lychee flavor requirement: \\(x_l \\geq 0.4(x_m + x_l)\\)\n4. Mango bubble tea quantity requirement: \\(x_m \\geq x_l\\)\n5. Non-negativity: \\(x_m, x_l \\geq 0\\)\n6. Integer: \\(x_m, x_l\\) must be integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(4*x_m <= 2000, name=\"MangoJuiceAvailability\")\nmodel.addConstr(6*x_l <= 3000, name=\"LycheeJuiceAvailability\")\nmodel.addConstr(x_l >= 0.4*(x_m + x_l), name=\"MinimumLycheeFlavorRequirement\")\nmodel.addConstr(x_m >= x_l, name=\"MangoBubbleTeaQuantityRequirement\")\n\n# Set the objective function\nmodel.setObjective(8*x_m + 6*x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total tea required: {}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {}\".format(x_m.x))\n    print(\"Number of lychee bubble teas made: {}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(4*x_m <= 2000, name=\"MangoJuiceAvailability\")\nmodel.addConstr(6*x_l <= 3000, name=\"LycheeJuiceAvailability\")\nmodel.addConstr(x_l >= 0.4*(x_m + x_l), name=\"MinimumLycheeFlavorRequirement\")\nmodel.addConstr(x_m >= x_l, name=\"MangoBubbleTeaQuantityRequirement\")\n\n# Set the objective function\nmodel.setObjective(8*x_m + 6*x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total tea required: {}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {}\".format(x_m.x))\n    print(\"Number of lychee bubble teas made: {}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 14ac7f83\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 0.000000000\nBest bound      : 0.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total tea required: 0.0\nNumber of mango bubble teas made: 0.0\nNumber of lychee bubble teas made: 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): The number of mango bubble teas made.\n- \\(x_2\\): The number of lychee bubble teas made.\n\nObjective Function:\nMinimize the total amount of tea needed:\n\\[\nZ = 8x_1 + 6x_2\n\\]\n\nConstraints:\n1. Mango juice availability: \\(4x_1 \\leq 2000\\)\n2. Lychee juice availability: \\(6x_2 \\leq 3000\\)\n3. At least 40% of the bubble teas must be lychee flavored: \\(x_2 \\geq 0.4(x_1 + x_2)\\)\n4. Mango bubble teas must be more than lychee bubble teas: \\(x_1 > x_2\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShopOptimization\")\n\n# Define decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of mango bubble teas made\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4*x1 <= 2000, name=\"MangoJuiceAvailability\")\nmodel.addConstr(6*x2 <= 3000, name=\"LycheeJuiceAvailability\")\nmodel.addConstr(x2 >= 0.4*(x1 + x2), name=\"LycheeFlavorRequirement\")\nmodel.addConstr(x1 > x2, name=\"MangoFlavorPreference\")\n\n# Set the objective function\nmodel.setObjective(8*x1 + 6*x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {}\".format(x1.x))\n    print(\"Number of lychee bubble teas made: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShopOptimization\")\n\n# Define decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of mango bubble teas made\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4*x1 <= 2000, name=\"MangoJuiceAvailability\")\nmodel.addConstr(6*x2 <= 3000, name=\"LycheeJuiceAvailability\")\nmodel.addConstr(x2 >= 0.4*(x1 + x2), name=\"LycheeFlavorRequirement\")\nmodel.addConstr(x1 > x2, name=\"MangoFlavorPreference\")\n\n# Set the objective function\nmodel.setObjective(8*x1 + 6*x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {}\".format(x1.x))\n    print(\"Number of lychee bubble teas made: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "'>' not supported between instances of 'Var' and 'Var'",
        "pass": false
      }
    ],
    "answer": 15.0,
    "cloze": "A strata-management company is looking into purchasing two types of air conditioners, a low-power and a high-power model. A low-powered air conditioner can cool down ____ housing units and uses ____ units of electricity every day. A high-power model can cool down ____ housing units and uses ____ units of electricity every day. Since the low-powered model is not good for the aesthetics, the strata decided to limit the number of low-powered models to only ____ and ____ ____ high-powered models must be used. If the apartment needs to condition ____ ____ housing units and has ____ units of electricity available, how many of each air conditioner should the strata company buy to ____ the total number of air conditioners?"
  },
  {
    "question": "A company produces two kinds of products. A product of the first type requires 1/4 hours of assembly labor, 1/8 hours of testing, and $1.2 worth of raw materials. A product of the second type requires 1/3 hours of assembly, 1/3 hours of testing, and $0.9 worth of raw materials. Given the current personnel of the company, there can be at most 90 hours of assembly labor and 80 hours of testing each day. Suppose that up to 50 hours of overtime assembly labor can be scheduled, at a cost of $7 per hour. Products of the first and second type have a market value of $9 and $8 respectively. Try to maximize the daily profit of the company. Provide your answer rounded to the nearest dollar.",
    "pass_count": 5,
    "pass_rate": 0.625,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): The number of vehicles allocated to route \\(i\\), where \\(i \\in \\{X, Y, Z\\}\\). All \\(x_i\\) are non-negative integers.\n\nObjective Function:\n- Minimize total operating cost: \n  \\[\n  Z = 10x_X + 15x_Y + 20x_Z\n  \\]\n\nConstraints:\n1. Combined vehicle limit on routes X and Y: \n   \\[\n   x_X + x_Y \\leq 1000\n   \\]\n2. Combined vehicle limit on routes Y and Z: \n   \\[\n   x_Y + x_Z \\leq 800\n   \\]\n3. Minimum combined vehicle requirement on routes X and Z: \n   \\[\n   x_X + x_Z \\geq 500\n   \\]\n4. Individual route capacity limits:\n   - Route X: \n     \\[\n     x_X \\leq 700\n     \\]\n   - Route Y: \n     \\[\n     x_Y \\leq 600\n     \\]\n   - Route Z: \n     \\[\n     x_Z \\leq 400\n     \\]\n5. Non-negativity and integer: \n   \\[\n   x_i \\geq 0 \\text{ and integer for all } i \\in \\{X, Y, Z\\}\n   \\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Add decision variables\nx_X = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_X\")  # Number of vehicles allocated to route X\nx_Y = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_Y\")  # Number of vehicles allocated to route Y\nx_Z = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_Z\")  # Number of vehicles allocated to route Z\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"CombinedLimitXY\")  # Combined vehicle limit on routes X and Y\nmodel.addConstr(x_Y + x_Z <= 800, name=\"CombinedLimitYZ\")  # Combined vehicle limit on routes Y and Z\nmodel.addConstr(x_X + x_Z >= 500, name=\"MinimumRequirementXZ\")  # Minimum combined vehicle requirement on routes X and Z\nmodel.addConstr(x_X <= 700, name=\"CapacityLimitX\")  # Route X capacity limit\nmodel.addConstr(x_Y <= 600, name=\"CapacityLimitY\")  # Route Y capacity limit\nmodel.addConstr(x_Z <= 400, name=\"CapacityLimitZ\")  # Route Z capacity limit\n\n# Set the objective function\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total operating cost: {round(model.objval)}\")\n    print(f\"Optimal vehicle allocation: Route X = {x_X.x}, Route Y = {x_Y.x}, Route Z = {x_Z.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Add decision variables\nx_X = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_X\")  # Number of vehicles allocated to route X\nx_Y = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_Y\")  # Number of vehicles allocated to route Y\nx_Z = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_Z\")  # Number of vehicles allocated to route Z\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"CombinedLimitXY\")  # Combined vehicle limit on routes X and Y\nmodel.addConstr(x_Y + x_Z <= 800, name=\"CombinedLimitYZ\")  # Combined vehicle limit on routes Y and Z\nmodel.addConstr(x_X + x_Z >= 500, name=\"MinimumRequirementXZ\")  # Minimum combined vehicle requirement on routes X and Z\nmodel.addConstr(x_X <= 700, name=\"CapacityLimitX\")  # Route X capacity limit\nmodel.addConstr(x_Y <= 600, name=\"CapacityLimitY\")  # Route Y capacity limit\nmodel.addConstr(x_Z <= 400, name=\"CapacityLimitZ\")  # Route Z capacity limit\n\n# Set the objective function\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total operating cost: {round(model.objval)}\")\n    print(f\"Optimal vehicle allocation: Route X = {x_X.x}, Route Y = {x_Y.x}, Route Z = {x_Z.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 428d8c5a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    6 rows, 3 columns and 9 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 5000.000000000\nBest bound      : 5000.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total operating cost: 5000\nOptimal vehicle allocation: Route X = 500.0, Route Y = 0.0, Route Z = 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- $x_X\\): Number of vehicles allocated to route X.  \n- \\(x_Y\\): Number of vehicles allocated to route Y.  \n- \\(x_Z\\): Number of vehicles allocated to route Z.  \n\nObjective Function:  \nMinimize total operating cost:  \n\\[\nZ = 10x_X + 15x_Y + 20x_Z\n\\]\n\nConstraints:  \n1. Traffic restrictions:  \n   \\[\n   x_X + x_Y \\leq 1000\n   \\]  \n2. Road capacity:  \n   \\[\n   x_Y + x_Z \\leq 800\n   \\]  \n3. Service level requirement:  \n   \\[\n   x_X + x_Z \\geq 500\n   \\]  \n4. Individual route capacity limits:  \n   \\[\n   x_X \\leq 700\n   \\]  \n   \\[\n   x_Y \\leq 600\n   \\]  \n   \\[\n   x_Z \\leq 400\n   \\]  \n5. Non-negativity and integer:  \n   \\[\n   x_X, x_Y, x_Z \\geq 0 \\quad \\text{and integer}\n   \\]  \n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Decision Variables\nx_X = model.addVar(lb=0, ub=700, vtype=COPT.INTEGER, name=\"x_X\")\nx_Y = model.addVar(lb=0, ub=600, vtype=COPT.INTEGER, name=\"x_Y\")\nx_Z = model.addVar(lb=0, ub=400, vtype=COPT.INTEGER, name=\"x_Z\")\n\n# Constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestrictions\")\nmodel.addConstr(x_Y + x_Z <= 800, name=\"RoadCapacity\")\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevel\")\n\n# Objective Function\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(f\"Optimal allocation: Route X = {x_X.x}, Route Y = {x_Y.x}, Route Z = {x_Z.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Decision Variables\nx_X = model.addVar(lb=0, ub=700, vtype=COPT.INTEGER, name=\"x_X\")\nx_Y = model.addVar(lb=0, ub=600, vtype=COPT.INTEGER, name=\"x_Y\")\nx_Z = model.addVar(lb=0, ub=400, vtype=COPT.INTEGER, name=\"x_Z\")\n\n# Constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestrictions\")\nmodel.addConstr(x_Y + x_Z <= 800, name=\"RoadCapacity\")\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevel\")\n\n# Objective Function\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(f\"Optimal allocation: Route X = {x_X.x}, Route Y = {x_Y.x}, Route Z = {x_Z.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: e507b3d2\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    3 rows, 3 columns and 6 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 5000.000000000\nBest bound      : 5000.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total operating cost: 5000\nOptimal allocation: Route X = 500.0, Route Y = 0.0, Route Z = 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_X\\): Number of vehicles allocated to route X.  \n- \\(x_Y\\): Number of vehicles allocated to route Y.  \n- \\(x_Z\\): Number of vehicles allocated to route Z.  \n\nObjective Function:  \nMinimize the total operating cost:  \n\\[\nZ = 10x_X + 15x_Y + 20x_Z\n\\]\n\nConstraints:  \n1. Traffic restrictions:  \n   \\[\n   x_X + x_Y \\leq 1000\n   \\]  \n2. Road capacity:  \n   \\[\n   x_Y + x_Z \\leq 800\n   \\]  \n3. Service level maintenance:  \n   \\[\n   x_X + x_Z \\geq 500\n   \\]  \n4. Route capacity limits:  \n   \\[\n   x_X \\leq 700\n   \\]  \n   \\[\n   x_Y \\leq 600\n   \\]  \n   \\[\n   x_Z \\leq 400\n   \\]  \n5. Non-negativity and integer constraints:  \n   \\[\n   x_X, x_Y, x_Z \\geq 0 \\text{ and integer}\n   \\]  \n</model>  \n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Add decision variables\nx_X = model.addVar(lb=0, ub=700, vtype=COPT.INTEGER, name=\"x_X\")\nx_Y = model.addVar(lb=0, ub=600, vtype=COPT.INTEGER, name=\"x_Y\")\nx_Z = model.addVar(lb=0, ub=400, vtype=COPT.INTEGER, name=\"x_Z\")\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestriction\")\nmodel.addConstr(x_Y + x_Z <= 800, name=\"RoadCapacity\")\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevelMaintenance\")\n\n# Set the objective function\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total operating cost: {round(model.objval)}\")\n    print(f\"Optimal allocations: route X = {x_X.x}, route Y = {x_Y.x}, route Z = {x_Z.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Add decision variables\nx_X = model.addVar(lb=0, ub=700, vtype=COPT.INTEGER, name=\"x_X\")\nx_Y = model.addVar(lb=0, ub=600, vtype=COPT.INTEGER, name=\"x_Y\")\nx_Z = model.addVar(lb=0, ub=400, vtype=COPT.INTEGER, name=\"x_Z\")\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestriction\")\nmodel.addConstr(x_Y + x_Z <= 800, name=\"RoadCapacity\")\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevelMaintenance\")\n\n# Set the objective function\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total operating cost: {round(model.objval)}\")\n    print(f\"Optimal allocations: route X = {x_X.x}, route Y = {x_Y.x}, route Z = {x_Z.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: e507b3d2\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    3 rows, 3 columns and 6 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 5000.000000000\nBest bound      : 5000.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total operating cost: 5000\nOptimal allocations: route X = 500.0, route Y = 0.0, route Z = 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): Integer number of vehicles allocated to route \\(i\\), for \\(i \\in \\{X, Y, Z\\}\\).\n\nObjective Function:\n- Minimize total operating cost:  \n  \\[Z = 10x_X + 15x_Y + 20x_Z\\]\n\nConstraints:\n1. Combined number of vehicles on routes X and Y:  \n   \\[x_X + x_Y \\leq 1000\\]\n2. Combined number of vehicles on routes Y and Z:  \n   \\[x_Y + x_Z \\leq 800\\]\n3. Sum of vehicles on routes X and Z:  \n   \\[x_X + x_Z \\geq 500\\]\n4. Individual route capacity limits:  \n   \\[x_X \\leq 700\\]  \n   \\[x_Y \\leq 600\\]  \n   \\[x_Z \\leq 400\\]\n5. Non-negativity and integer:  \n   \\[x_X, x_Y, x_Z \\geq 0 \\text{ and integers}\\]\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x\\): Number of vehicles allocated to route \\(X\\).  \n- \\(y\\): Number of vehicles allocated to route \\(Y\\).  \n- \\(z\\): Number of vehicles allocated to route \\(Z\\).  \n\nObjective Function:  \n- Minimize the total operating cost:  \n  \\[\n  Z = 10x + 15y + 20z\n  \\]  \n\nConstraints:  \n1. Traffic restrictions and road capacity:  \n   \\[\n   x + y \\leq 1000\n   \\]  \n2. Combined vehicle limit on routes Y and Z:  \n   \\[\n   y + z \\leq 800\n   \\]  \n3. Service level requirement:  \n   \\[\n   x + z \\geq 500\n   \\]  \n4. Route capacity limits:  \n   \\[\n   x \\leq 700\n   \\]  \n   \\[\n   y \\leq 600\n   \\]  \n   \\[\n   z \\leq 400\n   \\]  \n\nNon-negativity and integer constraints:  \n- \\(x, y, z \\geq 0\\) and integer.\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): The number of vehicles allocated to route \\(i\\), where \\(i = X, Y, Z\\). These are non-negative integers.\n\nObjective Function:\n- Minimize the total operating cost:  \n  \\[\n  Z = 10x_X + 15x_Y + 20x_Z\n  \\]\n\nConstraints:\n1. Traffic restriction on routes X and Y:  \n   \\[\n   x_X + x_Y \\leq 1000\n   \\]\n2. Traffic restriction on routes Y and Z:  \n   \\[\n   x_Y + x_Z \\leq 800\n   \\]\n3. Service level requirement on routes X and Z:  \n   \\[\n   x_X + x_Z \\geq 500\n   \\]\n4. Route capacity limits:  \n   \\[\n   x_X \\leq 700\n   \\]\n   \\[\n   x_Y \\leq 600\n   \\]\n   \\[\n   x_Z \\leq 400\n   \\]\n\nNon-negativity and Integer Constraints:  \n\\[\nx_X, x_Y, x_Z \\geq 0 \\text{ and are integers}\n\\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Add decision variables\nx_X = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_X\")\nx_Y = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_Y\")\nx_Z = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_Z\")\n\n# Set the objective function: minimize total operating cost\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestriction_XY\")\nmodel.addConstr(x_Y + x_Z <= 800, name=\"TrafficRestriction_YZ\")\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevelRequirement_XZ\")\nmodel.addConstr(x_X <= 700, name=\"CapacityLimit_X\")\nmodel.addConstr(x_Y <= 600, name=\"CapacityLimit_Y\")\nmodel.addConstr(x_Z <= 400, name=\"CapacityLimit_Z\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(\"Optimal allocation:\")\n    print(f\"Route X: {x_X.x}\")\n    print(f\"Route Y: {x_Y.x}\")\n    print(f\"Route Z: {x_Z.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Add decision variables\nx_X = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_X\")\nx_Y = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_Y\")\nx_Z = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_Z\")\n\n# Set the objective function: minimize total operating cost\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestriction_XY\")\nmodel.addConstr(x_Y + x_Z <= 800, name=\"TrafficRestriction_YZ\")\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevelRequirement_XZ\")\nmodel.addConstr(x_X <= 700, name=\"CapacityLimit_X\")\nmodel.addConstr(x_Y <= 600, name=\"CapacityLimit_Y\")\nmodel.addConstr(x_Z <= 400, name=\"CapacityLimit_Z\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(\"Optimal allocation:\")\n    print(f\"Route X: {x_X.x}\")\n    print(f\"Route Y: {x_Y.x}\")\n    print(f\"Route Z: {x_Z.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 428d8c5a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    6 rows, 3 columns and 9 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 5000.000000000\nBest bound      : 5000.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total operating cost: 5000\nOptimal allocation:\nRoute X: 500.0\nRoute Y: 0.0\nRoute Z: 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_X\\): The number of vehicles allocated to route X.\n- \\(x_Y\\): The number of vehicles allocated to route Y.\n- \\(x_Z\\): The number of vehicles allocated to route Z.\n\nObjective Function:\n- Minimize total operating cost: \\(Z = 10x_X + 15x_Y + 20x_Z\\).\n\nConstraints:\n1. Traffic restriction on routes X and Y: \\(x_X + x_Y \\leq 1000\\).\n2. Traffic restriction on routes Y and Z: \\(x_Y + x_Z \\leq 800\\).\n3. Service level requirement on routes X and Z: \\(x_X + x_Z \\geq 500\\).\n4. Route capacity limit for route X: \\(x_X \\leq 700\\).\n5. Route capacity limit for route Y: \\(x_Y \\leq 600\\).\n6. Route capacity limit for route Z: \\(x_Z \\leq 400\\).\n7. Non-negativity and integer: \\(x_X, x_Y, x_Z \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"VehicleAllocation\")\n\n# Add decision variables\nx_X = model.addVar(lb=0, ub=700, vtype=COPT.INTEGER, name=\"x_X\")\nx_Y = model.addVar(lb=0, ub=600, vtype=COPT.INTEGER, name=\"x_Y\")\nx_Z = model.addVar(lb=0, ub=400, vtype=COPT.INTEGER, name=\"x_Z\")\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestrictionXandY\")\nmodel.addConstr(x_Y + x_Z <= 800, name=\"TrafficRestrictionYandZ\")\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevelRequirement\")\n\n# Set the objective function\nmodel.setObjective(10 * x_X + 15 * x_Y + 20 * x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(\"Optimal vehicle allocations:\")\n    print(\"Route X: {} vehicles\".format(x_X.x))\n    print(\"Route Y: {} vehicles\".format(x_Y.x))\n    print(\"Route Z: {} vehicles\".format(x_Z.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"VehicleAllocation\")\n\n# Add decision variables\nx_X = model.addVar(lb=0, ub=700, vtype=COPT.INTEGER, name=\"x_X\")\nx_Y = model.addVar(lb=0, ub=600, vtype=COPT.INTEGER, name=\"x_Y\")\nx_Z = model.addVar(lb=0, ub=400, vtype=COPT.INTEGER, name=\"x_Z\")\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestrictionXandY\")\nmodel.addConstr(x_Y + x_Z <= 800, name=\"TrafficRestrictionYandZ\")\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevelRequirement\")\n\n# Set the objective function\nmodel.setObjective(10 * x_X + 15 * x_Y + 20 * x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(\"Optimal vehicle allocations:\")\n    print(\"Route X: {} vehicles\".format(x_X.x))\n    print(\"Route Y: {} vehicles\".format(x_Y.x))\n    print(\"Route Z: {} vehicles\".format(x_Z.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: e507b3d2\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    3 rows, 3 columns and 6 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 5000.000000000\nBest bound      : 5000.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total operating cost: 5000\nOptimal vehicle allocations:\nRoute X: 500.0 vehicles\nRoute Y: 0.0 vehicles\nRoute Z: 0.0 vehicles",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x\\): Number of vehicles allocated to route X.  \n- \\(y\\): Number of vehicles allocated to route Y.  \n- \\(z\\): Number of vehicles allocated to route Z.  \n\nObjective Function:  \nMinimize total operating cost:  \n\\[\n\\text{Minimize } Z = 10x + 15y + 20z\n\\]  \n\nConstraints:  \n1. Combined number of vehicles on routes X and Y cannot exceed 1000:  \n   \\[\n   x + y \\leq 1000\n   \\]  \n2. Combined number of vehicles on routes Y and Z cannot exceed 800:  \n   \\[\n   y + z \\leq 800\n   \\]  \n3. Sum of vehicles on routes X and Z must be at least 500:  \n   \\[\n   x + z \\geq 500\n   \\]  \n4. Individual route capacity limits:  \n   \\[\n   x \\leq 700, \\quad y \\leq 600, \\quad z \\leq 400\n   \\]  \n5. Non-negativity and integer:  \n   \\[\n   x, y, z \\geq 0 \\text{ and integer}\n   \\]  \n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      }
    ],
    "answer": 4018.0,
    "cloze": "A company produces two kinds of products. A product of the first type requires ____ hours of assembly labor, ____ hours of testing, and $____ worth of raw materials. A product of the second type requires ____ hours of assembly, ____ hours of testing, and $____ worth of raw materials. Given the current personnel of the company, there can be ____ ____ hours of assembly labor and ____ hours of testing each day. Suppose that ____ ____ hours of overtime assembly labor can be scheduled, at a cost of $____ per hour. Products of the first and second type have a market value of $____ and $____ respectively. Try to ____ the daily profit of the company. Provide your answer rounded to the nearest dollar."
  },
  {
    "question": "A manufacturing company produces three types of electronic components: A, B, and C. The company has four different production lines, each capable of producing these components with varying efficiencies. The company needs to produce at least 1000 units of component A, 800 units of component B, and 1200 units of component C daily. The production lines can only be operated if at least 5 workers are assigned. Please determine the minimum production time to meet the daily demand. The production rates for each component by each worker on different lines are given in the following Table.\n\n| Line | Component A | Component B | Component C |\n|------|-------------|-------------|-------------|\n| 1    | 10 units/hr | 5 units/hr  | 15 units/hr |\n| 2    | 8 units/hr  | 10 units/hr | 12 units/hr |\n| 3    | 12 units/hr | 6 units/hr  | 10 units/hr |\n| 4    | 15 units/hr | 8 units/hr  | 5 units/hr  |\n\nThere are total 50 workers available. Each production line can be utilized by up to 15 workers at a time. Each production line must have at least 5 workers to operate. The objective function is to minimize the maximum production time for components A, B, and C, which is defined as:\n- The production time for component A: T_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n- The production time for component B: T_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n- The production time for component C: T_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n- The objective is to minimize max(T_A, T_B, T_C).\n",
    "pass_count": 3,
    "pass_rate": 0.375,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): The fraction of investment \\(i\\) that Star Oil Company invests in, for \\(i = 1, 2, 3, 4, 5\\). These variables are non-negative real numbers.\n\nObjective Function:\nMaximize the total NPV:  \n\\[\nZ = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\n\\]\n\nConstraints:\n1. Time 0 cash outflow constraint:  \n\\[\n11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\n\\]\n2. Time 1 cash outflow constraint:  \n\\[\n3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\n\\]\n3. Non-negativity constraints:  \n\\[\nx_i \\geq 0 \\quad \\text{for all } i\n\\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"StarOilInvestment\")\n\n# Define the investment opportunities\ninvestments = [1, 2, 3, 4, 5]\ntime0_outflows = [11, 53, 5, 5, 29]\ntime1_outflows = [3, 6, 5, 1, 34]\nnpvs = [13, 16, 16, 14, 39]\n\n# Add decision variables\nx = {i: model.addVar(lb=0, name=f\"x_{i}\") for i in investments}\n\n# Add constraints\nmodel.addConstr(cp.quicksum(time0_outflows[i-1] * x[i] for i in investments) <= 40, name=\"Time0Constraint\")\nmodel.addConstr(cp.quicksum(time1_outflows[i-1] * x[i] for i in investments) <= 20, name=\"Time1Constraint\")\n\n# Set the objective function\nmodel.setObjective(cp.quicksum(npvs[i-1] * x[i] for i in investments), sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized NPV: {:.2f}\".format(model.objval))\n    print(\"Investment allocations:\")\n    for i in investments:\n        print(f\"Investment {i}: {x[i].x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"StarOilInvestment\")\n\n# Define the investment opportunities\ninvestments = [1, 2, 3, 4, 5]\ntime0_outflows = [11, 53, 5, 5, 29]\ntime1_outflows = [3, 6, 5, 1, 34]\nnpvs = [13, 16, 16, 14, 39]\n\n# Add decision variables\nx = {i: model.addVar(lb=0, name=f\"x_{i}\") for i in investments}\n\n# Add constraints\nmodel.addConstr(cp.quicksum(time0_outflows[i-1] * x[i] for i in investments) <= 40, name=\"Time0Constraint\")\nmodel.addConstr(cp.quicksum(time1_outflows[i-1] * x[i] for i in investments) <= 20, name=\"Time1Constraint\")\n\n# Set the objective function\nmodel.setObjective(cp.quicksum(npvs[i-1] * x[i] for i in investments), sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized NPV: {:.2f}\".format(model.objval))\n    print(\"Investment allocations:\")\n    for i in investments:\n        print(f\"Investment {i}: {x[i].x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "name 'model' is not defined",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): Fractional amount of investment \\(i\\) purchased by Star Oil, where \\(i = 1, 2, 3, 4, 5\\).\n\nObjective Function:\n- Maximize the total NPV:  \n  \\[\n  Z = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\n  \\]\n\nConstraints:\n1. Time 0 investment budget:  \n   \\[\n   11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\n   \\]\n2. Time 1 investment budget:  \n   \\[\n   3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\n   \\]\n3. Non-negativity:  \n   \\[\n   x_i \\geq 0 \\quad \\forall i\n   \\]\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): The fraction of investment \\(i\\) that Star Oil should purchase, for \\(i = 1, 2, 3, 4, 5\\). These variables represent the proportion of each investment that Star Oil decides to invest in, where \\(0 \\leq x_i \\leq 1\\).\n\nObjective Function:\n- Maximize the total net present value (NPV) of the investments:\n  \\[\n  Z = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\n  \\]\n\nConstraints:\n1. Time 0 budget constraint: The total cash outflows at time 0 cannot exceed the available budget of $40 million:\n   \\[\n   11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\n   \\]\n2. Time 1 budget constraint: The total cash outflows at time 1 cannot exceed the available budget of $20 million:\n   \\[\n   3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\n   \\]\n3. Non-negativity and fraction constraints: Each investment fraction must be between 0 and 1:\n   \\[\n   0 \\leq x_i \\leq 1 \\quad \\forall i \\in \\{1, 2, 3, 4, 5\\}\n   \\]\n4. Integer constraint: The decision variables must be integer values (since Star Oil can only invest in whole fractions of the investments).\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"StarOilInvestmentOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, ub=1, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, ub=1, vtype=COPT.INTEGER, name=\"x2\")\nx3 = model.addVar(lb=0, ub=1, vtype=COPT.INTEGER, name=\"x3\")\nx4 = model.addVar(lb=0, ub=1, vtype=COPT.INTEGER, name=\"x4\")\nx5 = model.addVar(lb=0, ub=1, vtype=COPT.INTEGER, name=\"x5\")\n\n# Set the objective function\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0BudgetConstraint\")\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1BudgetConstraint\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum NPV: {:.2f} million dollars\".format(model.objval))\n    print(\"Investment decisions:\")\n    print(\"Investment 1: {}\".format(x1.x))\n    print(\"Investment 2: {}\".format(x2.x))\n    print(\"Investment 3: {}\".format(x3.x))\n    print(\"Investment 4: {}\".format(x4.x))\n    print(\"Investment 5: {}\".format(x5.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"StarOilInvestmentOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, ub=1, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, ub=1, vtype=COPT.INTEGER, name=\"x2\")\nx3 = model.addVar(lb=0, ub=1, vtype=COPT.INTEGER, name=\"x3\")\nx4 = model.addVar(lb=0, ub=1, vtype=COPT.INTEGER, name=\"x4\")\nx5 = model.addVar(lb=0, ub=1, vtype=COPT.INTEGER, name=\"x5\")\n\n# Set the objective function\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0BudgetConstraint\")\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1BudgetConstraint\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum NPV: {:.2f} million dollars\".format(model.objval))\n    print(\"Investment decisions:\")\n    print(\"Investment 1: {}\".format(x1.x))\n    print(\"Investment 2: {}\".format(x2.x))\n    print(\"Investment 3: {}\".format(x3.x))\n    print(\"Investment 4: {}\".format(x4.x))\n    print(\"Investment 5: {}\".format(x5.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 2f04b1bb\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    2 rows, 5 columns and 10 non-zero elements\n    5 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 43.000000000\nBest bound      : 43.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximum NPV: 43.00 million dollars\nInvestment decisions:\nInvestment 1: 1.0\nInvestment 2: 0.0\nInvestment 3: 1.0\nInvestment 4: 1.0\nInvestment 5: 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): Fraction of investment \\(i\\) purchased, where \\(i = 1, 2, 3, 4, 5\\).\n\nObjective Function:\n- Maximize total NPV: \\(Z = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\\)\n\nConstraints:\n1. Time 0 cash outflow constraint: \\(11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\\)\n2. Time 1 cash outflow constraint: \\(3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\\)\n3. Non-negativity: \\(x_i \\geq 0\\) for all \\(i\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"StarOilInvestmentOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")\nx2 = model.addVar(lb=0, name=\"x2\")\nx3 = model.addVar(lb=0, name=\"x3\")\nx4 = model.addVar(lb=0, name=\"x4\")\nx5 = model.addVar(lb=0, name=\"x5\")\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0Constraint\")\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1Constraint\")\n\n# Set the objective function to maximize total NPV\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum NPV: {:.2f}\".format(model.objval))\n    print(\"Investment 1: {:.2f}\".format(x1.x))\n    print(\"Investment 2: {:.2f}\".format(x2.x))\n    print(\"Investment 3: {:.2f}\".format(x3.x))\n    print(\"Investment 4: {:.2f}\".format(x4.x))\n    print(\"Investment 5: {:.2f}\".format(x5.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"StarOilInvestmentOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")\nx2 = model.addVar(lb=0, name=\"x2\")\nx3 = model.addVar(lb=0, name=\"x3\")\nx4 = model.addVar(lb=0, name=\"x4\")\nx5 = model.addVar(lb=0, name=\"x5\")\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0Constraint\")\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1Constraint\")\n\n# Set the objective function to maximize total NPV\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum NPV: {:.2f}\".format(model.objval))\n    print(\"Investment 1: {:.2f}\".format(x1.x))\n    print(\"Investment 2: {:.2f}\".format(x2.x))\n    print(\"Investment 3: {:.2f}\".format(x3.x))\n    print(\"Investment 4: {:.2f}\".format(x4.x))\n    print(\"Investment 5: {:.2f}\".format(x5.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: bf03dec4\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    2 rows, 5 columns and 10 non-zero elements\nThe presolved problem has:\n    2 rows, 5 columns and 10 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    2.5977644480e+02            2           0       0.00s\nDual             2    1.1800074236e+02            0           0       0.00s\nPostsolving\nDual             2    1.1800000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.1800000000e+02  Iterations: 2  Time: 0.00s\nMaximum NPV: 118.00\nInvestment 1: 0.00\nInvestment 2: 0.00\nInvestment 3: 3.00\nInvestment 4: 5.00\nInvestment 5: 0.00",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x₁: Fraction of investment 1 purchased.\n- x₂: Fraction of investment 2 purchased.\n- x₃: Fraction of investment 3 purchased.\n- x₄: Fraction of investment 4 purchased.\n- x₅: Fraction of investment 5 purchased.\n\nObjective Function:\nMaximize Z = 13x₁ + 16x₂ + 16x₃ + 14x₄ + 39x₅\n\nConstraints:\n1. Time 0 cash outflow: 11x₁ + 53x₂ + 5x₃ + 5x₄ + 29x₅ ≤ 40\n2. Time 1 cash outflow: 3x₁ + 6x₂ + 5x₃ + 1x₄ + 34x₅ ≤ 20\n3. Non-negativity: x₁, x₂, x₃, x₄, x₅ ≥ 0\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"StarOilInvestmentOptimization\")\n\n# Define the investment data\ninvestment_data = [\n    {\"name\": \"Investment 1\", \"time0_outflow\": 11, \"time1_outflow\": 3, \"npv\": 13},\n    {\"name\": \"Investment 2\", \"time0_outflow\": 53, \"time1_outflow\": 6, \"npv\": 16},\n    {\"name\": \"Investment 3\", \"time0_outflow\": 5, \"time1_outflow\": 5, \"npv\": 16},\n    {\"name\": \"Investment 4\", \"time0_outflow\": 5, \"time1_outflow\": 1, \"npv\": 14},\n    {\"name\": \"Investment 5\", \"time0_outflow\": 29, \"time1_outflow\": 34, \"npv\": 39}\n]\n\n# Add decision variables\nx = {i: model.addVar(lb=0, name=f\"x_{i['name']}\") for i in investment_data}\n\n# Add constraints\nmodel.addConstr(cp.quicksum(i[\"time0_outflow\"] * x[i] for i in investment_data) <= 40, name=\"Time0OutflowConstraint\")\nmodel.addConstr(cp.quicksum(i[\"time1_outflow\"] * x[i] for i in investment_data) <= 20, name=\"Time1OutflowConstraint\")\n\n# Set the objective function\nmodel.setObjective(cp.quicksum(i[\"npv\"] * x[i] for i in investment_data), sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum NPV: {:.2f} million dollars\".format(model.objval))\n    for i in investment_data:\n        print(f\"Fraction of investment {i['name']} purchased: {x[i].x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"StarOilInvestmentOptimization\")\n\n# Define the investment data\ninvestment_data = [\n    {\"name\": \"Investment 1\", \"time0_outflow\": 11, \"time1_outflow\": 3, \"npv\": 13},\n    {\"name\": \"Investment 2\", \"time0_outflow\": 53, \"time1_outflow\": 6, \"npv\": 16},\n    {\"name\": \"Investment 3\", \"time0_outflow\": 5, \"time1_outflow\": 5, \"npv\": 16},\n    {\"name\": \"Investment 4\", \"time0_outflow\": 5, \"time1_outflow\": 1, \"npv\": 14},\n    {\"name\": \"Investment 5\", \"time0_outflow\": 29, \"time1_outflow\": 34, \"npv\": 39}\n]\n\n# Add decision variables\nx = {i: model.addVar(lb=0, name=f\"x_{i['name']}\") for i in investment_data}\n\n# Add constraints\nmodel.addConstr(cp.quicksum(i[\"time0_outflow\"] * x[i] for i in investment_data) <= 40, name=\"Time0OutflowConstraint\")\nmodel.addConstr(cp.quicksum(i[\"time1_outflow\"] * x[i] for i in investment_data) <= 20, name=\"Time1OutflowConstraint\")\n\n# Set the objective function\nmodel.setObjective(cp.quicksum(i[\"npv\"] * x[i] for i in investment_data), sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum NPV: {:.2f} million dollars\".format(model.objval))\n    for i in investment_data:\n        print(f\"Fraction of investment {i['name']} purchased: {x[i].x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "name 'model' is not defined",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): Fractional amount invested in investment \\(i\\), for \\(i = 1, 2, 3, 4, 5\\). These are continuous decision variables.\n\nObjective Function:\nMaximize total net present value (NPV):\n\\[\nZ = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\n\\]\n\nConstraints:\n1. Time 0 cash outflow budget:\n\\[\n11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\n\\]\n2. Time 1 cash outflow budget:\n\\[\n3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\n\\]\n3. Non-negativity:\n\\[\nx_i \\geq 0 \\quad \\text{for all } i\n\\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"StarOilInvestment\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Investment 1\nx2 = model.addVar(lb=0, name=\"x2\")  # Investment 2\nx3 = model.addVar(lb=0, name=\"x3\")  # Investment 3\nx4 = model.addVar(lb=0, name=\"x4\")  # Investment 4\nx5 = model.addVar(lb=0, name=\"x5\")  # Investment 5\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0Constraint\")  # Time 0 cash outflow budget\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1Constraint\")  # Time 1 cash outflow budget\n\n# Set the objective function\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximum NPV: {model.objval:.2f} million dollars\")\n    print(f\"Optimal investment allocation:\")\n    print(f\"Investment 1: {x1.x:.2f}\")\n    print(f\"Investment 2: {x2.x:.2f}\")\n    print(f\"Investment 3: {x3.x:.2f}\")\n    print(f\"Investment 4: {x4.x:.2f}\")\n    print(f\"Investment 5: {x5.x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"StarOilInvestment\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Investment 1\nx2 = model.addVar(lb=0, name=\"x2\")  # Investment 2\nx3 = model.addVar(lb=0, name=\"x3\")  # Investment 3\nx4 = model.addVar(lb=0, name=\"x4\")  # Investment 4\nx5 = model.addVar(lb=0, name=\"x5\")  # Investment 5\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0Constraint\")  # Time 0 cash outflow budget\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1Constraint\")  # Time 1 cash outflow budget\n\n# Set the objective function\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximum NPV: {model.objval:.2f} million dollars\")\n    print(f\"Optimal investment allocation:\")\n    print(f\"Investment 1: {x1.x:.2f}\")\n    print(f\"Investment 2: {x2.x:.2f}\")\n    print(f\"Investment 3: {x3.x:.2f}\")\n    print(f\"Investment 4: {x4.x:.2f}\")\n    print(f\"Investment 5: {x5.x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: bf03dec4\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    2 rows, 5 columns and 10 non-zero elements\nThe presolved problem has:\n    2 rows, 5 columns and 10 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    2.5977644480e+02            2           0       0.00s\nDual             2    1.1800074236e+02            0           0       0.00s\nPostsolving\nDual             2    1.1800000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.1800000000e+02  Iterations: 2  Time: 0.00s\nMaximum NPV: 118.00 million dollars\nOptimal investment allocation:\nInvestment 1: 0.00\nInvestment 2: 0.00\nInvestment 3: 3.00\nInvestment 4: 5.00\nInvestment 5: 0.00",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_i\\): Fraction of investment opportunity \\(i\\) (for \\(i = 1, 2, 3, 4, 5\\)) that Star Oil purchases.  \n\nObjective Function:  \nMaximize the total net present value (NPV):  \n\\[\nZ = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\n\\]  \n\nConstraints:  \n1. Cash outflow at time 0:  \n\\[\n11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\n\\]  \n2. Cash outflow at time 1:  \n\\[\n3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\n\\]  \n3. Non-negativity:  \n\\[\nx_i \\geq 0 \\quad \\text{for all } i\n\\]\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): Fraction of investment \\(i\\) to be purchased, for \\(i = 1, 2, 3, 4, 5\\), where \\(x_i \\geq 0\\).\n\nObjective Function:\n- Maximize the total NPV: \\(Z = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\\).\n\nConstraints:\n1. Time 0 investment budget: \\(11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\\).\n2. Time 1 investment budget: \\(3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\\).\n\nNon-negativity: \\(x_i \\geq 0\\) for all \\(i\\).\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      }
    ],
    "answer": 2.18,
    "cloze": "A manufacturing company produces three types of electronic components: A, B, and C. The company has four different production lines, each capable of producing these components with varying efficiencies. The company needs to produce ____ ____ units of component A, ____ units of component B, and ____ units of component C daily. The production lines can only be operated if at least ____ workers are assigned. Please determine the ____ production time to meet the daily demand. The production rates for each component by each worker on different lines are given in the following Table.\n\n| Line | Component A | Component B | Component C |\n|------|-------------|-------------|-------------|\n| 1    | ____ units/hr | ____ units/hr  | ____ units/hr |\n| 2    | ____ units/hr  | ____ units/hr | ____ units/hr |\n| 3    | ____ units/hr | ____ units/hr  | ____ units/hr |\n| 4    | ____ units/hr | ____ units/hr  | ____ units/hr |\n\nThere are total ____ workers available. Each production line can be utilized by ____ ____ workers at a time. Each production line must have ____ ____ workers to operate. The objective function is to ____ the maximum production time for components A, B, and C, which is defined as:\n- The production time for component A: T_A = ____ / (____ * W1 + ____ * W2 + ____ * W3 + ____ * W4)\n- The production time for component B: T_B = ____ / (____ * W1 + ____ * W2 + ____ * W3 + ____ * W4)\n- The production time for component C: T_C = ____ / (____ * W1 + ____ * W2 + ____ * W3 + ____ * W4)\n- The objective is to ____ max(T_A, T_B, T_C)."
  },
  {
    "question": "A bubble tea shop sells mango and lychee bubble tea. Each mango bubble tea requires 4 units of mango juice and 8 units of tea. Each lychee bubble tea requires 6 units of lychee juice and 6 units of tea. The shop has available 2000 units of mango juice and 3000 units of lychee juice. At least 40% of the bubble teas made must be lychee flavored. However, mango bubble tea sells better and thus the number of mango bubble teas made must be large than the number of lychee bubble teas made. How many of each bubble tea flavor should be made to minimize the total amount of tea needed?",
    "pass_count": 0,
    "pass_rate": 0.0,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- W1: Number of workers assigned to production line 1.\n- W2: Number of workers assigned to production line 2.\n- W3: Number of workers assigned to production line 3.\n- W4: Number of workers assigned to production line 4.\n\nObjective Function:\n- Minimize the maximum production time for components A, B, and C: Z = max(T_A, T_B, T_C)\n  - T_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n  - T_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n  - T_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\nConstraints:\n1. Demand satisfaction for component A: 10 * W1 + 8 * W2 + 12 * W3 + 15 * W4 >= 1000\n2. Demand satisfaction for component B: 5 * W1 + 10 * W2 + 6 * W3 + 8 * W4 >= 800\n3. Demand satisfaction for component C: 15 * W1 + 12 * W2 + 10 * W3 + 5 * W4 >= 1200\n4. Worker availability: W1 + W2 + W3 + W4 <= 50\n5. Production line utilization limits: W1 <= 15, W2 <= 15, W3 <= 15, W4 <= 15\n6. Production line minimum workers: W1 >= 5, W2 >= 5, W3 >= 5, W4 >= 5\n7. Non-negativity: W1, W2, W3, W4 >= 0 and integer.\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W_i: The number of workers assigned to production line i (i = 1, 2, 3, 4)\n\nObjective Function:\n- Minimize Z = max(T_A, T_B, T_C)\n- Where T_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n- T_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n- T_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\nConstraints:\n1. W1 + W2 + W3 + W4 ≤ 50 (Total worker limit)\n2. W1, W2, W3, W4 ≥ 5 (Minimum worker requirement for each production line)\n3. W1, W2, W3, W4 ≤ 15 (Maximum worker limit for each production line)\n4. W1, W2, W3, W4 are integers\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ProductionScheduling\")\n\n# Add decision variables\nW1 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W1\")\nW2 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W2\")\nW3 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W3\")\nW4 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W4\")\n\n# Calculate production times\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\n# Set the objective function to minimize the maximum production time\nmodel.setObjective(cp.quicksum([T_A, T_B, T_C]), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum maximum production time: {:.2f} hours\".format(model.objval))\n    print(\"Workers assigned to production lines:\")\n    print(\"Line 1: {} workers\".format(W1.x))\n    print(\"Line 2: {} workers\".format(W2.x))\n    print(\"Line 3: {} workers\".format(W3.x))\n    print(\"Line 4: {} workers\".format(W4.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ProductionScheduling\")\n\n# Add decision variables\nW1 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W1\")\nW2 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W2\")\nW3 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W3\")\nW4 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W4\")\n\n# Calculate production times\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\n# Set the objective function to minimize the maximum production time\nmodel.setObjective(cp.quicksum([T_A, T_B, T_C]), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum maximum production time: {:.2f} hours\".format(model.objval))\n    print(\"Workers assigned to production lines:\")\n    print(\"Line 1: {} workers\".format(W1.x))\n    print(\"Line 2: {} workers\".format(W2.x))\n    print(\"Line 3: {} workers\".format(W3.x))\n    print(\"Line 4: {} workers\".format(W4.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "unsupported operand type(s) for /: 'int' and 'ExprBuilder'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\( W_i \\): The number of workers assigned to production line \\( i \\), where \\( i \\in \\{1, 2, 3, 4\\} \\).\n\nObjective Function:\n- Minimize the maximum production time for components A, B, and C, which is defined as:\n  - The production time for component A: \\( T_A = 1000 / (10 \\cdot W_1 + 8 \\cdot W_2 + 12 \\cdot W_3 + 15 \\cdot W_4) \\)\n  - The production time for component B: \\( T_B = 800 / (5 \\cdot W_1 + 10 \\cdot W_2 + 6 \\cdot W_3 + 8 \\cdot W_4) \\)\n  - The production time for component C: \\( T_C = 1200 / (15 \\cdot W_1 + 12 \\cdot W_2 + 10 \\cdot W_3 + 5 \\cdot W_4) \\)\n  - Objective: Minimize \\( Z = \\max(T_A, T_B, T_C) \\)\n\nConstraints:\n1. Minimum production time: \\( T_A \\geq 0 \\), \\( T_B \\geq 0 \\), \\( T_C \\geq 0 \\)\n2. Worker assignment limits: \\( W_i \\leq 15 \\) for all \\( i \\)\n3. Worker assignment requirements: \\( W_i \\geq 5 \\) for all \\( i \\)\n4. Integer constraints: \\( W_i \\) must be integers for all \\( i \\)\n5. Total available workers: \\( W_1 + W_2 + W_3 + W_4 \\leq 50 \\)\n6. Non-negativity: \\( W_i \\geq 0 \\) for all \\( i \\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionPlanning\")\n\n# Add decision variables\nW = {i: model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=f\"W_{i}\") for i in range(1, 5)}\n\n# Add constraints\nmodel.addConstr(W[1] + W[2] + W[3] + W[4] <= 50, name=\"TotalWorkers\")\nmodel.addConstr(W[i] >= 5 for i in range(1, 5), name=f\"MinWorkers_{i}\")\n\n# Set the objective function\nT_A = 1000 / (10 * W[1] + 8 * W[2] + 12 * W[3] + 15 * W[4])\nT_B = 800 / (5 * W[1] + 10 * W[2] + 6 * W[3] + 8 * W[4])\nT_C = 1200 / (15 * W[1] + 12 * W[2] + 10 * W[3] + 5 * W[4])\nmodel.setObjective(cp.quicksum([T_A, T_B, T_C]), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum maximum production time: {:.2f} hours\".format(model.objval))\n    for i in range(1, 5):\n        print(f\"Number of workers assigned to production line {i}: {W[i].x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionPlanning\")\n\n# Add decision variables\nW = {i: model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=f\"W_{i}\") for i in range(1, 5)}\n\n# Add constraints\nmodel.addConstr(W[1] + W[2] + W[3] + W[4] <= 50, name=\"TotalWorkers\")\nmodel.addConstr(W[i] >= 5 for i in range(1, 5), name=f\"MinWorkers_{i}\")\n\n# Set the objective function\nT_A = 1000 / (10 * W[1] + 8 * W[2] + 12 * W[3] + 15 * W[4])\nT_B = 800 / (5 * W[1] + 10 * W[2] + 6 * W[3] + 8 * W[4])\nT_C = 1200 / (15 * W[1] + 12 * W[2] + 10 * W[3] + 5 * W[4])\nmodel.setObjective(cp.quicksum([T_A, T_B, T_C]), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum maximum production time: {:.2f} hours\".format(model.objval))\n    for i in range(1, 5):\n        print(f\"Number of workers assigned to production line {i}: {W[i].x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Generator expression must be parenthesized (<string>, line 15)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W1, W2, W3, W4: Number of workers assigned to production lines 1, 2, 3, and 4 respectively.\n\nObjective Function:\n- Minimize Z = max(1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4), 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4), 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4))\n\nConstraints:\n1. W1 + W2 + W3 + W4 ≤ 50 (Total number of workers available)\n2. W1, W2, W3, W4 ≤ 15 (Maximum number of workers per production line)\n3. W1, W2, W3, W4 ≥ 5 (Minimum number of workers per production line)\n4. W1, W2, W3, W4 are integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionScheduling\")\n\n# Add decision variables\nW1 = model.addVar(lb=5, ub=15, name=\"W1\")  # Number of workers assigned to production line 1\nW2 = model.addVar(lb=5, ub=15, name=\"W2\")  # Number of workers assigned to production line 2\nW3 = model.addVar(lb=5, ub=15, name=\"W3\")  # Number of workers assigned to production line 3\nW4 = model.addVar(lb=5, ub=15, name=\"W4\")  # Number of workers assigned to production line 4\n\n# Add constraints\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkers\")  # Total number of workers available\n\n# Set the objective function to minimize the maximum production time\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\nmodel.setObjective(cp.quicksum(T_A, T_B, T_C), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum production time: {:.2f}\".format(model.objval))\n    print(f\"Number of workers assigned to production line 1: {W1.x}\")\n    print(f\"Number of workers assigned to production line 2: {W2.x}\")\n    print(f\"Number of workers assigned to production line 3: {W3.x}\")\n    print(f\"Number of workers assigned to production line 4: {W4.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionScheduling\")\n\n# Add decision variables\nW1 = model.addVar(lb=5, ub=15, name=\"W1\")  # Number of workers assigned to production line 1\nW2 = model.addVar(lb=5, ub=15, name=\"W2\")  # Number of workers assigned to production line 2\nW3 = model.addVar(lb=5, ub=15, name=\"W3\")  # Number of workers assigned to production line 3\nW4 = model.addVar(lb=5, ub=15, name=\"W4\")  # Number of workers assigned to production line 4\n\n# Add constraints\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkers\")  # Total number of workers available\n\n# Set the objective function to minimize the maximum production time\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\nmodel.setObjective(cp.quicksum(T_A, T_B, T_C), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum production time: {:.2f}\".format(model.objval))\n    print(f\"Number of workers assigned to production line 1: {W1.x}\")\n    print(f\"Number of workers assigned to production line 2: {W2.x}\")\n    print(f\"Number of workers assigned to production line 3: {W3.x}\")\n    print(f\"Number of workers assigned to production line 4: {W4.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "unsupported operand type(s) for /: 'int' and 'ExprBuilder'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W_i: Number of workers assigned to production line i, where i ∈ {1, 2, 3, 4}.\n\nObjective Function:\n- Minimize Z = max(1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4), 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4), 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)).\n\nConstraints:\n1. Production line availability: W_i ≤ 15 for all i ∈ {1, 2, 3, 4}.\n2. Minimum workers per line: W_i ≥ 5 for all i ∈ {1, 2, 3, 4}.\n3. Total workers: W1 + W2 + W3 + W4 ≤ 50.\n4. Non-negativity: W_i ≥ 0 for all i ∈ {1, 2, 3, 4}.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionOptimization\")\n\n# Add decision variables\nW1 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W1\")  # Number of workers assigned to production line 1\nW2 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W2\")  # Number of workers assigned to production line 2\nW3 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W3\")  # Number of workers assigned to production line 3\nW4 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W4\")  # Number of workers assigned to production line 4\n\n# Add constraints\nmodel.addConstr(W1 >= 5, name=\"MinWorkersLine1\")  # Minimum workers per line for line 1\nmodel.addConstr(W2 >= 5, name=\"MinWorkersLine2\")  # Minimum workers per line for line 2\nmodel.addConstr(W3 >= 5, name=\"MinWorkersLine3\")  # Minimum workers per line for line 3\nmodel.addConstr(W4 >= 5, name=\"MinWorkersLine4\")  # Minimum workers per line for line 4\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkers\")  # Total workers constraint\n\n# Define the production time for each component\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\n# Add the objective function\nmodel.setObjective(T_A, sense=COPT.MINIMIZE)  # Minimize the maximum production time for component A\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum production time for component A: {T_A:.2f} hours\")\n    print(f\"Minimum production time for component B: {T_B:.2f} hours\")\n    print(f\"Minimum production time for component C: {T_C:.2f} hours\")\n    print(f\"Minimum maximum production time: {max(T_A, T_B, T_C):.2f} hours\")\n    print(f\"Optimal number of workers assigned to each production line:\")\n    print(f\"Line 1: {W1.x}\")\n    print(f\"Line 2: {W2.x}\")\n    print(f\"Line 3: {W3.x}\")\n    print(f\"Line 4: {W4.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionOptimization\")\n\n# Add decision variables\nW1 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W1\")  # Number of workers assigned to production line 1\nW2 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W2\")  # Number of workers assigned to production line 2\nW3 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W3\")  # Number of workers assigned to production line 3\nW4 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W4\")  # Number of workers assigned to production line 4\n\n# Add constraints\nmodel.addConstr(W1 >= 5, name=\"MinWorkersLine1\")  # Minimum workers per line for line 1\nmodel.addConstr(W2 >= 5, name=\"MinWorkersLine2\")  # Minimum workers per line for line 2\nmodel.addConstr(W3 >= 5, name=\"MinWorkersLine3\")  # Minimum workers per line for line 3\nmodel.addConstr(W4 >= 5, name=\"MinWorkersLine4\")  # Minimum workers per line for line 4\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkers\")  # Total workers constraint\n\n# Define the production time for each component\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\n# Add the objective function\nmodel.setObjective(T_A, sense=COPT.MINIMIZE)  # Minimize the maximum production time for component A\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum production time for component A: {T_A:.2f} hours\")\n    print(f\"Minimum production time for component B: {T_B:.2f} hours\")\n    print(f\"Minimum production time for component C: {T_C:.2f} hours\")\n    print(f\"Minimum maximum production time: {max(T_A, T_B, T_C):.2f} hours\")\n    print(f\"Optimal number of workers assigned to each production line:\")\n    print(f\"Line 1: {W1.x}\")\n    print(f\"Line 2: {W2.x}\")\n    print(f\"Line 3: {W3.x}\")\n    print(f\"Line 4: {W4.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "unsupported operand type(s) for /: 'int' and 'ExprBuilder'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W1, W2, W3, W4: The number of workers assigned to production lines 1, 2, 3, and 4, respectively.\n\nObjective Function:\n- Minimize the maximum production time for components A, B, and C: Z = max(1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4), 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4), 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4))\n\nConstraints:\n1. Daily demand: \n   - 10 * W1 + 8 * W2 + 12 * W3 + 15 * W4 ≥ 1000\n   - 5 * W1 + 10 * W2 + 6 * W3 + 8 * W4 ≥ 800\n   - 15 * W1 + 12 * W2 + 10 * W3 + 5 * W4 ≥ 1200\n2. Worker availability: W1 + W2 + W3 + W4 ≤ 50\n3. Line capacity: W1 ≤ 15, W2 ≤ 15, W3 ≤ 15, W4 ≤ 15\n4. Minimum workers: W1 ≥ 5, W2 ≥ 5, W3 ≥ 5, W4 ≥ 5\n5. Non-negativity and integer: W1, W2, W3, W4 ≥ 0 and integers.\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W1: Number of workers assigned to Line 1.\n- W2: Number of workers assigned to Line 2.\n- W3: Number of workers assigned to Line 3.\n- W4: Number of workers assigned to Line 4.\n\nObjective Function:\nMinimize Z = max(T_A, T_B, T_C), where:\n- T_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n- T_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n- T_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\nConstraints:\n1. W1 + W2 + W3 + W4 ≤ 50 (Total number of workers available)\n2. W1 ≥ 5 (Minimum number of workers required for Line 1)\n3. W2 ≥ 5 (Minimum number of workers required for Line 2)\n4. W3 ≥ 5 (Minimum number of workers required for Line 3)\n5. W4 ≥ 5 (Minimum number of workers required for Line 4)\n6. W1 ≤ 15 (Maximum number of workers allowed for Line 1)\n7. W2 ≤ 15 (Maximum number of workers allowed for Line 2)\n8. W3 ≤ 15 (Maximum number of workers allowed for Line 3)\n9. W4 ≤ 15 (Maximum number of workers allowed for Line 4)\n10. W1, W2, W3, W4 ≥ 0 (Non-negativity)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionScheduling\")\n\n# Add decision variables\nW1 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W1\")\nW2 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W2\")\nW3 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W3\")\nW4 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W4\")\n\n# Add constraints\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkers\")\n\n# Set the objective function\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\nmodel.setObjective(max(T_A, T_B, T_C), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum maximum production time: {:.2f}\".format(model.objval))\n    print(\"Optimal worker assignment:\")\n    print(\"Line 1: {} workers\".format(W1.x))\n    print(\"Line 2: {} workers\".format(W2.x))\n    print(\"Line 3: {} workers\".format(W3.x))\n    print(\"Line 4: {} workers\".format(W4.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionScheduling\")\n\n# Add decision variables\nW1 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W1\")\nW2 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W2\")\nW3 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W3\")\nW4 = model.addVar(lb=5, ub=15, vtype=COPT.INTEGER, name=\"W4\")\n\n# Add constraints\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkers\")\n\n# Set the objective function\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\nmodel.setObjective(max(T_A, T_B, T_C), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum maximum production time: {:.2f}\".format(model.objval))\n    print(\"Optimal worker assignment:\")\n    print(\"Line 1: {} workers\".format(W1.x))\n    print(\"Line 2: {} workers\".format(W2.x))\n    print(\"Line 3: {} workers\".format(W3.x))\n    print(\"Line 4: {} workers\".format(W4.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "unsupported operand type(s) for /: 'int' and 'ExprBuilder'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W1, W2, W3, W4: Number of workers assigned to each production line (integer, non-negative).\n\nObjective Function:\n- Minimize Z = max(1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4), 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4), 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4))\n\nConstraints:\n1. W1 + W2 + W3 + W4 ≤ 50 (Total number of workers available).\n2. W1 ≤ 15, W2 ≤ 15, W3 ≤ 15, W4 ≤ 15 (Maximum number of workers per production line).\n3. W1 ≥ 5, W2 ≥ 5, W3 ≥ 5, W4 ≥ 5 (Minimum number of workers per production line).\n4. W1, W2, W3, W4 are integers.\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      }
    ],
    "answer": 0.0,
    "cloze": "A bubble tea shop sells mango and lychee bubble tea. Each mango bubble tea requires ____ units of mango juice and ____ units of tea. Each lychee bubble tea requires ____ units of lychee juice and ____ units of tea. The shop has available ____ units of mango juice and ____ units of lychee juice. ____ ____ ____ of the bubble teas made must be lychee flavored. However, mango bubble tea sells better and thus the number of mango bubble teas made must be ____ the number of lychee bubble teas made. How many of each bubble tea flavor should be made to ____ the total amount of tea needed?"
  },
  {
    "question": "A school is organizing a field trip to a science center and wants to hire small buses and large buses. A small bus can carry 20 students while a large bus can carry 50 students.  The school needs to provide transportation for at least 500 students.  In addition, since the parking lot is rather small, a maximum of 20% of the buses can be large buses. How many of each type of bus should be hired to minimize the total number of buses?",
    "pass_count": 4,
    "pass_rate": 0.5,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- $x1\\): amount invested in asset X1 (integer)\n- \\(x2\\): amount invested in asset X2 (integer)\n- \\(x3\\): amount invested in asset X3 (integer)\n- \\(x4\\): amount invested in asset X4 (integer)\n\nObjective Function:\nMinimize total cost:  \n\\[\nZ = 0.05x1 + 0.08x2 + 0.12x3 + 0.15x4\n\\]\n\nConstraints:\n1. Budget constraint:  \n\\[\nx1 + x2 + x3 + x4 \\leq 100000\n\\]\n\n2. Investment limits:\n- Minimum investment in asset X1:  \n\\[\nx1 \\geq 10000\n\\]\n- Maximum investment in asset X1:  \n\\[\nx1 \\leq 60000\n\\]\n- Minimum investment in asset X2:  \n\\[\nx2 \\geq 20000\n\\]\n- Maximum investment in asset X2:  \n\\[\nx2 \\leq 80000\n\\]\n- Minimum investment in asset X3:  \n\\[\nx3 \\geq 15000\n\\]\n- Maximum investment in asset X3:  \n\\[\nx3 \\leq 50000\n\\]\n- Minimum investment in asset X4:  \n\\[\nx4 \\geq 200\n\\]\n\n3. Additional constraints:\n- The difference between 60% of the investment in asset X1 and 40% of the investment in asset X2 must be non-negative:  \n\\[\n0.6x1 - 0.4x2 \\geq 0\n\\]\n- The sum of investments in assets X3 and X4 should not be less than the combined investments in assets X1 and X2 by more than \\$30000:  \n\\[\nx3 + x4 - (x1 + x2) \\geq -30000\n\\]\n- The difference between 70% of the investment in asset X3 and 50% of the investment in asset X4 should not exceed \\$500:  \n\\[\n0.7x3 - 0.5x4 \\leq 500\n\\]\n\nNon-negativity and integer constraints:  \n\\[\nx1, x2, x3, x4 \\geq 0 \\quad \\text{and integer}\n\\]\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(X1\\): Amount invested in asset X1 (in dollars)  \n- \\(X2\\): Amount invested in asset X2 (in dollars)  \n- \\(X3\\): Amount invested in asset X3 (in dollars)  \n- \\(X4\\): Amount invested in asset X4 (in dollars)  \n\nObjective Function:  \nMinimize total cost:  \n\\[\nZ = 0.05X1 + 0.08X2 + 0.12X3 + 0.15X4\n\\]\n\nConstraints:  \n1. Budget constraint:  \n\\[\nX1 + X2 + X3 + X4 \\leq 100000\n\\]  \n2. Investment limits:  \n\\[\n10000 \\leq X1 \\leq 60000\n\\]  \n\\[\n20000 \\leq X2 \\leq 80000\n\\]  \n\\[\n15000 \\leq X3 \\leq 50000\n\\]  \n\\[\nX4 \\geq 200\n\\]  \n3. Non-negativity and integer:  \n\\[\nX1, X2, X3, X4 \\geq 0 \\text{ and integer}\n\\]  \n4. Additional constraints:  \n\\[\n0.6X1 - 0.4X2 \\geq 0\n\\]  \n\\[\nX3 + X4 - X1 - X2 \\geq -30000\n\\]  \n\\[\n0.7X3 - 0.5X4 \\leq 500\n\\]  \n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x1\\): Amount invested in asset \\(X1\\), in dollars.\n- \\(x2\\): Amount invested in asset \\(X2\\), in dollars.\n- \\(x3\\): Amount invested in asset \\(X3\\), in dollars.\n- \\(x4\\): Amount invested in asset \\(X4\\), in dollars.\n\nObjective Function:\n- Minimize total investment cost:  \n  \\(Z = 0.05x1 + 0.08x2 + 0.12x3 + 0.15x4\\)\n\nConstraints:\n1. Budget constraint:  \n   \\(x1 + x2 + x3 + x4 \\leq 100000\\)\n2. Investment limits:  \n   \\(10000 \\leq x1 \\leq 60000\\)  \n   \\(20000 \\leq x2 \\leq 80000\\)  \n   \\(15000 \\leq x3 \\leq 50000\\)  \n   \\(x4 \\geq 200\\)\n3. Additional constraints:  \n   \\(0.6x1 - 0.4x2 \\geq 0\\)  \n   \\(x3 + x4 - x1 - x2 \\geq -30000\\)  \n   \\(0.7x3 - 0.5x4 \\leq 500\\)\n\nNon-negativity and integer:  \n- \\(x1, x2, x3, x4 \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"PortfolioManagement\")\n\n# Add decision variables\nx1 = model.addVar(lb=10000, ub=60000, name=\"x1\")\nx2 = model.addVar(lb=20000, ub=80000, name=\"x2\")\nx3 = model.addVar(lb=15000, ub=50000, name=\"x3\")\nx4 = model.addVar(lb=200, name=\"x4\")\n\n# Add constraints\nmodel.addConstr(x1 + x2 + x3 + x4 <= 100000, name=\"BudgetConstraint\")\nmodel.addConstr(0.6 * x1 - 0.4 * x2 >= 0, name=\"DifferenceConstraint1\")\nmodel.addConstr(x3 + x4 - x1 - x2 >= -30000, name=\"DifferenceConstraint2\")\nmodel.addConstr(0.7 * x3 - 0.5 * x4 <= 500, name=\"DifferenceConstraint3\")\n\n# Set the objective function\nmodel.setObjective(0.05 * x1 + 0.08 * x2 + 0.12 * x3 + 0.15 * x4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total investment cost: ${model.objval:.2f}\")\n    print(f\"Optimal investment plan: {x1.x}, {x2.x}, {x3.x}, {x4.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"PortfolioManagement\")\n\n# Add decision variables\nx1 = model.addVar(lb=10000, ub=60000, name=\"x1\")\nx2 = model.addVar(lb=20000, ub=80000, name=\"x2\")\nx3 = model.addVar(lb=15000, ub=50000, name=\"x3\")\nx4 = model.addVar(lb=200, name=\"x4\")\n\n# Add constraints\nmodel.addConstr(x1 + x2 + x3 + x4 <= 100000, name=\"BudgetConstraint\")\nmodel.addConstr(0.6 * x1 - 0.4 * x2 >= 0, name=\"DifferenceConstraint1\")\nmodel.addConstr(x3 + x4 - x1 - x2 >= -30000, name=\"DifferenceConstraint2\")\nmodel.addConstr(0.7 * x3 - 0.5 * x4 <= 500, name=\"DifferenceConstraint3\")\n\n# Set the objective function\nmodel.setObjective(0.05 * x1 + 0.08 * x2 + 0.12 * x3 + 0.15 * x4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total investment cost: ${model.objval:.2f}\")\n    print(f\"Optimal investment plan: {x1.x}, {x2.x}, {x3.x}, {x4.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 52a6e85f\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing an LP problem\n\nThe original problem has:\n    4 rows, 4 columns and 12 non-zero elements\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    7.0668521816e+03            1           0       0.00s\nDual             1    7.0668671817e+03            0           0       0.00s\nPostsolving\nDual             1    7.0666666667e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 7.0666666667e+03  Iterations: 1  Time: 0.00s\nMinimum total investment cost: $7066.67\nOptimal investment plan: 13333.333333333334, 20000.0, 15000.0, 20000.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(X1\\): Investment amount in asset X1 (in dollars).\n- \\(X2\\): Investment amount in asset X2 (in dollars).\n- \\(X3\\): Investment amount in asset X3 (in dollars).\n- \\(X4\\): Investment amount in asset X4 (in dollars).\n\nObjective Function:\n- Minimize total investment cost: \\(Z = 0.05X1 + 0.08X2 + 0.12X3 + 0.15X4\\)\n\nConstraints:\n1. Budget constraint: \\(X1 + X2 + X3 + X4 \\leq 100000\\)\n2. Investment range for asset X1: \\(10000 \\leq X1 \\leq 60000\\)\n3. Investment range for asset X2: \\(20000 \\leq X2 \\leq 80000\\)\n4. Investment range for asset X3: \\(15000 \\leq X3 \\leq 50000\\)\n5. No upper limit for asset X4: \\(X4 \\geq 200\\)\n6. Condition on X1 and X2: \\(0.6X1 - 0.4X2 \\geq 0\\)\n7. Condition on X3 and X4: \\(X3 + X4 - (X1 + X2) \\leq 30000\\)\n8. Condition on X3 and X4: \\(0.7X3 - 0.5X4 \\leq 500\\)\n9. Non-negativity and integer constraints: \\(X1, X2, X3, X4 \\geq 0\\), and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"FinancialPortfolioOptimization\")\n\n# Define decision variables\nX1 = model.addVar(lb=10000, ub=60000, vtype=COPT.INTEGER, name=\"X1\")  # Investment amount in asset X1\nX2 = model.addVar(lb=20000, ub=80000, vtype=COPT.INTEGER, name=\"X2\")  # Investment amount in asset X2\nX3 = model.addVar(lb=15000, ub=50000, vtype=COPT.INTEGER, name=\"X3\")  # Investment amount in asset X3\nX4 = model.addVar(lb=200, vtype=COPT.INTEGER, name=\"X4\")  # Investment amount in asset X4\n\n# Define the objective function\ntotal_cost = 0.05 * X1 + 0.08 * X2 + 0.12 * X3 + 0.15 * X4\nmodel.setObjective(total_cost, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(X1 + X2 + X3 + X4 <= 100000, name=\"BudgetConstraint\")  # Budget constraint\nmodel.addConstr(0.6 * X1 - 0.4 * X2 >= 0, name=\"ConditionX1X2\")  # Condition on X1 and X2\nmodel.addConstr(X3 + X4 - (X1 + X2) <= 30000, name=\"ConditionX3X4\")  # Condition on X3 and X4\nmodel.addConstr(0.7 * X3 - 0.5 * X4 <= 500, name=\"ConditionX3X42\")  # Condition on X3 and X4\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total cost: ${:.2f}\".format(model.objval))\n    print(\"Optimal investment amounts:\")\n    print(f\"Asset X1: ${X1.x}\")\n    print(f\"Asset X2: ${X2.x}\")\n    print(f\"Asset X3: ${X3.x}\")\n    print(f\"Asset X4: ${X4.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"FinancialPortfolioOptimization\")\n\n# Define decision variables\nX1 = model.addVar(lb=10000, ub=60000, vtype=COPT.INTEGER, name=\"X1\")  # Investment amount in asset X1\nX2 = model.addVar(lb=20000, ub=80000, vtype=COPT.INTEGER, name=\"X2\")  # Investment amount in asset X2\nX3 = model.addVar(lb=15000, ub=50000, vtype=COPT.INTEGER, name=\"X3\")  # Investment amount in asset X3\nX4 = model.addVar(lb=200, vtype=COPT.INTEGER, name=\"X4\")  # Investment amount in asset X4\n\n# Define the objective function\ntotal_cost = 0.05 * X1 + 0.08 * X2 + 0.12 * X3 + 0.15 * X4\nmodel.setObjective(total_cost, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(X1 + X2 + X3 + X4 <= 100000, name=\"BudgetConstraint\")  # Budget constraint\nmodel.addConstr(0.6 * X1 - 0.4 * X2 >= 0, name=\"ConditionX1X2\")  # Condition on X1 and X2\nmodel.addConstr(X3 + X4 - (X1 + X2) <= 30000, name=\"ConditionX3X4\")  # Condition on X3 and X4\nmodel.addConstr(0.7 * X3 - 0.5 * X4 <= 500, name=\"ConditionX3X42\")  # Condition on X3 and X4\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total cost: ${:.2f}\".format(model.objval))\n    print(\"Optimal investment amounts:\")\n    print(f\"Asset X1: ${X1.x}\")\n    print(f\"Asset X2: ${X2.x}\")\n    print(f\"Asset X3: ${X3.x}\")\n    print(f\"Asset X4: ${X4.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 7ad6766a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 4 columns and 12 non-zero elements\n    4 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 7066.700000000\nBest bound      : 7066.700000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total cost: $7066.70\nOptimal investment amounts:\nAsset X1: $13334.0\nAsset X2: $20000.0\nAsset X3: $15000.0\nAsset X4: $20000.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x1\\): Investment in asset \\(X1\\) (in dollars)\n- \\(x2\\): Investment in asset \\(X2\\) (in dollars)\n- \\(x3\\): Investment in asset \\(X3\\) (in dollars)\n- \\(x4\\): Investment in asset \\(X4\\) (in dollars)\n\nObjective Function:\n- Minimize total cost: \\(Z = 0.05x1 + 0.08x2 + 0.12x3 + 0.15x4\\)\n\nConstraints:\n1. Total investment budget: \\(x1 + x2 + x3 + x4 \\leq 100000\\)\n2. Minimum and maximum investment for asset \\(X1\\): \\(10000 \\leq x1 \\leq 60000\\)\n3. Minimum and maximum investment for asset \\(X2\\): \\(20000 \\leq x2 \\leq 80000\\)\n4. Minimum and maximum investment for asset \\(X3\\): \\(15000 \\leq x3 \\leq 50000\\)\n5. Minimum investment for asset \\(X4\\): \\(x4 \\geq 200\\)\n6. Condition on \\(X1\\) and \\(X2\\): \\(0.6x1 - 0.4x2 \\geq 0\\)\n7. Condition on \\(X3\\) and \\(X4\\): \\(x3 + x4 \\geq x1 + x2 - 30000\\)\n8. Condition on \\(X3\\) and \\(X4\\): \\(0.7x3 - 0.5x4 \\leq 500\\)\n9. Integer constraints: \\(x1, x2, x3, x4 \\in \\mathbb{Z}^+\\)\n10. Non-negativity constraints: \\(x1, x2, x3, x4 \\geq 0\\)\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x1\\): Amount invested in asset \\(X1\\)\n- \\(x2\\): Amount invested in asset \\(X2\\)\n- \\(x3\\): Amount invested in asset \\(X3\\)\n- \\(x4\\): Amount invested in asset \\(X4\\)\n\nObjective Function:\n- Minimize total cost: \\(Z = 0.05x1 + 0.08x2 + 0.12x3 + 0.15x4\\)\n\nConstraints:\n1. Budget constraint: \\(x1 + x2 + x3 + x4 \\leq 100000\\)\n2. Investment limits:\n   - \\(10000 \\leq x1 \\leq 60000\\)\n   - \\(20000 \\leq x2 \\leq 80000\\)\n   - \\(15000 \\leq x3 \\leq 50000\\)\n   - \\(200 \\leq x4\\)\n3. Investment conditions:\n   - \\(0.6x1 - 0.4x2 \\geq 0\\)\n   - \\(-x1 - x2 + x3 + x4 \\geq -30000\\)\n   - \\(0.7x3 - 0.5x4 \\leq 500\\)\n\nNon-negativity and Integer:\n- \\(x1, x2, x3, x4 \\geq 0\\)\n- \\(x1, x2, x3, x4\\) must be integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"PortfolioOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=10000, ub=60000, name=\"x1\")\nx2 = model.addVar(lb=20000, ub=80000, name=\"x2\")\nx3 = model.addVar(lb=15000, ub=50000, name=\"x3\")\nx4 = model.addVar(lb=200, name=\"x4\")\n\n# Add constraints\nmodel.addConstr(x1 + x2 + x3 + x4 <= 100000, name=\"BudgetConstraint\")\nmodel.addConstr(0.6*x1 - 0.4*x2 >= 0, name=\"InvestmentCondition1\")\nmodel.addConstr(-x1 - x2 + x3 + x4 >= -30000, name=\"InvestmentCondition2\")\nmodel.addConstr(0.7*x3 - 0.5*x4 <= 500, name=\"InvestmentCondition3\")\n\n# Set the objective function\nmodel.setObjective(0.05*x1 + 0.08*x2 + 0.12*x3 + 0.15*x4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total cost: {:.2f}\".format(model.objval))\n    print(\"Optimal investment amounts:\")\n    print(f\"Asset X1: {x1.x}\")\n    print(f\"Asset X2: {x2.x}\")\n    print(f\"Asset X3: {x3.x}\")\n    print(f\"Asset X4: {x4.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"PortfolioOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=10000, ub=60000, name=\"x1\")\nx2 = model.addVar(lb=20000, ub=80000, name=\"x2\")\nx3 = model.addVar(lb=15000, ub=50000, name=\"x3\")\nx4 = model.addVar(lb=200, name=\"x4\")\n\n# Add constraints\nmodel.addConstr(x1 + x2 + x3 + x4 <= 100000, name=\"BudgetConstraint\")\nmodel.addConstr(0.6*x1 - 0.4*x2 >= 0, name=\"InvestmentCondition1\")\nmodel.addConstr(-x1 - x2 + x3 + x4 >= -30000, name=\"InvestmentCondition2\")\nmodel.addConstr(0.7*x3 - 0.5*x4 <= 500, name=\"InvestmentCondition3\")\n\n# Set the objective function\nmodel.setObjective(0.05*x1 + 0.08*x2 + 0.12*x3 + 0.15*x4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total cost: {:.2f}\".format(model.objval))\n    print(\"Optimal investment amounts:\")\n    print(f\"Asset X1: {x1.x}\")\n    print(f\"Asset X2: {x2.x}\")\n    print(f\"Asset X3: {x3.x}\")\n    print(f\"Asset X4: {x4.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 52a6e85f\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing an LP problem\n\nThe original problem has:\n    4 rows, 4 columns and 12 non-zero elements\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    7.0668521816e+03            1           0       0.00s\nDual             1    7.0668671817e+03            0           0       0.00s\nPostsolving\nDual             1    7.0666666667e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 7.0666666667e+03  Iterations: 1  Time: 0.00s\nMinimum total cost: 7066.67\nOptimal investment amounts:\nAsset X1: 13333.333333333334\nAsset X2: 20000.0\nAsset X3: 15000.0\nAsset X4: 20000.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Investment amount in asset X1 (in dollars).\n- \\(x_2\\): Investment amount in asset X2 (in dollars).\n- \\(x_3\\): Investment amount in asset X3 (in dollars).\n- \\(x_4\\): Investment amount in asset X4 (in dollars).\n\nObjective Function:\n- Minimize total cost: \\(Z = 0.05x_1 + 0.08x_2 + 0.12x_3 + 0.15x_4\\)\n\nConstraints:\n1. Budget constraint: \\(x_1 + x_2 + x_3 + x_4 \\leq 100000\\)\n2. Minimum investment for X1: \\(x_1 \\geq 10000\\)\n3. Maximum investment for X1: \\(x_1 \\leq 60000\\)\n4. Minimum investment for X2: \\(x_2 \\geq 20000\\)\n5. Maximum investment for X2: \\(x_2 \\leq 80000\\)\n6. Minimum investment for X3: \\(x_3 \\geq 15000\\)\n7. Maximum investment for X3: \\(x_3 \\leq 50000\\)\n8. Minimum investment for X4: \\(x_4 \\geq 200\\)\n9. Non-negativity and integer: \\(x_1, x_2, x_3, x_4 \\geq 0\\) and integer\n10. Investment requirement 1: \\(0.6x_1 - 0.4x_2 \\geq 0\\)\n11. Investment requirement 2: \\(x_3 + x_4 - x_1 - x_2 \\geq -30000\\)\n12. Investment requirement 3: \\(0.7x_3 - 0.5x_4 \\leq 500\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model for the portfolio management problem\nmodel = env.createModel(\"PortfolioManagement\")\n\n# Define the investment amounts for the assets\nx1 = model.addVar(lb=10000, ub=60000, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=20000, ub=80000, vtype=COPT.INTEGER, name=\"x2\")\nx3 = model.addVar(lb=15000, ub=50000, vtype=COPT.INTEGER, name=\"x3\")\nx4 = model.addVar(lb=200, vtype=COPT.INTEGER, name=\"x4\")\n\n# Add constraints\nmodel.addConstr(x1 + x2 + x3 + x4 <= 100000, name=\"BudgetConstraint\")\nmodel.addConstr(0.6*x1 - 0.4*x2 >= 0, name=\"InvestmentRequirement1\")\nmodel.addConstr(x3 + x4 - x1 - x2 >= -30000, name=\"InvestmentRequirement2\")\nmodel.addConstr(0.7*x3 - 0.5*x4 <= 500, name=\"InvestmentRequirement3\")\n\n# Set the objective function\nmodel.setObjective(0.05*x1 + 0.08*x2 + 0.12*x3 + 0.15*x4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total cost: ${model.objval:.2f}\")\n    print(f\"Optimal investment amounts:\")\n    print(f\"Asset X1: ${x1.x:.2f}\")\n    print(f\"Asset X2: ${x2.x:.2f}\")\n    print(f\"Asset X3: ${x3.x:.2f}\")\n    print(f\"Asset X4: ${x4.x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model for the portfolio management problem\nmodel = env.createModel(\"PortfolioManagement\")\n\n# Define the investment amounts for the assets\nx1 = model.addVar(lb=10000, ub=60000, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=20000, ub=80000, vtype=COPT.INTEGER, name=\"x2\")\nx3 = model.addVar(lb=15000, ub=50000, vtype=COPT.INTEGER, name=\"x3\")\nx4 = model.addVar(lb=200, vtype=COPT.INTEGER, name=\"x4\")\n\n# Add constraints\nmodel.addConstr(x1 + x2 + x3 + x4 <= 100000, name=\"BudgetConstraint\")\nmodel.addConstr(0.6*x1 - 0.4*x2 >= 0, name=\"InvestmentRequirement1\")\nmodel.addConstr(x3 + x4 - x1 - x2 >= -30000, name=\"InvestmentRequirement2\")\nmodel.addConstr(0.7*x3 - 0.5*x4 <= 500, name=\"InvestmentRequirement3\")\n\n# Set the objective function\nmodel.setObjective(0.05*x1 + 0.08*x2 + 0.12*x3 + 0.15*x4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total cost: ${model.objval:.2f}\")\n    print(f\"Optimal investment amounts:\")\n    print(f\"Asset X1: ${x1.x:.2f}\")\n    print(f\"Asset X2: ${x2.x:.2f}\")\n    print(f\"Asset X3: ${x3.x:.2f}\")\n    print(f\"Asset X4: ${x4.x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 58fc49af\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 4 columns and 12 non-zero elements\n    4 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 7066.700000000\nBest bound      : 7066.700000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total cost: $7066.70\nOptimal investment amounts:\nAsset X1: $13334.00\nAsset X2: $20000.00\nAsset X3: $15000.00\nAsset X4: $20000.00",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(X1, X2, X3, X4\\): The amount of investment (in dollars) in assets X1, X2, X3, and X4 respectively.\n\nObjective Function:\n- Minimize total investment cost: \\(Z = 0.05 \\times X1 + 0.08 \\times X2 + 0.12 \\times X3 + 0.15 \\times X4\\)\n\nConstraints:\n1. Total investment budget: \\(X1 + X2 + X3 + X4 \\leq 100000\\)\n2. Minimum and maximum investment limits for assets:\n   - \\(10000 \\leq X1 \\leq 60000\\)\n   - \\(20000 \\leq X2 \\leq 80000\\)\n   - \\(15000 \\leq X3 \\leq 50000\\)\n   - \\(X4 \\geq 200\\)\n3. Investment condition 1: \\(0.6 \\times X1 - 0.4 \\times X2 \\geq 0\\)\n4. Investment condition 2: \\(X3 + X4 - X1 - X2 \\leq 30000\\)\n5. Investment condition 3: \\(0.7 \\times X3 - 0.5 \\times X4 \\leq 500\\)\n6. Non-negativity and integer constraints: \\(X1, X2, X3, X4 \\geq 0\\) and all are integers.\n</model>",
        "code": "",
        "exec_output": "[Error: Empty code]",
        "pass": false
      }
    ],
    "answer": 20.0,
    "cloze": "A school is organizing a field trip to a science center and wants to hire small buses and large buses. A small bus can carry ____ students while a large bus can carry ____ students. The school needs to provide transportation for ____ ____ students. In addition, since the parking lot is rather small, ____ ____ ____ of the buses can be large buses. How many of each type of bus should be hired to ____ the total number of buses?"
  }
]
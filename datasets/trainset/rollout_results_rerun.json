[
  {
    "question": "A transportation company is planning to allocate its fleet of vehicles across three routes: $X, Y$, and $Z$. Each route requires a different type of vehicle with varying operating costs. The operating cost per vehicle for routes $X, Y$, and $Z$ are 10, 15, and 20 units respectively. The company aims to minimize the total operating cost while adhering to the following constraints:\\n\\n- Due to traffic restrictions and road capacity, the combined number of vehicles on routes X and Y cannot exceed 1000.\\n- Similarly, the combined number of vehicles on routes Y and Z cannot exceed 800 due to similar limitations.\\n- To maintain service levels across all regions served by these routes, the sum of vehicles on routes X and Z must be at least 500.\\n\\nThe allocation must also respect individual route capacity limits due to physical or regulatory restrictions: route X can accommodate up to 700 vehicles; route Y can have a maximum of 600 vehicles; while route Z can only handle up to 400 vehicles. Given that each route's allocation must be in whole numbers due to the indivisible nature of a vehicle,\\n\\nWhat is the minimum total operating cost for this scenario when optimal allocations are made for each route? Please provide your answer rounded to nearest whole number.",
    "pass_count": 5,
    "pass_rate": 0.625,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- x1: Number of strawberry cookies produced per day.\n- x2: Number of sugar cookies produced per day.\n\nObjective Function:\nMaximize profit: Z = 5.5 * x1 + 12 * x2\n\nConstraints:\n1. Demand limit for strawberry cookies: x1 ≤ 100\n2. Demand limit for sugar cookies: x2 ≤ 80\n3. Staff capacity limit: x1 + x2 ≤ 100\n4. Non-negativity: x1, x2 ≥ 0\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced\n\n# Set the objective function\nmodel.setObjective(5.5 * x1 + 12 * x2, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemandLimit\")  # Demand limit for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemandLimit\")  # Demand limit for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"StaffCapacityLimit\")  # Staff capacity limit\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Number of strawberry cookies produced: {}\".format(x1.x))\n    print(\"Number of sugar cookies produced: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced\n\n# Set the objective function\nmodel.setObjective(5.5 * x1 + 12 * x2, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemandLimit\")  # Demand limit for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemandLimit\")  # Demand limit for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"StaffCapacityLimit\")  # Staff capacity limit\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Number of strawberry cookies produced: {}\".format(x1.x))\n    print(\"Number of sugar cookies produced: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.00s\nMaximized profit: $1070.0\nNumber of strawberry cookies produced: 20.0\nNumber of sugar cookies produced: 80.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: The number of strawberry cookies produced per day.\n- x2: The number of sugar cookies produced per day.\n\nObjective Function:\nMaximize profit: Z = 5.5x1 + 12x2\n\nConstraints:\n1. Daily demand for strawberry cookies: x1 ≤ 100\n2. Daily demand for sugar cookies: x2 ≤ 80\n3. Maximum production capacity: x1 + x2 ≤ 100\n4. Non-negativity: x1 ≥ 0, x2 ≥ 0\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced per day\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Daily demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")  # Daily demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"ProductionCapacity\")  # Maximum production capacity\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum profit: ${}\".format(model.objval))\n    print(\"Number of strawberry cookies produced: {}\".format(x1.x))\n    print(\"Number of sugar cookies produced: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced per day\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Daily demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")  # Daily demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"ProductionCapacity\")  # Maximum production capacity\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum profit: ${}\".format(model.objval))\n    print(\"Number of strawberry cookies produced: {}\".format(x1.x))\n    print(\"Number of sugar cookies produced: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.00s\nMaximum profit: $1070.0\nNumber of strawberry cookies produced: 20.0\nNumber of sugar cookies produced: 80.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: Number of strawberry cookies to be made per day.\n- x2: Number of sugar cookies to be made per day.\n\nObjective Function:\n- Maximize profit: Z = 5.5*x1 + 12*x2\n\nConstraints:\n1. Daily demand for strawberry cookies: x1 ≤ 100\n2. Daily demand for sugar cookies: x2 ≤ 80\n3. Maximum number of cookies that can be made per day: x1 + x2 ≤ 100\n4. Non-negativity: x1, x2 ≥ 0\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakeryProfitMaximization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")\nx2 = model.addVar(lb=0, name=\"x2\")\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryCookieDemand\")\nmodel.addConstr(x2 <= 80, name=\"SugarCookieDemand\")\nmodel.addConstr(x1 + x2 <= 100, name=\"MaxCookieProduction\")\n\n# Solve the model\nmodel.solve()\n\n# Output the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Optimal production plan:\")\n    print(f\"Strawberry cookies: {x1.x}\")\n    print(f\"Sugar cookies: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakeryProfitMaximization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")\nx2 = model.addVar(lb=0, name=\"x2\")\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryCookieDemand\")\nmodel.addConstr(x2 <= 80, name=\"SugarCookieDemand\")\nmodel.addConstr(x1 + x2 <= 100, name=\"MaxCookieProduction\")\n\n# Solve the model\nmodel.solve()\n\n# Output the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Optimal production plan:\")\n    print(f\"Strawberry cookies: {x1.x}\")\n    print(f\"Sugar cookies: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.00s\nMaximized profit: $1070.0\nOptimal production plan:\nStrawberry cookies: 20.0\nSugar cookies: 80.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: Number of strawberry cookies produced per day.\n- x2: Number of sugar cookies produced per day.\n\nObjective Function:\n- Maximize total profit: Z = 5.5*x1 + 12*x2\n\nConstraints:\n1. Demand for strawberry cookies: x1 ≤ 100\n2. Demand for sugar cookies: x2 ≤ 80\n3. Staffing limit: x1 + x2 ≤ 100\n4. Non-negativity: x1, x2 ≥ 0\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakeryOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced per day\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"DemandStrawberry\")  # Demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"DemandSugar\")  # Demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"StaffingLimit\")  # Staffing limit\n\n# Set the objective function to maximize total profit\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized total profit: ${model.objval:.2f}\")\n    print(f\"Number of strawberry cookies produced per day: {x1.x}\")\n    print(f\"Number of sugar cookies produced per day: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakeryOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies produced per day\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"DemandStrawberry\")  # Demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"DemandSugar\")  # Demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"StaffingLimit\")  # Staffing limit\n\n# Set the objective function to maximize total profit\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized total profit: ${model.objval:.2f}\")\n    print(f\"Number of strawberry cookies produced per day: {x1.x}\")\n    print(f\"Number of sugar cookies produced per day: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.00s\nMaximized total profit: $1070.00\nNumber of strawberry cookies produced per day: 20.0\nNumber of sugar cookies produced per day: 80.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x1\\): the number of strawberry cookies produced per day.  \n- \\(x2\\): the number of sugar cookies produced per day.  \n\nObjective Function:  \nMaximize profit:  \n\\[\nZ = 5.5x1 + 12x2\n\\]  \n\nConstraints:  \n1. Maximum daily demand for strawberry cookies:  \n\\[\nx1 \\leq 100\n\\]  \n2. Maximum daily demand for sugar cookies:  \n\\[\nx2 \\leq 80\n\\]  \n3. Maximum daily production capacity:  \n\\[\nx1 + x2 \\leq 100\n\\]  \n4. Non-negativity:  \n\\[\nx1, x2 \\geq 0\n\\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"CookieProduction\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Maximum demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")        # Maximum demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"ProductionCapacity\")  # Maximum daily production capacity\n\n# Set the objective function\nmodel.setObjective(5.5 * x1 + 12 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total profit: ${:.2f}\".format(model.objval))\n    print(f\"Optimal production plan: {x1.x:.2f} strawberry cookies, {x2.x:.2f} sugar cookies\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"CookieProduction\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of strawberry cookies\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of sugar cookies\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")  # Maximum demand for strawberry cookies\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")        # Maximum demand for sugar cookies\nmodel.addConstr(x1 + x2 <= 100, name=\"ProductionCapacity\")  # Maximum daily production capacity\n\n# Set the objective function\nmodel.setObjective(5.5 * x1 + 12 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total profit: ${:.2f}\".format(model.objval))\n    print(f\"Optimal production plan: {x1.x:.2f} strawberry cookies, {x2.x:.2f} sugar cookies\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: ae93ba11\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 2 columns and 4 non-zero elements\nThe presolved problem has:\n    3 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    1.5119029919e+03            3           0       0.00s\nDual             2    1.0700439603e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.0700000000e+03  Iterations: 2  Time: 0.00s\nMaximized total profit: $1070.00\nOptimal production plan: 20.00 strawberry cookies, 80.00 sugar cookies",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- x1: The number of strawberry cookies produced.  \n- x2: The number of sugar cookies produced.  \n\nObjective Function:  \nMaximize profit Z = 5.5 * x1 + 12 * x2  \n\nConstraints:  \n1. Daily demand for strawberry cookies: x1 ≤ 100  \n2. Daily demand for sugar cookies: x2 ≤ 80  \n3. Staff capacity constraint: x1 + x2 ≤ 100  \n4. Non-negativity: x1 ≥ 0, x2 ≥ 0  \n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- x1: number of strawberry cookies produced per day.  \n- x2: number of sugar cookies produced per day.  \n\nObjective Function:  \nMaximize Z = 5.5*x1 + 12*x2  \n\nConstraints:  \n1. Demand for strawberry cookies: x1 ≤ 100  \n2. Demand for sugar cookies: x2 ≤ 80  \n3. Staffing constraint: x1 + x2 ≤ 100  \n4. Non-negativity: x1 ≥ 0, x2 ≥ 0  \n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: Number of strawberry cookies to be made.\n- x2: Number of sugar cookies to be made.\n\nObjective Function:\nMaximize Z = 5.5*x1 + 12*x2\n\nConstraints:\n1. x1 ≤ 100 (Daily demand for strawberry cookies)\n2. x2 ≤ 80 (Daily demand for sugar cookies)\n3. x1 + x2 ≤ 100 (Bakery's staff capacity)\n4. x1 ≥ 0 and x2 ≥ 0 (Non-negativity constraint)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")\nx2 = model.addVar(lb=0, name=\"x2\")\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")\nmodel.addConstr(x1 + x2 <= 100, name=\"StaffCapacity\")\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Number of strawberry cookies: {}\".format(x1.x))\n    print(\"Number of sugar cookies: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ZetaBakery\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")\nx2 = model.addVar(lb=0, name=\"x2\")\n\n# Set the objective function\nmodel.setObjective(5.5*x1 + 12*x2, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 100, name=\"StrawberryDemand\")\nmodel.addConstr(x2 <= 80, name=\"SugarDemand\")\nmodel.addConstr(x1 + x2 <= 100, name=\"StaffCapacity\")\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Number of strawberry cookies: {}\".format(x1.x))\n    print(\"Number of sugar cookies: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Error: Execution timeout",
        "pass": false
      }
    ],
    "answer": 5000.0,
    "cloze": "A transportation company is planning to allocate its fleet of vehicles across three routes: $X, Y$, and $Z$. Each route requires a different type of vehicle with varying operating costs. The operating cost per vehicle for routes $X, Y$, and $Z$ are ____, ____, and ____ units respectively. The company aims to ____ the total operating cost while adhering to the following constraints:\\n\\n- Due to traffic restrictions and road capacity, the combined number of vehicles on routes X and Y ____ ____.\\n- Similarly, the combined number of vehicles on routes Y and Z ____ ____ due to similar limitations.\\n- To maintain service levels across all regions served by these routes, the sum of vehicles on routes X and Z ____ ____.\\n\\nThe allocation must also respect individual route capacity limits due to physical or regulatory restrictions: route X can accommodate ____ ____ vehicles; route Y can have ____ ____ ____ vehicles; while route Z can only handle ____ ____ ____ vehicles. Given that each route's allocation must be in whole numbers due to the indivisible nature of a vehicle,\\n\\nWhat is the ____ total operating cost for this scenario when optimal allocations are made for each route? Please provide your answer rounded to nearest whole number."
  },
  {
    "question": "Gabriel is growing pumpkins and carrots on his farm. He has 100 acres available on which he must grow a minimum of 7 acres of pumpkins and a minimum of 12 acres of carrots to meet demands. The profit per pumpkin is $2.5 and the profit per carrot is $3.4. He prefers to grow more carrots than pumpkins but limitations in his workforce allow him to grow at most three times the amount of carrots as pumpkins. How many of each produce should Gabriel grow in order to maximize his profit?",
    "pass_count": 8,
    "pass_rate": 1.0,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_s\\): Number of small buses hired.\n- \\(x_l\\): Number of large buses hired.\n\nObjective Function:\nMinimize the total number of buses:  \n\\(Z = x_s + x_l\\)\n\nConstraints:\n1. The total number of students transported must be at least 500:  \n   \\(20x_s + 50x_l \\geq 500\\)\n2. The maximum proportion of large buses is 20%:  \n   \\(x_l \\leq 0.2(x_s + x_l)\\) or equivalently, \\(x_l \\leq 0.2x_s + 0.2x_l\\), which simplifies to \\(x_l \\leq 0.2x_s\\).\n3. Non-negativity and integer constraints:  \n   \\(x_s, x_l \\geq 0\\) and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"FieldTripBusHiring\")\n\n# Add decision variables\nx_s = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_s\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(20*x_s + 50*x_l >= 500, name=\"StudentTransportation\")\nmodel.addConstr(x_l <= 0.2*x_s, name=\"LargeBusProportion\")\n\n# Set the objective function\nmodel.setObjective(x_s + x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimized total number of buses: {model.objval}\")\n    print(f\"Number of small buses hired: {x_s.x}\")\n    print(f\"Number of large buses hired: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"FieldTripBusHiring\")\n\n# Add decision variables\nx_s = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_s\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(20*x_s + 50*x_l >= 500, name=\"StudentTransportation\")\nmodel.addConstr(x_l <= 0.2*x_s, name=\"LargeBusProportion\")\n\n# Set the objective function\nmodel.setObjective(x_s + x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimized total number of buses: {model.objval}\")\n    print(f\"Number of small buses hired: {x_s.x}\")\n    print(f\"Number of large buses hired: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: a6c8c538\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  6.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  5.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  2.000000e+01  2.500000e+01  20.00%  0.01s\nH        0         1      --       2  2.000000e+01  2.100000e+01  4.762%  0.01s\n         1         1     0.0       2  2.100000e+01  2.100000e+01  0.000%  0.01s\n         1         1     0.0       2  2.100000e+01  2.100000e+01  0.000%  0.01s\n\nBest solution   : 21.000000000\nBest bound      : 21.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimized total number of buses: 21.0\nNumber of small buses hired: 18.0\nNumber of large buses hired: 3.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of small buses hired.\n- \\(x_2\\): Number of large buses hired.\n\nObjective Function:\n- Minimize the total number of buses: \\(Z = x_1 + x_2\\).\n\nConstraints:\n1. Transportation capacity requirement: \\(20x_1 + 50x_2 \\geq 500\\).\n2. Maximum percentage of large buses: \\(x_2 \\leq 0.2(x_1 + x_2)\\), which simplifies to: \\(x_1 \\geq 4x_2\\).\n3. Non-negativity and integer constraints: \\(x_1, x_2 \\geq 0\\) and must be integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"TransportCapacity\")\nmodel.addConstr(x1 >= 4*x2, name=\"LargeBusLimit\")\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {}\".format(model.objval))\n    print(\"Optimal solution:\")\n    print(\"Number of small buses hired: {}\".format(x1.x))\n    print(\"Number of large buses hired: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"TransportCapacity\")\nmodel.addConstr(x1 >= 4*x2, name=\"LargeBusLimit\")\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {}\".format(model.objval))\n    print(\"Optimal solution:\")\n    print(\"Number of small buses hired: {}\".format(x1.x))\n    print(\"Number of large buses hired: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: f4e3af08\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.01s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.01s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of buses: 20.0\nOptimal solution:\nNumber of small buses hired: 16.0\nNumber of large buses hired: 4.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of small buses hired.\n- \\(x_2\\): Number of large buses hired.\n\nObjective Function:\nMinimize total number of buses:  \n\\(Z = x_1 + x_2\\)\n\nConstraints:\n1. The total number of students transported must be at least 500:  \n   \\(20x_1 + 50x_2 \\geq 500\\)\n2. The number of large buses cannot exceed 20% of the total number of buses:  \n   \\(x_2 \\leq 0.2(x_1 + x_2)\\)\n3. Non-negativity and integer constraints:  \n   \\(x_1, x_2 \\geq 0 \\text{ and integers}\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Decision Variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\n\n# Objective Function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Constraints\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"StudentCapacity\")\nmodel.addConstr(x2 <= 0.2*(x1 + x2), name=\"LargeBusLimit\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {}\".format(model.objval))\n    print(\"Number of small buses: {}\".format(x1.x))\n    print(\"Number of large buses: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Decision Variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\n\n# Objective Function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Constraints\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"StudentCapacity\")\nmodel.addConstr(x2 <= 0.2*(x1 + x2), name=\"LargeBusLimit\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {}\".format(model.objval))\n    print(\"Number of small buses: {}\".format(x1.x))\n    print(\"Number of large buses: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 88437a4d\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.01s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of buses: 20.0\nNumber of small buses: 16.0\nNumber of large buses: 4.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x: number of small buses.\n- y: number of large buses.\n\nObjective Function:\n- Minimize the total number of buses: Z = x + y.\n\nConstraints:\n1. The total number of students transported must be at least 500: 20x + 50y ≥ 500.\n2. The maximum proportion of large buses (20% of the total number of buses): y ≤ 0.2(x + y).\n3. Non-negativity: x ≥ 0, y ≥ 0 and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BusHiring\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")  # Number of small buses\ny = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y\")  # Number of large buses\n\n# Set the objective function: Minimize the total number of buses\nmodel.setObjective(x + y, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(20*x + 50*y >= 500, name=\"StudentTransport\")  # At least 500 students transported\nmodel.addConstr(y <= 0.2*(x + y), name=\"LargeBusLimit\")  # Maximum 20% of the total number of buses can be large buses\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {}\".format(model.objval))\n    print(\"Number of small buses: {}\".format(x.x))\n    print(\"Number of large buses: {}\".format(y.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BusHiring\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")  # Number of small buses\ny = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y\")  # Number of large buses\n\n# Set the objective function: Minimize the total number of buses\nmodel.setObjective(x + y, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(20*x + 50*y >= 500, name=\"StudentTransport\")  # At least 500 students transported\nmodel.addConstr(y <= 0.2*(x + y), name=\"LargeBusLimit\")  # Maximum 20% of the total number of buses can be large buses\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {}\".format(model.objval))\n    print(\"Number of small buses: {}\".format(x.x))\n    print(\"Number of large buses: {}\".format(y.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 88437a4d\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.01s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of buses: 20.0\nNumber of small buses: 16.0\nNumber of large buses: 4.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of small buses to hire.\n- \\(x_2\\): Number of large buses to hire.\n\nObjective Function:\n- Minimize total number of buses: \\(Z = x_1 + x_2\\)\n\nConstraints:\n1. Transportation capacity: \\(20x_1 + 50x_2 \\geq 500\\)\n2. Maximum large buses: \\(x_2 \\leq 0.2(x_1 + x_2)\\)\n3. Non-negativity and integer: \\(x_1, x_2 \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BusHireOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"TransportCapacity\")\nmodel.addConstr(x2 <= 0.2*(x1 + x2), name=\"MaxLargeBuses\")\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {:.2f}\".format(model.objval))\n    print(\"Number of small buses to hire: {}\".format(x1.x))\n    print(\"Number of large buses to hire: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BusHireOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"TransportCapacity\")\nmodel.addConstr(x2 <= 0.2*(x1 + x2), name=\"MaxLargeBuses\")\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {:.2f}\".format(model.objval))\n    print(\"Number of small buses to hire: {}\".format(x1.x))\n    print(\"Number of large buses to hire: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 88437a4d\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.01s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of buses: 20.00\nNumber of small buses to hire: 16.0\nNumber of large buses to hire: 4.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of small buses hired.\n- \\(x_2\\): Number of large buses hired.\n\nObjective Function:\n- Minimize the total number of buses: \\(Z = x_1 + x_2\\).\n\nConstraints:\n1. Capacity constraint: \\(20x_1 + 50x_2 \\geq 500\\).\n2. Parking constraint: \\(x_2 \\leq 0.2(x_1 + x_2)\\), which simplifies to \\(x_2 \\leq 0.2x_1 + 0.2x_2\\) or \\(0.8x_2 \\leq 0.2x_1\\), which further simplifies to \\(4x_2 \\leq x_1\\).\n3. Non-negativity constraint: \\(x_1, x_2 \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of small buses\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of large buses\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Add constraints\n# Capacity constraint: 20 small buses + 50 large buses >= 500 students\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"CapacityConstraint\")\n\n# Parking constraint: 4 large buses <= small buses\nmodel.addConstr(4*x2 <= x1, name=\"ParkingConstraint\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum number of buses: {}\".format(model.objval))\n    print(\"Number of small buses: {}\".format(x1.x))\n    print(\"Number of large buses: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"SchoolFieldTrip\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of small buses\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of large buses\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Add constraints\n# Capacity constraint: 20 small buses + 50 large buses >= 500 students\nmodel.addConstr(20*x1 + 50*x2 >= 500, name=\"CapacityConstraint\")\n\n# Parking constraint: 4 large buses <= small buses\nmodel.addConstr(4*x2 <= x1, name=\"ParkingConstraint\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum number of buses: {}\".format(model.objval))\n    print(\"Number of small buses: {}\".format(x1.x))\n    print(\"Number of large buses: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 2819b7ec\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.01s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum number of buses: 20.0\nNumber of small buses: 16.0\nNumber of large buses: 4.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_s\\): The number of small buses hired.\n- \\(x_l\\): The number of large buses hired.\n\nObjective Function:\n- Minimize the total number of buses: \\(Z = x_s + x_l\\)\n\nConstraints:\n1. The number of students transported must be at least 500: \\(20x_s + 50x_l \\geq 500\\)\n2. The number of large buses cannot exceed 20% of the total number of buses: \\(x_l \\leq 0.2(x_s + x_l)\\)\n3. Non-negativity: \\(x_s, x_l \\geq 0\\) and integer\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"FieldTripBuses\")\n\n# Add decision variables\nx_s = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_s\")  # Number of small buses\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")  # Number of large buses\n\n# Add constraints\nmodel.addConstr(20*x_s + 50*x_l >= 500, name=\"StudentCapacity\")  # Students capacity constraint\nmodel.addConstr(x_l <= 0.2*(x_s + x_l), name=\"LargeBusLimit\")  # Large bus limit constraint\n\n# Set the objective function\nmodel.setObjective(x_s + x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {:.0f}\".format(model.objval))\n    print(\"Number of small buses: {:.0f}\".format(x_s.x))\n    print(\"Number of large buses: {:.0f}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"FieldTripBuses\")\n\n# Add decision variables\nx_s = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_s\")  # Number of small buses\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")  # Number of large buses\n\n# Add constraints\nmodel.addConstr(20*x_s + 50*x_l >= 500, name=\"StudentCapacity\")  # Students capacity constraint\nmodel.addConstr(x_l <= 0.2*(x_s + x_l), name=\"LargeBusLimit\")  # Large bus limit constraint\n\n# Set the objective function\nmodel.setObjective(x_s + x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of buses: {:.0f}\".format(model.objval))\n    print(\"Number of small buses: {:.0f}\".format(x_s.x))\n    print(\"Number of large buses: {:.0f}\".format(x_l.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 88437a4d\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.01s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of buses: 20\nNumber of small buses: 16\nNumber of large buses: 4",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_s\\): Number of small buses hired.\n- \\(x_l\\): Number of large buses hired.\n\nObjective Function:\n- Minimize the total number of buses: \\(Z = x_s + x_l\\)\n\nConstraints:\n1. Transportation capacity: \\(20x_s + 50x_l \\geq 500\\)\n2. Maximum large buses: \\(x_l \\leq 0.2(x_s + x_l)\\)\n3. Non-negativity and integer: \\(x_s, x_l \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"FieldTripOptimization\")\n\n# Add decision variables\nx_s = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_s\")  # Number of small buses\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")  # Number of large buses\n\n# Add constraints\nmodel.addConstr(20*x_s + 50*x_l >= 500, name=\"TransportCapacity\")  # Transportation capacity constraint\nmodel.addConstr(x_l <= 0.2*(x_s + x_l), name=\"MaxLargeBuses\")  # Maximum large buses constraint\n\n# Set the objective function\nmodel.setObjective(x_s + x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total number of buses: {model.objval}\")\n    print(f\"Number of small buses: {x_s.x}\")\n    print(f\"Number of large buses: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"FieldTripOptimization\")\n\n# Add decision variables\nx_s = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_s\")  # Number of small buses\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")  # Number of large buses\n\n# Add constraints\nmodel.addConstr(20*x_s + 50*x_l >= 500, name=\"TransportCapacity\")  # Transportation capacity constraint\nmodel.addConstr(x_l <= 0.2*(x_s + x_l), name=\"MaxLargeBuses\")  # Maximum large buses constraint\n\n# Set the objective function\nmodel.setObjective(x_s + x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total number of buses: {model.objval}\")\n    print(f\"Number of small buses: {x_s.x}\")\n    print(f\"Number of large buses: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 88437a4d\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  0.000000e+00            --     Inf  0.00s\nH        0         1      --       0  0.000000e+00  5.000000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  4.500000e+01 100.00%  0.00s\nH        0         1      --       0  0.000000e+00  2.600000e+01 100.00%  0.01s\nH        0         1      --       0  0.000000e+00  2.500000e+01 100.00%  0.01s\n         0         1      --       2  1.923077e+01  2.500000e+01  23.08%  0.01s\nH        0         1      --       2  1.923077e+01  2.000000e+01  3.846%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n         1         0     0.0       2  2.000000e+01  2.000000e+01  0.000%  0.01s\n\nBest solution   : 20.000000000\nBest bound      : 20.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of buses: 20.0\nNumber of small buses: 16.0\nNumber of large buses: 4.0",
        "pass": true
      }
    ],
    "answer": 317.5,
    "cloze": "Gabriel is growing pumpkins and carrots on his farm. He has ____ acres available on which he must grow ____ ____ acres of pumpkins and ____ ____ acres of carrots to meet demands. The profit per pumpkin is $____ and the profit per carrot is $____. He prefers to grow more carrots than pumpkins but limitations in his workforce allow him to grow ____ ____ ____ the amount of carrots as pumpkins. How many of each produce should Gabriel grow in order to ____ his profit?"
  },
  {
    "question": "In a financial portfolio management scenario, an investment manager needs to allocate funds across four different assets: $X1, X2, X3$, and $X4$. These could represent investments in various financial instruments such as bonds, stocks, mutual funds or derivatives. The total investment across all four assets cannot exceed \\$100000 due to budget constraints. Asset $X1$ requires a minimum investment of \\$10000 and a maximum of \\$60000, while asset $X2$ has an allowable range from \\$20000 to \\$80000. Asset $X3$ requires an investment ranging between \\$15000 and \\$50000. For asset $X4$, the minimum investment is \\$200 with no upper limit.\\n\\nThe manager also needs to ensure that the following conditions are met:\\n- The difference between 60% of the investment in asset X1 and 40% of the investment in asset X2 must be non-negative.\\n- The sum of investments in assets X3 and X4 should not be less than the combined investments in assets X1 and X2 by more than \\$30000.\\n- The difference between 70% of the investment in asset X3 and 50% of the investment in asset X4 should not exceed \\$500.\\n\\nEach unit invested in assets $X1, X2, X3$, and $X4$ incurs costs at rates of 0.05 , 0.08 , 0.12 , and 0.15 respectively. Given these conditions, calculate the minimum total cost for managing this portfolio (round your answer to two decimal places), given that all investments are integer multiples of one dollar.",
    "pass_count": 8,
    "pass_rate": 1.0,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): The number of acres of pumpkins grown.\n- \\(x_2\\): The number of acres of carrots grown.\n\nObjective Function:\nMaximize profit:  \n\\(Z = 2.5x_1 + 3.4x_2\\)\n\nConstraints:\n1. Land availability: \\(x_1 + x_2 \\leq 100\\)\n2. Minimum pumpkin requirement: \\(x_1 \\geq 7\\)\n3. Minimum carrot requirement: \\(x_2 \\geq 12\\)\n4. Carrot-to-pumpkin ratio limitation: \\(x_2 \\leq 3x_1\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\) and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarmOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of acres of pumpkins grown\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of acres of carrots grown\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"LandAvailability\")  # Land availability constraint\nmodel.addConstr(x1 >= 7, name=\"PumpkinMinimum\")  # Minimum pumpkin requirement constraint\nmodel.addConstr(x2 >= 12, name=\"CarrotMinimum\")  # Minimum carrot requirement constraint\nmodel.addConstr(x2 <= 3 * x1, name=\"CarrotPumpkinRatio\")  # Carrot-to-pumpkin ratio constraint\n\n# Set the objective function to maximize profit\nmodel.setObjective(2.5 * x1 + 3.4 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total profit: ${}\".format(model.objval))\n    print(\"Optimal number of acres for pumpkins: {}\".format(x1.x))\n    print(\"Optimal number of acres for carrots: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarmOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of acres of pumpkins grown\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of acres of carrots grown\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"LandAvailability\")  # Land availability constraint\nmodel.addConstr(x1 >= 7, name=\"PumpkinMinimum\")  # Minimum pumpkin requirement constraint\nmodel.addConstr(x2 >= 12, name=\"CarrotMinimum\")  # Minimum carrot requirement constraint\nmodel.addConstr(x2 <= 3 * x1, name=\"CarrotPumpkinRatio\")  # Carrot-to-pumpkin ratio constraint\n\n# Set the objective function to maximize profit\nmodel.setObjective(2.5 * x1 + 3.4 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total profit: ${}\".format(model.objval))\n    print(\"Optimal number of acres for pumpkins: {}\".format(x1.x))\n    print(\"Optimal number of acres for carrots: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 28edbc8a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 317.500000000\nBest bound      : 317.500000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized total profit: $317.5\nOptimal number of acres for pumpkins: 25.0\nOptimal number of acres for carrots: 75.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of acres of pumpkins grown.\n- \\(x_2\\): Number of acres of carrots grown.\n\nObjective Function:\nMaximize total profit: \\(Z = 2.5x_1 + 3.4x_2\\)\n\nConstraints:\n1. Total land available: \\(x_1 + x_2 \\leq 100\\)\n2. Minimum land for pumpkins: \\(x_1 \\geq 7\\)\n3. Minimum land for carrots: \\(x_2 \\geq 12\\)\n4. Maximum ratio of land for carrots to pumpkins: \\(x_2 \\leq 3x_1\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarming\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Acres of pumpkins grown\nx2 = model.addVar(lb=0, name=\"x2\")  # Acres of carrots grown\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"LandLimit\")  # Total land available\nmodel.addConstr(x1 >= 7, name=\"MinPumpkinLand\")  # Minimum land for pumpkins\nmodel.addConstr(x2 >= 12, name=\"MinCarrotLand\")  # Minimum land for carrots\nmodel.addConstr(x2 <= 3 * x1, name=\"CarrotPumpkinRatio\")  # Maximum ratio of land for carrots to pumpkins\n\n# Set the objective function\nmodel.setObjective(2.5 * x1 + 3.4 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total profit: ${}\".format(model.objval))\n    print(\"Number of acres of pumpkins grown: {}\".format(x1.x))\n    print(\"Number of acres of carrots grown: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarming\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Acres of pumpkins grown\nx2 = model.addVar(lb=0, name=\"x2\")  # Acres of carrots grown\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"LandLimit\")  # Total land available\nmodel.addConstr(x1 >= 7, name=\"MinPumpkinLand\")  # Minimum land for pumpkins\nmodel.addConstr(x2 >= 12, name=\"MinCarrotLand\")  # Minimum land for carrots\nmodel.addConstr(x2 <= 3 * x1, name=\"CarrotPumpkinRatio\")  # Maximum ratio of land for carrots to pumpkins\n\n# Set the objective function\nmodel.setObjective(2.5 * x1 + 3.4 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total profit: ${}\".format(model.objval))\n    print(\"Number of acres of pumpkins grown: {}\".format(x1.x))\n    print(\"Number of acres of carrots grown: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 4afcaab\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\nThe presolved problem is empty\n\nPostsolving\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    3.1750000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 3.1750000000e+02  Iterations: 0  Time: 0.00s\nMaximized total profit: $317.5\nNumber of acres of pumpkins grown: 25.0\nNumber of acres of carrots grown: 75.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x: Acres of pumpkins.\n- y: Acres of carrots.\n\nObjective Function:\nMaximize profit Z = 2.5x + 3.4y\n\nConstraints:\n1. Total land: x + y ≤ 100\n2. Minimum pumpkin: x ≥ 7\n3. Minimum carrot: y ≥ 12\n4. Carrot-pumpkin ratio: y ≤ 3x\n5. Non-negativity: x ≥ 0, y ≥ 0\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarming\")\n\n# Add decision variables\nx = model.addVar(lb=0, name=\"x\")  # Acres of pumpkins\ny = model.addVar(lb=0, name=\"y\")  # Acres of carrots\n\n# Add constraints\nmodel.addConstr(x + y <= 100, name=\"TotalLand\")  # Total land constraint\nmodel.addConstr(x >= 7, name=\"MinPumpkins\")     # Minimum pumpkin constraint\nmodel.addConstr(y >= 12, name=\"MinCarrots\")     # Minimum carrot constraint\nmodel.addConstr(y <= 3*x, name=\"CarrotPumpkinRatio\")  # Carrot-pumpkin ratio constraint\n\n# Set the objective function\nmodel.setObjective(2.5*x + 3.4*y, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized profit: ${model.objval}\")\n    print(f\"Acres of pumpkins to grow: {x.x}\")\n    print(f\"Acres of carrots to grow: {y.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarming\")\n\n# Add decision variables\nx = model.addVar(lb=0, name=\"x\")  # Acres of pumpkins\ny = model.addVar(lb=0, name=\"y\")  # Acres of carrots\n\n# Add constraints\nmodel.addConstr(x + y <= 100, name=\"TotalLand\")  # Total land constraint\nmodel.addConstr(x >= 7, name=\"MinPumpkins\")     # Minimum pumpkin constraint\nmodel.addConstr(y >= 12, name=\"MinCarrots\")     # Minimum carrot constraint\nmodel.addConstr(y <= 3*x, name=\"CarrotPumpkinRatio\")  # Carrot-pumpkin ratio constraint\n\n# Set the objective function\nmodel.setObjective(2.5*x + 3.4*y, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized profit: ${model.objval}\")\n    print(f\"Acres of pumpkins to grow: {x.x}\")\n    print(f\"Acres of carrots to grow: {y.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 4afcaab\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\nThe presolved problem is empty\n\nPostsolving\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    3.1750000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 3.1750000000e+02  Iterations: 0  Time: 0.00s\nMaximized profit: $317.5\nAcres of pumpkins to grow: 25.0\nAcres of carrots to grow: 75.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_{p}\\): The number of acres of pumpkins grown.  \n- \\(x_{c}\\): The number of acres of carrots grown.  \n\nObjective Function:  \n- Maximize profit: \\(Z = 2.5x_{p} + 3.4x_{c}\\)  \n\nConstraints:  \n1. Total land: \\(x_{p} + x_{c} \\leq 100\\)  \n2. Minimum pumpkin: \\(x_{p} \\geq 7\\)  \n3. Minimum carrot: \\(x_{c} \\geq 12\\)  \n4. Carrot-to-pumpkin ratio: \\(x_{c} \\leq 3x_{p}\\)  \n5. Non-negativity: \\(x_{p}, x_{c} \\geq 0\\) and integers.  \n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarm\")\n\n# Add decision variables\nx_p = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_p\")  # Acres of pumpkins\nx_c = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_c\")  # Acres of carrots\n\n# Objective function: Maximize profit\nmodel.setObjective(2.5*x_p + 3.4*x_c, sense=COPT.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_p + x_c <= 100, name=\"LandConstraint\")  # Total land constraint\nmodel.addConstr(x_p >= 7, name=\"MinPumpkinConstraint\")  # Minimum pumpkin requirement\nmodel.addConstr(x_c >= 12, name=\"MinCarrotConstraint\")  # Minimum carrot requirement\nmodel.addConstr(x_c <= 3*x_p, name=\"CarrotPumpkinRatioConstraint\")  # Carrot-to-pumpkin ratio constraint\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized profit: ${model.objval}\")\n    print(f\"Optimal solution: Grow {x_p.x} acres of pumpkins and {x_c.x} acres of carrots.\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarm\")\n\n# Add decision variables\nx_p = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_p\")  # Acres of pumpkins\nx_c = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_c\")  # Acres of carrots\n\n# Objective function: Maximize profit\nmodel.setObjective(2.5*x_p + 3.4*x_c, sense=COPT.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_p + x_c <= 100, name=\"LandConstraint\")  # Total land constraint\nmodel.addConstr(x_p >= 7, name=\"MinPumpkinConstraint\")  # Minimum pumpkin requirement\nmodel.addConstr(x_c >= 12, name=\"MinCarrotConstraint\")  # Minimum carrot requirement\nmodel.addConstr(x_c <= 3*x_p, name=\"CarrotPumpkinRatioConstraint\")  # Carrot-to-pumpkin ratio constraint\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized profit: ${model.objval}\")\n    print(f\"Optimal solution: Grow {x_p.x} acres of pumpkins and {x_c.x} acres of carrots.\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 28edbc8a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 317.500000000\nBest bound      : 317.500000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized profit: $317.5\nOptimal solution: Grow 25.0 acres of pumpkins and 75.0 acres of carrots.",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): The number of acres of pumpkins Gabriel grows.\n- \\(x_2\\): The number of acres of carrots Gabriel grows.\n\nObjective Function:\n- Maximize profit: \\(Z = 2.5x_1 + 3.4x_2\\)\n\nConstraints:\n1. Total available acres: \\(x_1 + x_2 \\leq 100\\)\n2. Minimum acres of pumpkins: \\(x_1 \\geq 7\\)\n3. Minimum acres of carrots: \\(x_2 \\geq 12\\)\n4. Carrots cannot exceed three times pumpkins: \\(x_2 \\leq 3x_1\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n\nInteger Requirement: The variables are integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarmOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"TotalAvailableAcres\")\nmodel.addConstr(x1 >= 7, name=\"MinimumPumpkins\")\nmodel.addConstr(x2 >= 12, name=\"MinimumCarrots\")\nmodel.addConstr(x2 <= 3 * x1, name=\"CarrotsLimit\")\n\n# Set the objective function\nmodel.setObjective(2.5 * x1 + 3.4 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(round(model.objval)))\n    print(\"Optimal number of acres to grow pumpkins: {}\".format(x1.x))\n    print(\"Optimal number of acres to grow carrots: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarmOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"TotalAvailableAcres\")\nmodel.addConstr(x1 >= 7, name=\"MinimumPumpkins\")\nmodel.addConstr(x2 >= 12, name=\"MinimumCarrots\")\nmodel.addConstr(x2 <= 3 * x1, name=\"CarrotsLimit\")\n\n# Set the objective function\nmodel.setObjective(2.5 * x1 + 3.4 * x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(round(model.objval)))\n    print(\"Optimal number of acres to grow pumpkins: {}\".format(x1.x))\n    print(\"Optimal number of acres to grow carrots: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 28edbc8a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 317.500000000\nBest bound      : 317.500000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized profit: $318\nOptimal number of acres to grow pumpkins: 25.0\nOptimal number of acres to grow carrots: 75.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): the number of acres used to grow pumpkins.\n- \\(x_2\\): the number of acres used to grow carrots.\n\nObjective Function:\nMaximize total profit:  \n\\(Z = 2.5x_1 + 3.4x_2\\)\n\nConstraints:\n1. Total land area constraint:  \n   \\(x_1 + x_2 \\leq 100\\)\n2. Minimum pumpkin acreage constraint:  \n   \\(x_1 \\geq 7\\)\n3. Minimum carrot acreage constraint:  \n   \\(x_2 \\geq 12\\)\n4. Workforce limitation constraint:  \n   \\(x_2 \\leq 3x_1\\)\n5. Non-negativity and integer constraints:  \n   \\(x_1, x_2 \\geq 0\\) and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarmOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Acres used to grow pumpkins\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Acres used to grow carrots\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"LandLimit\")  # Total land area constraint\nmodel.addConstr(x1 >= 7, name=\"MinPumpkin\")        # Minimum pumpkin acreage constraint\nmodel.addConstr(x2 >= 12, name=\"MinCarrot\")        # Minimum carrot acreage constraint\nmodel.addConstr(x2 <= 3*x1, name=\"WorkforceLimit\") # Workforce limitation constraint\n\n# Set the objective function\nmodel.setObjective(2.5*x1 + 3.4*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized profit: ${model.objval:.2f}\")\n    print(f\"Optimal solution: Grow {x1.x} acres of pumpkins and {x2.x} acres of carrots.\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielFarmOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Acres used to grow pumpkins\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Acres used to grow carrots\n\n# Add constraints\nmodel.addConstr(x1 + x2 <= 100, name=\"LandLimit\")  # Total land area constraint\nmodel.addConstr(x1 >= 7, name=\"MinPumpkin\")        # Minimum pumpkin acreage constraint\nmodel.addConstr(x2 >= 12, name=\"MinCarrot\")        # Minimum carrot acreage constraint\nmodel.addConstr(x2 <= 3*x1, name=\"WorkforceLimit\") # Workforce limitation constraint\n\n# Set the objective function\nmodel.setObjective(2.5*x1 + 3.4*x2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized profit: ${model.objval:.2f}\")\n    print(f\"Optimal solution: Grow {x1.x} acres of pumpkins and {x2.x} acres of carrots.\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 28edbc8a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 317.500000000\nBest bound      : 317.500000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized profit: $317.50\nOptimal solution: Grow 25.0 acres of pumpkins and 75.0 acres of carrots.",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_p\\): The number of acres allocated to growing pumpkins.\n- \\(x_c\\): The number of acres allocated to growing carrots.\n\nObjective Function:\n- Maximize profit: \\(Z = 2.5x_p + 3.4x_c\\)\n\nConstraints:\n1. Total land availability: \\(x_p + x_c \\leq 100\\)\n2. Minimum pumpkin requirement: \\(x_p \\geq 7\\)\n3. Minimum carrot requirement: \\(x_c \\geq 12\\)\n4. Workforce limitation: \\(x_c \\leq 3x_p\\)\n5. Non-negativity: \\(x_p, x_c \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"GabrielFarming\")\n\n# Add decision variables\nx_p = model.addVar(lb=0, name=\"x_p\")  # Acres allocated to growing pumpkins\nx_c = model.addVar(lb=0, name=\"x_c\")  # Acres allocated to growing carrots\n\n# Add constraints\nmodel.addConstr(x_p + x_c <= 100, name=\"TotalLand\")  # Total land availability\nmodel.addConstr(x_p >= 7, name=\"MinPumpkins\")  # Minimum pumpkin requirement\nmodel.addConstr(x_c >= 12, name=\"MinCarrots\")  # Minimum carrot requirement\nmodel.addConstr(x_c <= 3*x_p, name=\"WorkforceLimit\")  # Workforce limitation\n\n# Set the objective function\nmodel.setObjective(2.5*x_p + 3.4*x_c, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Optimal solution: Grow {} acres of pumpkins and {} acres of carrots\".format(x_p.x, x_c.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"GabrielFarming\")\n\n# Add decision variables\nx_p = model.addVar(lb=0, name=\"x_p\")  # Acres allocated to growing pumpkins\nx_c = model.addVar(lb=0, name=\"x_c\")  # Acres allocated to growing carrots\n\n# Add constraints\nmodel.addConstr(x_p + x_c <= 100, name=\"TotalLand\")  # Total land availability\nmodel.addConstr(x_p >= 7, name=\"MinPumpkins\")  # Minimum pumpkin requirement\nmodel.addConstr(x_c >= 12, name=\"MinCarrots\")  # Minimum carrot requirement\nmodel.addConstr(x_c <= 3*x_p, name=\"WorkforceLimit\")  # Workforce limitation\n\n# Set the objective function\nmodel.setObjective(2.5*x_p + 3.4*x_c, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized profit: ${}\".format(model.objval))\n    print(\"Optimal solution: Grow {} acres of pumpkins and {} acres of carrots\".format(x_p.x, x_c.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 4afcaab\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\nThe presolved problem is empty\n\nPostsolving\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    3.1750000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 3.1750000000e+02  Iterations: 0  Time: 0.00s\nMaximized profit: $317.5\nOptimal solution: Grow 25.0 acres of pumpkins and 75.0 acres of carrots",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_{\\text{pumpkins}}\\): The number of acres allocated to grow pumpkins.\n- \\(x_{\\text{carrots}}\\): The number of acres allocated to grow carrots.\n\nObjective Function:\n- Maximize total profit: \\(Z = 2.5 \\times x_{\\text{pumpkins}} + 3.4 \\times x_{\\text{carrots}}\\)\n\nConstraints:\n1. Total land availability: \\(x_{\\text{pumpkins}} + x_{\\text{carrots}} \\leq 100\\)\n2. Minimum acres for pumpkins: \\(x_{\\text{pumpkins}} \\geq 7\\)\n3. Minimum acres for carrots: \\(x_{\\text{carrots}} \\geq 12\\)\n4. Limitation in workforce: \\(x_{\\text{carrots}} \\leq 3 \\times x_{\\text{pumpkins}}\\)\n5. Non-negativity: \\(x_{\\text{pumpkins}}, x_{\\text{carrots}} \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielPumpkinCarrot\")\n\n# Add decision variables\nx_pumpkins = model.addVar(lb=0, name=\"x_pumpkins\")  # Acres allocated to grow pumpkins\nx_carrots = model.addVar(lb=0, name=\"x_carrots\")    # Acres allocated to grow carrots\n\n# Add constraints\nmodel.addConstr(x_pumpkins + x_carrots <= 100, name=\"TotalLand\")  # Total land availability\nmodel.addConstr(x_pumpkins >= 7, name=\"MinPumpkins\")              # Minimum acres for pumpkins\nmodel.addConstr(x_carrots >= 12, name=\"MinCarrots\")               # Minimum acres for carrots\nmodel.addConstr(x_carrots <= 3 * x_pumpkins, name=\"WorkforceLimit\")  # Limitation in workforce\n\n# Set the objective function\nmodel.setObjective(2.5 * x_pumpkins + 3.4 * x_carrots, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized total profit: ${model.objval:.2f}\")\n    print(f\"Optimal planting plan:\")\n    print(f\"Number of acres for pumpkins: {x_pumpkins.x}\")\n    print(f\"Number of acres for carrots: {x_carrots.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"GabrielPumpkinCarrot\")\n\n# Add decision variables\nx_pumpkins = model.addVar(lb=0, name=\"x_pumpkins\")  # Acres allocated to grow pumpkins\nx_carrots = model.addVar(lb=0, name=\"x_carrots\")    # Acres allocated to grow carrots\n\n# Add constraints\nmodel.addConstr(x_pumpkins + x_carrots <= 100, name=\"TotalLand\")  # Total land availability\nmodel.addConstr(x_pumpkins >= 7, name=\"MinPumpkins\")              # Minimum acres for pumpkins\nmodel.addConstr(x_carrots >= 12, name=\"MinCarrots\")               # Minimum acres for carrots\nmodel.addConstr(x_carrots <= 3 * x_pumpkins, name=\"WorkforceLimit\")  # Limitation in workforce\n\n# Set the objective function\nmodel.setObjective(2.5 * x_pumpkins + 3.4 * x_carrots, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized total profit: ${model.objval:.2f}\")\n    print(f\"Optimal planting plan:\")\n    print(f\"Number of acres for pumpkins: {x_pumpkins.x}\")\n    print(f\"Number of acres for carrots: {x_carrots.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 4afcaab\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\nThe presolved problem is empty\n\nPostsolving\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    3.1750000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 3.1750000000e+02  Iterations: 0  Time: 0.00s\nMaximized total profit: $317.50\nOptimal planting plan:\nNumber of acres for pumpkins: 25.0\nNumber of acres for carrots: 75.0",
        "pass": true
      }
    ],
    "answer": 7066.7,
    "cloze": "In a financial portfolio management scenario, an investment manager needs to allocate funds across four different assets: $X1, X2, X3$, and $X4$. These could represent investments in various financial instruments such as bonds, stocks, mutual funds or derivatives. The total investment across all four assets ____ ____ $____ due to budget constraints. Asset $X1$ requires ____ ____ of $____ and ____ ____ of $____, while asset $X2$ has an allowable range from $____ to $____. Asset $X3$ requires an investment ranging between $____ and $____. For asset $X4$, ____ ____ is $____ with ____ ____ ____.\n\nThe manager also needs to ensure that the following conditions are met:\n- The difference between ____ of the investment in asset X1 and ____ of the investment in asset X2 must be ____.\n- The sum of investments in assets X3 and X4 should ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____.\n- The difference between ____ of the investment in asset X3 and ____ of the investment in asset X4 should ____ ____ $____.\n\nEach unit invested in assets $X1, X2, X3$, and $X4$ incurs costs at rates of ____ , ____ , ____ , and ____ respectively. Given these conditions, calculate the ____ total cost for managing this portfolio (round your answer to two decimal places), given that all investments are integer multiples of one dollar."
  },
  {
    "question": "Star Oil Company is considering five different investment opportunities. The cash outflows and net present values (NPVs) (in millions of dollars) for each opportunity are given in Table 7. Specifically, Investment 1 has a time 0 cash outflow of $11 million and a time 1 cash outflow of $3 million, with an NPV of $13 million. Investment 2 requires a time 0 outflow of $53 million and a time 1 outflow of $6 million, yielding an NPV of $16 million. Investment 3 has smaller outflows of $5 million at both time 0 and time 1 and also an NPV of $16 million. Investment 4 asks for a time 0 outflow of $5 million and a minimal $1 million at time 1, with an NPV of $14 million. Lastly, Investment 5 requires a $29 million outflow at time 0 and a significant $34 million at time 1, resulting in the highest NPV of $39 million. Star Oil has $40 million available for investment at time 0, and it estimates that $20 million will be available for investment at time 1. Star Oil may purchase any fraction of each investment, in which case, the cash outflows and NPV are adjusted proportionally. For example, if Star Oil purchases one-fifth of investment 3, then a cash outflow of (1/5)*5=1 million dollars or $1 million would be required at time 0, and a cash outflow of (1/5)*5=1 million dollars or $1 million would be required at time 1. The one-fifth share of investment 3 would yield an NPV of (1/5)*16=3.2 million dollars or $3.2 million. Star Oil wants to maximize the NPV that can be obtained by investing in investments 1-5. The goal is to formulate an LP that will help achieve this objective. Assume that any funds left over at time 0 cannot be used at time 1. Find the maximum NPV in million dollars.",
    "pass_count": 4,
    "pass_rate": 0.5,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_m\\): Number of mango bubble teas made.\n- \\(x_l\\): Number of lychee bubble teas made.\n\nObjective Function:\n- Minimize total amount of tea needed: \\(Z = 8x_m + 6x_l\\)\n\nConstraints:\n1. Mango juice requirement: \\(4x_m \\leq 2000\\)\n2. Lychee juice requirement: \\(6x_l \\leq 3000\\)\n3. Minimum proportion of lychee bubble teas: \\(x_l \\geq 0.4(x_m + x_l)\\)\n4. Mango bubble teas must be greater than lychee bubble teas: \\(x_m \\geq x_l\\)\n5. Non-negativity: \\(x_m, x_l \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, name=\"x_m\")  # Number of mango bubble teas made\nx_l = model.addVar(lb=0, name=\"x_l\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuiceRequirement\")\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuiceRequirement\")\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"MinimumProportionLychee\")\nmodel.addConstr(x_m >= x_l, name=\"MangoBubbleTeasGreater\")\n\n# Set the objective function to minimize total tea needed\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimized total amount of tea needed: {:.2f}\".format(model.objval))\n    print(f\"Number of mango bubble teas made: {x_m.x}\")\n    print(f\"Number of lychee bubble teas made: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, name=\"x_m\")  # Number of mango bubble teas made\nx_l = model.addVar(lb=0, name=\"x_l\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuiceRequirement\")\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuiceRequirement\")\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"MinimumProportionLychee\")\nmodel.addConstr(x_m >= x_l, name=\"MangoBubbleTeasGreater\")\n\n# Set the objective function to minimize total tea needed\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimized total amount of tea needed: {:.2f}\".format(model.objval))\n    print(f\"Number of mango bubble teas made: {x_m.x}\")\n    print(f\"Number of lychee bubble teas made: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 4a627289\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\nThe presolved problem is empty\n\nPostsolving\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    0.0000000000e+00            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 0.0000000000e+00  Iterations: 0  Time: 0.00s\nMinimized total amount of tea needed: 0.00\nNumber of mango bubble teas made: 0.0\nNumber of lychee bubble teas made: 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: Number of mango bubble teas made.\n- x2: Number of lychee bubble teas made.\n\nObjective Function:\n- Minimize total tea needed: Z = 8x1 + 6x2\n\nConstraints:\n1. Mango juice availability: 4x1 ≤ 2000\n2. Lychee juice availability: 6x2 ≤ 3000\n3. At least 40% of bubble teas must be lychee flavored: x2 ≥ 0.4(x1 + x2)\n4. Mango bubble teas must be more than lychee bubble teas: x1 ≥ x2\n5. Non-negativity: x1, x2 ≥ 0 and integer\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_1\\): The number of mango bubble teas made.  \n- \\(x_2\\): The number of lychee bubble teas made.  \n\nObjective Function:  \n- Minimize the total amount of tea needed:  \n  \\[Z = 8x_1 + 6x_2\\]  \n\nConstraints:  \n1. Mango juice availability:  \n   \\[4x_1 \\leq 2000\\]  \n2. Lychee juice availability:  \n   \\[6x_2 \\leq 3000\\]  \n3. At least 40% of the bubble teas must be lychee flavored:  \n   \\[x_2 \\geq 0.4(x_1 + x_2)\\]  \n4. Mango bubble teas must be more than lychee bubble teas:  \n   \\[x_1 > x_2\\]  \n5. Non-negativity and integer constraints:  \n   \\[x_1, x_2 \\geq 0\\text{ and integers}\\]  \n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Define decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of mango bubble teas\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of lychee bubble teas\n\n# Set the objective function\nmodel.setObjective(8*x1 + 6*x2, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(4*x1 <= 2000, name=\"MangoJuiceAvailability\")  # Mango juice availability constraint\nmodel.addConstr(6*x2 <= 3000, name=\"LycheeJuiceAvailability\")  # Lychee juice availability constraint\nmodel.addConstr(x2 >= 0.4*(x1 + x2), name=\"LycheeFlavorRequirement\")  # At least 40% must be lychee flavored\nmodel.addConstr(x1 > x2, name=\"MangoFlavorPreference\")  # Mango bubble teas must be more than lychee bubble teas\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total amount of tea needed: {model.objval}\")\n    print(f\"Number of mango bubble teas made: {x1.x}\")\n    print(f\"Number of lychee bubble teas made: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Define decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of mango bubble teas\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of lychee bubble teas\n\n# Set the objective function\nmodel.setObjective(8*x1 + 6*x2, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(4*x1 <= 2000, name=\"MangoJuiceAvailability\")  # Mango juice availability constraint\nmodel.addConstr(6*x2 <= 3000, name=\"LycheeJuiceAvailability\")  # Lychee juice availability constraint\nmodel.addConstr(x2 >= 0.4*(x1 + x2), name=\"LycheeFlavorRequirement\")  # At least 40% must be lychee flavored\nmodel.addConstr(x1 > x2, name=\"MangoFlavorPreference\")  # Mango bubble teas must be more than lychee bubble teas\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total amount of tea needed: {model.objval}\")\n    print(f\"Number of mango bubble teas made: {x1.x}\")\n    print(f\"Number of lychee bubble teas made: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Error: '>' not supported between instances of 'Var' and 'Var'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_m\\): the number of mango bubble teas made.\n- \\(x_l\\): the number of lychee bubble teas made.\n\nObjective Function:\n- Minimize the total amount of tea needed: \\(Z = 8x_m + 6x_l\\)\n\nConstraints:\n1. Availability of mango juice: \\(4x_m \\leq 2000\\)\n2. Availability of lychee juice: \\(6x_l \\leq 3000\\)\n3. At least 40% of the bubble teas must be lychee flavored: \\(x_l \\geq 0.4(x_m + x_l)\\)\n4. Mango bubble tea must be more than the number of lychee bubble teas made: \\(x_m > x_l\\)\n5. Non-negativity: \\(x_m, x_l \\geq 0\\)\n6. Integer: \\(x_m, x_l\\) must be integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")  # Number of mango bubble teas\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")  # Number of lychee bubble teas\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuice\")  # Availability of mango juice\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuice\")  # Availability of lychee juice\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"LycheeRatio\")  # At least 40% of bubble teas must be lychee flavored\nmodel.addConstr(x_m > x_l, name=\"MangoMore\")  # Mango bubble tea must be more than the number of lychee bubble teas made\n\n# Set the objective function\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(f\"Number of mango bubble teas made: {x_m.x}\")\n    print(f\"Number of lychee bubble teas made: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")  # Number of mango bubble teas\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")  # Number of lychee bubble teas\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuice\")  # Availability of mango juice\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuice\")  # Availability of lychee juice\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"LycheeRatio\")  # At least 40% of bubble teas must be lychee flavored\nmodel.addConstr(x_m > x_l, name=\"MangoMore\")  # Mango bubble tea must be more than the number of lychee bubble teas made\n\n# Set the objective function\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(f\"Number of mango bubble teas made: {x_m.x}\")\n    print(f\"Number of lychee bubble teas made: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Error: '>' not supported between instances of 'Var' and 'Var'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_m\\): Number of mango bubble teas made.\n- \\(x_l\\): Number of lychee bubble teas made.\n\nObjective Function:\n- Minimize the total amount of tea needed: \\(Z = 8x_m + 6x_l\\)\n\nConstraints:\n1. Mango juice requirement: \\(4x_m \\leq 2000\\)\n2. Lychee juice requirement: \\(6x_l \\leq 3000\\)\n3. At least 40% of the bubble teas made must be lychee flavored: \\(x_l \\geq 0.4(x_m + x_l)\\)\n4. The number of mango bubble teas made must be larger than the number of lychee bubble teas made: \\(x_m \\geq x_l + 1\\)\n5. Non-negativity: \\(x_m, x_l \\geq 0\\)\n6. Integer: \\(x_m, x_l\\) must be integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShopOptimization\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuiceConstraint\")\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuiceConstraint\")\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"LycheeFlavorConstraint\")\nmodel.addConstr(x_m >= x_l + 1, name=\"MangoFlavorConstraint\")\n\n# Set the objective function\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimized total tea needed: {:.2f}\".format(model.objval))\n    print(f\"Number of mango bubble teas made: {x_m.x}\")\n    print(f\"Number of lychee bubble teas made: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaShopOptimization\")\n\n# Add decision variables\nx_m = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_m\")\nx_l = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x_l\")\n\n# Add constraints\nmodel.addConstr(4 * x_m <= 2000, name=\"MangoJuiceConstraint\")\nmodel.addConstr(6 * x_l <= 3000, name=\"LycheeJuiceConstraint\")\nmodel.addConstr(x_l >= 0.4 * (x_m + x_l), name=\"LycheeFlavorConstraint\")\nmodel.addConstr(x_m >= x_l + 1, name=\"MangoFlavorConstraint\")\n\n# Set the objective function\nmodel.setObjective(8 * x_m + 6 * x_l, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimized total tea needed: {:.2f}\".format(model.objval))\n    print(f\"Number of mango bubble teas made: {x_m.x}\")\n    print(f\"Number of lychee bubble teas made: {x_l.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: afeef2b8\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 36.000000000\nBest bound      : 36.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :  2.22045e-16  2.22045e-16\n  integrality   :            0\nMinimized total tea needed: 36.00\nNumber of mango bubble teas made: 3.0\nNumber of lychee bubble teas made: 2.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): The number of mango bubble teas made.\n- \\(x_2\\): The number of lychee bubble teas made.\n\nObjective Function:\n- Minimize total tea usage: \\(Z = 8x_1 + 6x_2\\)\n\nConstraints:\n1. Mango juice availability: \\(4x_1 \\leq 2000\\)\n2. Lychee juice availability: \\(6x_2 \\leq 3000\\)\n3. At least 40% of the bubble teas must be lychee flavored: \\(x_2 \\geq 0.4(x_1 + x_2)\\)\n4. Mango bubble tea sales must be larger than lychee bubble tea sales: \\(x_1 > x_2\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\), and integer.\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of mango bubble teas to be made.\n- \\(x_2\\): Number of lychee bubble teas to be made.\n\nObjective Function:\n- Minimize the total amount of tea needed: \\(Z = 8x_1 + 6x_2\\).\n\nConstraints:\n1. Mango juice availability: \\(4x_1 \\leq 2000\\).\n2. Lychee juice availability: \\(6x_2 \\leq 3000\\).\n3. At least 40% of the bubble teas made must be lychee flavored: \\(x_2 \\geq 0.4(x_1 + x_2)\\).\n4. Mango bubble tea sells better and thus the number of mango bubble teas made must be large than the number of lychee bubble teas made: \\(x_1 \\geq x_2\\).\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\), and \\(x_1, x_2\\) must be integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(4*x1 <= 2000, name=\"MangoJuiceConstraint\")\nmodel.addConstr(6*x2 <= 3000, name=\"LycheeJuiceConstraint\")\nmodel.addConstr(x2 >= 0.4*(x1 + x2), name=\"LycheeFlavorConstraint\")\nmodel.addConstr(x1 >= x2, name=\"MangoFlavorConstraint\")\n\n# Set the objective function\nmodel.setObjective(8*x1 + 6*x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(\"Number of mango bubble teas to be made: {}\".format(x1.x))\n    print(\"Number of lychee bubble teas to be made: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"BubbleTeaOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(4*x1 <= 2000, name=\"MangoJuiceConstraint\")\nmodel.addConstr(6*x2 <= 3000, name=\"LycheeJuiceConstraint\")\nmodel.addConstr(x2 >= 0.4*(x1 + x2), name=\"LycheeFlavorConstraint\")\nmodel.addConstr(x1 >= x2, name=\"MangoFlavorConstraint\")\n\n# Set the objective function\nmodel.setObjective(8*x1 + 6*x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(\"Number of mango bubble teas to be made: {}\".format(x1.x))\n    print(\"Number of lychee bubble teas to be made: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 14ac7f83\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 0.000000000\nBest bound      : 0.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total amount of tea needed: 0.00\nNumber of mango bubble teas to be made: 0.0\nNumber of lychee bubble teas to be made: 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): The number of mango bubble teas made.\n- \\(x_2\\): The number of lychee bubble teas made.\n\nObjective Function:\n- Minimize the total amount of tea needed: \\(Z = 8x_1 + 6x_2\\)\n\nConstraints:\n1. Mango juice availability: \\(4x_1 \\leq 2000\\)\n2. Lychee juice availability: \\(6x_2 \\leq 3000\\)\n3. At least 40% of the bubble teas made must be lychee flavored: \\(x_2 \\geq 0.4(x_1 + x_2)\\)\n4. Mango bubble tea sells better and thus the number of mango bubble teas made must be large than the number of lychee bubble teas made: \\(x_1 \\geq x_2\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of mango bubble teas made\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4*x1 <= 2000, name=\"MangoJuiceAvailability\")  # Mango juice availability\nmodel.addConstr(6*x2 <= 3000, name=\"LycheeJuiceAvailability\")  # Lychee juice availability\nmodel.addConstr(x2 >= 0.4*(x1 + x2), name=\"LycheeFlavorRequirement\")  # At least 40% of the bubble teas made must be lychee flavored\nmodel.addConstr(x1 >= x2, name=\"MangoTeaSalesRequirement\")  # Mango bubble tea sells better and thus the number of mango bubble teas made must be large than the number of lychee bubble teas made\n\n# Set the objective function\nmodel.setObjective(8*x1 + 6*x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {:.0f}\".format(x1.x))\n    print(\"Number of lychee bubble teas made: {:.0f}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"BubbleTeaShop\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of mango bubble teas made\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of lychee bubble teas made\n\n# Add constraints\nmodel.addConstr(4*x1 <= 2000, name=\"MangoJuiceAvailability\")  # Mango juice availability\nmodel.addConstr(6*x2 <= 3000, name=\"LycheeJuiceAvailability\")  # Lychee juice availability\nmodel.addConstr(x2 >= 0.4*(x1 + x2), name=\"LycheeFlavorRequirement\")  # At least 40% of the bubble teas made must be lychee flavored\nmodel.addConstr(x1 >= x2, name=\"MangoTeaSalesRequirement\")  # Mango bubble tea sells better and thus the number of mango bubble teas made must be large than the number of lychee bubble teas made\n\n# Set the objective function\nmodel.setObjective(8*x1 + 6*x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total amount of tea needed: {:.2f}\".format(model.objval))\n    print(\"Number of mango bubble teas made: {:.0f}\".format(x1.x))\n    print(\"Number of lychee bubble teas made: {:.0f}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 4a627289\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing an LP problem\n\nThe original problem has:\n    4 rows, 2 columns and 6 non-zero elements\nThe presolved problem is empty\n\nPostsolving\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    0.0000000000e+00            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 0.0000000000e+00  Iterations: 0  Time: 0.00s\nMinimum total amount of tea needed: 0.00\nNumber of mango bubble teas made: 0\nNumber of lychee bubble teas made: 0",
        "pass": true
      }
    ],
    "answer": 57.45,
    "cloze": "Star Oil Company is considering five different investment opportunities. The cash outflows and net present values (NPVs) (in millions of dollars) for each opportunity are given in Table 7. Specifically, Investment 1 has a time 0 cash outflow of $____ million and a time 1 cash outflow of $____ million, with an NPV of $____ million. Investment 2 requires a time 0 outflow of $____ million and a time 1 outflow of $____ million, yielding an NPV of $____ million. Investment 3 has smaller outflows of $____ million at both time 0 and time 1 and also an NPV of $____ million. Investment 4 asks for a time 0 outflow of $____ million and a minimal $____ million at time 1, with an NPV of $____ million. Lastly, Investment 5 requires a $____ million outflow at time 0 and a significant $____ million at time 1, resulting in the highest NPV of $____ million. Star Oil has $____ million available for investment at time 0, and it estimates that $____ million will be available for investment at time 1. Star Oil may purchase any fraction of each investment, in which case, the cash outflows and NPV are adjusted proportionally. For example, if Star Oil purchases one-fifth of investment 3, then a cash outflow of (1/5)*5=1 million dollars or $1 million would be required at time 0, and a cash outflow of (1/5)*5=1 million dollars or $1 million would be required at time 1. The one-fifth share of investment 3 would yield an NPV of (1/5)*16=3.2 million dollars or $3.2 million. Star Oil wants to ____ the NPV that can be obtained by investing in investments 1-5. The goal is to formulate an LP that will help achieve this objective. Assume that any funds left over at time 0 cannot be used at time 1. Find the ____ NPV in million dollars."
  },
  {
    "question": "Zeta Bakery sells two types of cookies. They sell a strawberry cookie and a sugar cookie. Let's say they make x1 strawberry cookies, at a profit of $5.5 each, and x2 sugar cookies, at a profit of $12 each (x1 and x2 are unknowns both greater than or equal to 0). The daily demand for these cookies is at most 100 strawberry cookies and at most 80 sugar cookies. The bakery is short staffed and can make a maximum of 100 cookies of either type per day. How much of each cookie should the bakery make in order to maximize profit?",
    "pass_count": 6,
    "pass_rate": 0.75,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of low-power air conditioners purchased.\n- \\(x_2\\): Number of high-power air conditioners purchased.\n\nObjective Function:\nMinimize the total number of air conditioners: \\(Z = x_1 + x_2\\)\n\nConstraints:\n1. Cooling requirement: \\(12x_1 + 17x_2 \\geq 250\\)\n2. Electricity constraint: \\(150x_1 + 250x_2 \\leq 8000\\)\n3. Limit on low-power models: \\(x_1 \\leq 0.3(x_1 + x_2)\\)\n4. Minimum high-power models: \\(x_2 \\geq 7\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n6. Integer: \\(x_1, x_2 \\in \\mathbb{Z}^+\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerPurchase\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(12 * x1 + 17 * x2 >= 250, name=\"CoolingRequirement\")\nmodel.addConstr(150 * x1 + 250 * x2 <= 8000, name=\"ElectricityConstraint\")\nmodel.addConstr(x1 <= 0.3 * (x1 + x2), name=\"LowPowerLimit\")\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimum\")\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-power air conditioners: {}\".format(x1.x))\n    print(\"Number of high-power air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerPurchase\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")\n\n# Add constraints\nmodel.addConstr(12 * x1 + 17 * x2 >= 250, name=\"CoolingRequirement\")\nmodel.addConstr(150 * x1 + 250 * x2 <= 8000, name=\"ElectricityConstraint\")\nmodel.addConstr(x1 <= 0.3 * (x1 + x2), name=\"LowPowerLimit\")\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimum\")\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-power air conditioners: {}\".format(x1.x))\n    print(\"Number of high-power air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 192fcc03\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 7 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  7.000000e+00            --     Inf  0.02s\nH        0         1      --       0  7.000000e+00  2.600000e+01  73.08%  0.02s\nH        0         1      --       0  7.000000e+00  1.600000e+01  56.25%  0.03s\nH        0         1      --       0  7.000000e+00  1.500000e+01  53.33%  0.03s\n         1         1     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.03s\n         1         1     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.03s\n\nBest solution   : 15.000000000\nBest bound      : 15.000000000\nBest gap        : 0.0000%\nSolve time      : 0.03\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of air conditioners: 15.0\nNumber of low-power air conditioners: 0.0\nNumber of high-power air conditioners: 15.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): the number of low-powered air conditioners.\n- \\(x_2\\): the number of high-powered air conditioners.\n\nObjective Function:\n- Minimize the total number of air conditioners: \\(Z = x_1 + x_2\\)\n\nConstraints:\n1. The total number of housing units cooled must be at least 250: \\(12x_1 + 17x_2 \\geq 250\\)\n2. The total electricity used must be at most 8000 units: \\(150x_1 + 250x_2 \\leq 8000\\)\n3. The number of low-powered air conditioners must be no more than 30% of the total number of air conditioners: \\(x_1 \\leq 0.3(x_1 + x_2)\\)\n4. The number of high-powered air conditioners must be at least 7: \\(x_2 \\geq 7\\)\n5. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n6. Integer: \\(x_1, x_2\\) must be integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of low-powered air conditioners\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of high-powered air conditioners\n\n# Add constraints\nmodel.addConstr(12*x1 + 17*x2 >= 250, name=\"CoolingRequirement\")  # Housing unit cooling requirement\nmodel.addConstr(150*x1 + 250*x2 <= 8000, name=\"ElectricityLimit\")  # Electricity limit\nmodel.addConstr(x1 <= 0.3*(x1 + x2), name=\"LowPowerLimit\")  # Low-powered air conditioners limit\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimum\")  # High-powered air conditioners minimum\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimized total number of air conditioners: {}\".format(model.objval))\n    print(f\"Number of low-powered air conditioners: {x1.x}\")\n    print(f\"Number of high-powered air conditioners: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of low-powered air conditioners\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of high-powered air conditioners\n\n# Add constraints\nmodel.addConstr(12*x1 + 17*x2 >= 250, name=\"CoolingRequirement\")  # Housing unit cooling requirement\nmodel.addConstr(150*x1 + 250*x2 <= 8000, name=\"ElectricityLimit\")  # Electricity limit\nmodel.addConstr(x1 <= 0.3*(x1 + x2), name=\"LowPowerLimit\")  # Low-powered air conditioners limit\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimum\")  # High-powered air conditioners minimum\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimized total number of air conditioners: {}\".format(model.objval))\n    print(f\"Number of low-powered air conditioners: {x1.x}\")\n    print(f\"Number of high-powered air conditioners: {x2.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 192fcc03\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 7 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  7.000000e+00            --     Inf  0.00s\nH        0         1      --       0  7.000000e+00  2.600000e+01  73.08%  0.00s\nH        0         1      --       0  7.000000e+00  1.600000e+01  56.25%  0.01s\nH        0         1      --       0  7.000000e+00  1.500000e+01  53.33%  0.01s\n         1         1     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         1     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n\nBest solution   : 15.000000000\nBest bound      : 15.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimized total number of air conditioners: 15.0\nNumber of low-powered air conditioners: 0.0\nNumber of high-powered air conditioners: 15.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_1\\): Number of low-powered air conditioners purchased.  \n- \\(x_2\\): Number of high-powered air conditioners purchased.  \n\nObjective Function:  \nMinimize total number of air conditioners:  \n\\(Z = x_1 + x_2\\)\n\nConstraints:  \n1. Cooling capacity requirement:  \n   \\(12x_1 + 17x_2 \\geq 250\\)\n\n2. Electricity usage limit:  \n   \\(150x_1 + 250x_2 \\leq 8000\\)\n\n3. Limit on low-powered air conditioners:  \n   \\(x_1 \\leq 0.3x_2\\)\n\n4. Minimum number of high-powered air conditioners:  \n   \\(x_2 \\geq 7\\)\n\n5. Non-negativity and integer:  \n   \\(x_1, x_2 \\geq 0\\) and integers.\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): The number of low-power air conditioners purchased.\n- \\(x_2\\): The number of high-power air conditioners purchased.\n\nObjective Function:\n- Minimize the total number of air conditioners: \\(Z = x_1 + x_2\\).\n\nConstraints:\n1. The total number of housing units cooled down must be at least 250: \\(12x_1 + 17x_2 \\geq 250\\).\n2. The total electricity usage must not exceed 8000 units: \\(150x_1 + 250x_2 \\leq 8000\\).\n3. The number of low-power air conditioners must be at most 30% of the total number of air conditioners: \\(x_1 \\leq 0.3(x_1 + x_2)\\).\n4. The number of high-power air conditioners must be at least 7: \\(x_2 \\geq 7\\).\n5. Non-negativity and integer constraints: \\(x_1, x_2 \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerPurchasing\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")  # Number of low-power air conditioners\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")  # Number of high-power air conditioners\n\n# Add constraints\nmodel.addConstr(12*x1 + 17*x2 >= 250, name=\"HousingUnitsConstraint\")\nmodel.addConstr(150*x1 + 250*x2 <= 8000, name=\"ElectricityUsageConstraint\")\nmodel.addConstr(x1 <= 0.3*(x1 + x2), name=\"LowPowerLimitConstraint\")\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimumConstraint\")\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-power air conditioners: {}\".format(x1.x))\n    print(\"Number of high-power air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerPurchasing\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")  # Number of low-power air conditioners\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")  # Number of high-power air conditioners\n\n# Add constraints\nmodel.addConstr(12*x1 + 17*x2 >= 250, name=\"HousingUnitsConstraint\")\nmodel.addConstr(150*x1 + 250*x2 <= 8000, name=\"ElectricityUsageConstraint\")\nmodel.addConstr(x1 <= 0.3*(x1 + x2), name=\"LowPowerLimitConstraint\")\nmodel.addConstr(x2 >= 7, name=\"HighPowerMinimumConstraint\")\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-power air conditioners: {}\".format(x1.x))\n    print(\"Number of high-power air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 192fcc03\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 7 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  7.000000e+00            --     Inf  0.00s\nH        0         1      --       0  7.000000e+00  2.600000e+01  73.08%  0.00s\nH        0         1      --       0  7.000000e+00  1.600000e+01  56.25%  0.01s\nH        0         1      --       0  7.000000e+00  1.500000e+01  53.33%  0.01s\n         1         1     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         1     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n\nBest solution   : 15.000000000\nBest bound      : 15.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of air conditioners: 15.0\nNumber of low-power air conditioners: 0.0\nNumber of high-power air conditioners: 15.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of low-powered air conditioners purchased.\n- \\(x_2\\): Number of high-powered air conditioners purchased.\n\nObjective Function:\n- Minimize total number of air conditioners: \\(Z = x_1 + x_2\\)\n\nConstraints:\n1. Housing unit cooling requirement: \\(12x_1 + 17x_2 \\geq 250\\)\n2. Electricity usage limit: \\(150x_1 + 250x_2 \\leq 8000\\)\n3. Limit on low-powered air conditioners: \\(x_1 \\leq 0.3x_2\\)\n4. Minimum number of high-powered air conditioners: \\(x_2 \\geq 7\\)\n5. Non-negativity and integer constraints: \\(x_1, x_2 \\geq 0\\) and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerPurchasing\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of low-powered air conditioners\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of high-powered air conditioners\n\n# Add constraints\nmodel.addConstr(12*x1 + 17*x2 >= 250, name=\"HousingUnitCoolingRequirement\")  # Housing unit cooling requirement\nmodel.addConstr(150*x1 + 250*x2 <= 8000, name=\"ElectricityUsageLimit\")  # Electricity usage limit\nmodel.addConstr(x1 <= 0.3*x2, name=\"LimitOnLowPowerAirConditioners\")  # Limit on low-powered air conditioners\nmodel.addConstr(x2 >= 7, name=\"MinimumNumberOfHighPowerAirConditioners\")  # Minimum number of high-powered air conditioners\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-powered air conditioners: {}\".format(x1.x))\n    print(\"Number of high-powered air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerPurchasing\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of low-powered air conditioners\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of high-powered air conditioners\n\n# Add constraints\nmodel.addConstr(12*x1 + 17*x2 >= 250, name=\"HousingUnitCoolingRequirement\")  # Housing unit cooling requirement\nmodel.addConstr(150*x1 + 250*x2 <= 8000, name=\"ElectricityUsageLimit\")  # Electricity usage limit\nmodel.addConstr(x1 <= 0.3*x2, name=\"LimitOnLowPowerAirConditioners\")  # Limit on low-powered air conditioners\nmodel.addConstr(x2 >= 7, name=\"MinimumNumberOfHighPowerAirConditioners\")  # Minimum number of high-powered air conditioners\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-powered air conditioners: {}\".format(x1.x))\n    print(\"Number of high-powered air conditioners: {}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: d058e560\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 7 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  9.000000e+00            --     Inf  0.01s\nH        0         1      --       0  9.000000e+00  3.000000e+01  70.00%  0.01s\nH        0         1      --       0  9.000000e+00  1.500000e+01  40.00%  0.01s\n         0         1      --       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         0     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         0     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n\nBest solution   : 15.000000000\nBest bound      : 15.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of air conditioners: 15.0\nNumber of low-powered air conditioners: 0.0\nNumber of high-powered air conditioners: 15.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of low-power air conditioners to be purchased.\n- \\(x_2\\): Number of high-power air conditioners to be purchased.\n\nObjective Function:\n- Minimize the total number of air conditioners: \\(Z = x_1 + x_2\\)\n\nConstraints:\n1. The number of low-power air conditioners must not exceed 30% of the total number of air conditioners: \\(x_1 \\leq 0.3(x_1 + x_2)\\).\n2. At least 7 high-power air conditioners must be used: \\(x_2 \\geq 7\\).\n3. The total cooling capacity must be at least 250 housing units: \\(12x_1 + 17x_2 \\geq 250\\).\n4. The total electricity consumption must not exceed 8000 units: \\(150x_1 + 250x_2 \\leq 8000\\).\n5. Non-negativity and integer constraints: \\(x_1, x_2 \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerPurchase\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")  # Number of low-power air conditioners\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")  # Number of high-power air conditioners\n\n# Add constraints\nmodel.addConstr(x1 <= 0.3 * (x1 + x2), name=\"CoolingCapacityConstraint\")  # Cooling capacity constraint\nmodel.addConstr(x2 >= 7, name=\"HighPowerModelConstraint\")  # High-power model constraint\nmodel.addConstr(12 * x1 + 17 * x2 >= 250, name=\"TotalCoolingCapacityConstraint\")  # Total cooling capacity constraint\nmodel.addConstr(150 * x1 + 250 * x2 <= 8000, name=\"TotalElectricityConsumptionConstraint\")  # Total electricity consumption constraint\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {:.0f}\".format(model.objval))\n    print(\"Number of low-power air conditioners: {:.0f}\".format(x1.x))\n    print(\"Number of high-power air conditioners: {:.0f}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerPurchase\")\n\n# Add decision variables\nx1 = model.addVar(vtype=COPT.INTEGER, name=\"x1\")  # Number of low-power air conditioners\nx2 = model.addVar(vtype=COPT.INTEGER, name=\"x2\")  # Number of high-power air conditioners\n\n# Add constraints\nmodel.addConstr(x1 <= 0.3 * (x1 + x2), name=\"CoolingCapacityConstraint\")  # Cooling capacity constraint\nmodel.addConstr(x2 >= 7, name=\"HighPowerModelConstraint\")  # High-power model constraint\nmodel.addConstr(12 * x1 + 17 * x2 >= 250, name=\"TotalCoolingCapacityConstraint\")  # Total cooling capacity constraint\nmodel.addConstr(150 * x1 + 250 * x2 <= 8000, name=\"TotalElectricityConsumptionConstraint\")  # Total electricity consumption constraint\n\n# Set the objective function\nmodel.setObjective(x1 + x2, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {:.0f}\".format(model.objval))\n    print(\"Number of low-power air conditioners: {:.0f}\".format(x1.x))\n    print(\"Number of high-power air conditioners: {:.0f}\".format(x2.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 36af9a7\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 2 columns and 7 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  7.000000e+00            --     Inf  0.00s\nH        0         1      --       0  7.000000e+00  2.600000e+01  73.08%  0.00s\nH        0         1      --       0  7.000000e+00  1.600000e+01  56.25%  0.01s\nH        0         1      --       0  7.000000e+00  1.500000e+01  53.33%  0.01s\n         1         1     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         1     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n\nBest solution   : 15.000000000\nBest bound      : 15.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of air conditioners: 15\nNumber of low-power air conditioners: 0\nNumber of high-power air conditioners: 15",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_1\\): Number of low-power air conditioners purchased.  \n- \\(x_2\\): Number of high-power air conditioners purchased.  \n\nObjective Function:  \nMinimize the total number of air conditioners:  \n\\[\nZ = x_1 + x_2\n\\]\n\nConstraints:  \n1. The total number of housing units cooled must be at least 250:  \n\\[\n12x_1 + 17x_2 \\geq 250\n\\]  \n2. The total electricity usage must not exceed 8000 units:  \n\\[\n150x_1 + 250x_2 \\leq 8000\n\\]  \n3. The number of low-power air conditioners cannot exceed 30% of the total number of air conditioners:  \n\\[\nx_1 \\leq 0.3(x_1 + x_2)\n\\]  \n4. The number of high-power air conditioners must be at least 7:  \n\\[\nx_2 \\geq 7\n\\]  \n5. Non-negativity and integer constraints:  \n\\[\nx_1, x_2 \\geq 0 \\text{ and integers}\n\\]  \n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- Let \\(x\\) be the number of low-power air conditioners.\n- Let \\(y\\) be the number of high-power air conditioners.\n\nObjective Function:\n- Minimize the total number of air conditioners: \\(Z = x + y\\)\n\nConstraints:\n1. Cooling requirement: \\(12x + 17y \\geq 250\\)\n2. Electricity availability: \\(150x + 250y \\leq 8000\\)\n3. Low-power air conditioner limit: \\(x \\leq 0.3y\\)\n4. Minimum high-power air conditioners: \\(y \\geq 7\\)\n5. Non-negativity: \\(x, y \\geq 0\\) and integers\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerOptimization\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")  # Number of low-power air conditioners\ny = model.addVar(lb=7, vtype=COPT.INTEGER, name=\"y\")  # Number of high-power air conditioners\n\n# Add constraints\nmodel.addConstr(12*x + 17*y >= 250, name=\"CoolingRequirement\")  # Cooling requirement\nmodel.addConstr(150*x + 250*y <= 8000, name=\"ElectricityAvailability\")  # Electricity availability\nmodel.addConstr(x <= 0.3*y, name=\"LowPowerLimit\")  # Low-power air conditioner limit\n\n# Set the objective function\nmodel.setObjective(x + y, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-power air conditioners: {}\".format(x.x))\n    print(\"Number of high-power air conditioners: {}\".format(y.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"AirConditionerOptimization\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")  # Number of low-power air conditioners\ny = model.addVar(lb=7, vtype=COPT.INTEGER, name=\"y\")  # Number of high-power air conditioners\n\n# Add constraints\nmodel.addConstr(12*x + 17*y >= 250, name=\"CoolingRequirement\")  # Cooling requirement\nmodel.addConstr(150*x + 250*y <= 8000, name=\"ElectricityAvailability\")  # Electricity availability\nmodel.addConstr(x <= 0.3*y, name=\"LowPowerLimit\")  # Low-power air conditioner limit\n\n# Set the objective function\nmodel.setObjective(x + y, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total number of air conditioners: {}\".format(model.objval))\n    print(\"Number of low-power air conditioners: {}\".format(x.x))\n    print(\"Number of high-power air conditioners: {}\".format(y.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: a58bcf33\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\n\nThe presolved problem has:\n    3 rows, 2 columns and 6 non-zero elements\n    2 integers\n\n\n     Nodes    Active  LPit/n  IntInf     BestBound  BestSolution     Gap   Time\n         0         1      --       0  9.000000e+00            --     Inf  0.00s\nH        0         1      --       0  9.000000e+00  3.000000e+01  70.00%  0.00s\nH        0         1      --       0  9.000000e+00  1.500000e+01  40.00%  0.01s\n         0         1      --       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         0     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n         1         0     0.0       0  1.500000e+01  1.500000e+01  0.000%  0.01s\n\nBest solution   : 15.000000000\nBest bound      : 15.000000000\nBest gap        : 0.0000%\nSolve time      : 0.01\nSolve node      : 1\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total number of air conditioners: 15.0\nNumber of low-power air conditioners: 0.0\nNumber of high-power air conditioners: 15.0",
        "pass": true
      }
    ],
    "answer": 1070.0,
    "cloze": "Zeta Bakery sells two types of cookies. They sell a strawberry cookie and a sugar cookie. Let's say they make x1 strawberry cookies, at a profit of $____ each, and x2 sugar cookies, at a profit of $____ each (x1 and x2 are unknowns both greater than or equal to ____). The daily demand for these cookies is ____ ____ strawberry cookies and ____ ____ sugar cookies. The bakery is short staffed and can make ____ ____ ____ cookies of either type per day. How much of each cookie should the bakery make in order to ____ profit?"
  },
  {
    "question": "A strata-management company is looking into purchasing two types of air conditioners, a low-power and a high-power model. A low-powered air conditioner can cool down 12 housing units and uses 150 units of electricity every day. A high-power model can cool down 17 housing units and uses 250 units of electricity every day. Since the low-powered model is not good for the aesthetics, the strata decided to limit the number of low-powered models to only 30% and at least 7 high-powered models must be used. If the apartment needs to condition at least 250 housing units and has 8000 units of electricity available, how many of each air conditioner should the strata company buy to minimize the total number of air conditioners?",
    "pass_count": 4,
    "pass_rate": 0.5,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of units of product 1 produced per day.\n- \\(x_2\\): Number of units of product 2 produced per day.\n- \\(y\\): Hours of overtime assembly labor scheduled per day.\n\nObjective Function:\n- Maximize daily profit:  \n  \\[Z = 9x_1 + 8x_2 - 7y\\]\n\nConstraints:\n1. Assembly labor limit:  \n   \\[0.25x_1 + 0.33x_2 + y \\leq 90\\]\n2. Testing limit:  \n   \\[0.125x_1 + 0.33x_2 \\leq 80\\]\n3. Overtime assembly labor limit:  \n   \\[y \\leq 50\\]\n4. Non-negativity and integer:  \n   \\[x_1, x_2, y \\geq 0\\] and integer.\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of units of the first product produced per day.\n- \\(x_2\\): Number of units of the second product produced per day.\n- \\(o_1\\): Number of overtime hours for assembly labor.\n- \\(o_2\\): Number of overtime hours for testing.\n\nObjective Function:\n- Maximize daily profit: \\(Z = 9x_1 + 8x_2 - 7o_1\\)\n\nConstraints:\n1. Assembly labor: \\(\\frac{1}{4}x_1 + \\frac{1}{3}x_2 \\leq 90\\)\n2. Testing: \\(\\frac{1}{8}x_1 + \\frac{1}{3}x_2 \\leq 80\\)\n3. Overtime assembly labor: \\(o_1 \\leq 50\\)\n4. Non-negativity: \\(x_1, x_2, o_1 \\geq 0\\) and integer.\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- x1: Number of units of product 1 produced per day.\n- x2: Number of units of product 2 produced per day.\n- o1: Overtime hours for assembly labor per day.\n\nObjective Function:\nMaximize Z = 9x1 + 8x2 - 7o1\n\nConstraints:\n1. Assembly labor constraint: (1/4)x1 + (1/3)x2 ≤ 90\n2. Testing labor constraint: (1/8)x1 + (1/3)x2 ≤ 80\n3. Overtime assembly labor constraint: o1 ≤ 50\n4. Non-negativity: x1 ≥ 0, x2 ≥ 0, o1 ≥ 0\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"CompanyProfitMaximization\")\n\n# Define decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of units of product 1 produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of units of product 2 produced per day\no1 = model.addVar(lb=0, name=\"o1\")  # Overtime hours for assembly labor per day\n\n# Define the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*o1, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr((1/4)*x1 + (1/3)*x2 <= 90, name=\"AssemblyLaborConstraint\")  # Assembly labor constraint\nmodel.addConstr((1/8)*x1 + (1/3)*x2 <= 80, name=\"TestingLaborConstraint\")  # Testing labor constraint\nmodel.addConstr(o1 <= 50, name=\"OvertimeAssemblyConstraint\")  # Overtime assembly labor constraint\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${}\".format(round(model.objval)))\n    print(\"Optimal production plan:\")\n    print(f\"Product 1: {x1.x:.0f} units\")\n    print(f\"Product 2: {x2.x:.0f} units\")\n    print(f\"Overtime assembly labor: {o1.x:.0f} hours\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"CompanyProfitMaximization\")\n\n# Define decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of units of product 1 produced per day\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of units of product 2 produced per day\no1 = model.addVar(lb=0, name=\"o1\")  # Overtime hours for assembly labor per day\n\n# Define the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*o1, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr((1/4)*x1 + (1/3)*x2 <= 90, name=\"AssemblyLaborConstraint\")  # Assembly labor constraint\nmodel.addConstr((1/8)*x1 + (1/3)*x2 <= 80, name=\"TestingLaborConstraint\")  # Testing labor constraint\nmodel.addConstr(o1 <= 50, name=\"OvertimeAssemblyConstraint\")  # Overtime assembly labor constraint\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${}\".format(round(model.objval)))\n    print(\"Optimal production plan:\")\n    print(f\"Product 1: {x1.x:.0f} units\")\n    print(f\"Product 2: {x2.x:.0f} units\")\n    print(f\"Overtime assembly labor: {o1.x:.0f} hours\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: e9ebfcb1\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    3 rows, 3 columns and 5 non-zero elements\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    5.1704556072e+03            2           0       0.00s\nDual             1    3.2400506719e+03            0           0       0.00s\nPostsolving\nDual             1    3.2400000000e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 3.2400000000e+03  Iterations: 1  Time: 0.00s\nMaximized daily profit: $3240\nOptimal production plan:\nProduct 1: 360 units\nProduct 2: 0 units\nOvertime assembly labor: 0 hours",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of units of product type 1 produced per day.\n- \\(x_2\\): Number of units of product type 2 produced per day.\n- \\(o_1\\): Number of overtime hours of assembly labor used per day.\n\nObjective Function:\n- Maximize daily profit:  \n  \\[Z = (9 - 1.2)x_1 + (8 - 0.9)x_2 - 7o_1\\]\n\nConstraints:\n1. Assembly labor capacity (non-overtime):  \n   \\[0.25x_1 + 0.333x_2 \\leq 90\\]\n2. Testing labor capacity:  \n   \\[0.125x_1 + 0.333x_2 \\leq 80\\]\n3. Overtime assembly labor capacity:  \n   \\[o_1 \\leq 50\\]\n4. Non-negativity and integer constraints:  \n   \\[x_1, x_2, o_1 \\geq 0 \\text{ and integer}\\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"FactoryProfitMaximization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of units of product type 1 produced per day\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of units of product type 2 produced per day\no1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"o1\")  # Number of overtime hours of assembly labor used per day\n\n# Set the objective function to maximize daily profit\nmodel.setObjective(9*x1 - 1.2*x1 + 8*x2 - 0.9*x2 - 7*o1, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(0.25*x1 + 0.333*x2 <= 90, name=\"AssemblyCapacity\")  # Assembly labor capacity (non-overtime)\nmodel.addConstr(0.125*x1 + 0.333*x2 <= 80, name=\"TestingCapacity\")  # Testing labor capacity\nmodel.addConstr(o1 <= 50, name=\"OvertimeCapacity\")  # Overtime assembly labor capacity\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${:.0f}\".format(round(model.objval)))\n    print(\"Optimal production plan:\")\n    print(f\"Product type 1: {x1.x} units\")\n    print(f\"Product type 2: {x2.x} units\")\n    print(f\"Overtime assembly labor: {o1.x} hours\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"FactoryProfitMaximization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of units of product type 1 produced per day\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of units of product type 2 produced per day\no1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"o1\")  # Number of overtime hours of assembly labor used per day\n\n# Set the objective function to maximize daily profit\nmodel.setObjective(9*x1 - 1.2*x1 + 8*x2 - 0.9*x2 - 7*o1, sense=COPT.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(0.25*x1 + 0.333*x2 <= 90, name=\"AssemblyCapacity\")  # Assembly labor capacity (non-overtime)\nmodel.addConstr(0.125*x1 + 0.333*x2 <= 80, name=\"TestingCapacity\")  # Testing labor capacity\nmodel.addConstr(o1 <= 50, name=\"OvertimeCapacity\")  # Overtime assembly labor capacity\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${:.0f}\".format(round(model.objval)))\n    print(\"Optimal production plan:\")\n    print(f\"Product type 1: {x1.x} units\")\n    print(f\"Product type 2: {x2.x} units\")\n    print(f\"Overtime assembly labor: {o1.x} hours\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 20d1e7e3\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    3 rows, 3 columns and 5 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 2808.000000000\nBest bound      : 2808.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized daily profit: $2808\nOptimal production plan:\nProduct type 1: 360.0 units\nProduct type 2: 0.0 units\nOvertime assembly labor: 0.0 hours",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): The number of units of the first product produced per day.\n- \\(x_2\\): The number of units of the second product produced per day.\n\nObjective Function:\n- Maximize the daily profit: \\(Z = 9x_1 + 8x_2 - 7 \\cdot \\max(0, 0.25x_1 + 0.33x_2 - 90)\\)\n\nConstraints:\n1. Assembly labor: \\(0.25x_1 + 0.33x_2 \\leq 90\\)\n2. Testing labor: \\(0.125x_1 + 0.33x_2 \\leq 80\\)\n3. Non-negativity: \\(x_1, x_2 \\geq 0\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"CompanyProfitMaximization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of units of the first product\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of units of the second product\n\n# Add constraints\nmodel.addConstr(0.25*x1 + 0.33*x2 <= 90, name=\"AssemblyLabor\")  # Assembly labor constraint\nmodel.addConstr(0.125*x1 + 0.33*x2 <= 80, name=\"TestingLabor\")  # Testing labor constraint\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*COPT.max(0, 0.25*x1 + 0.33*x2 - 90), sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${}\".format(round(model.objval)))\n    print(\"Number of units of the first product: {}\".format(round(x1.x)))\n    print(\"Number of units of the second product: {}\".format(round(x2.x)))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"CompanyProfitMaximization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Number of units of the first product\nx2 = model.addVar(lb=0, name=\"x2\")  # Number of units of the second product\n\n# Add constraints\nmodel.addConstr(0.25*x1 + 0.33*x2 <= 90, name=\"AssemblyLabor\")  # Assembly labor constraint\nmodel.addConstr(0.125*x1 + 0.33*x2 <= 80, name=\"TestingLabor\")  # Testing labor constraint\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*COPT.max(0, 0.25*x1 + 0.33*x2 - 90), sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized daily profit: ${}\".format(round(model.objval)))\n    print(\"Number of units of the first product: {}\".format(round(x1.x)))\n    print(\"Number of units of the second product: {}\".format(round(x2.x)))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Error: type object 'COPT' has no attribute 'max'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_1\\): Number of units of product 1 produced per day.  \n- \\(x_2\\): Number of units of product 2 produced per day.  \n- \\(o_1\\): Overtime hours of assembly labor used per day.  \n\nObjective Function:  \n- Maximize daily profit:  \n  \\[Z = 9x_1 + 8x_2 - 7o_1\\]  \n\nConstraints:  \n1. Assembly labor:  \n   \\[0.25x_1 + 0.3333x_2 + o_1 \\leq 90\\]  \n2. Testing:  \n   \\[0.125x_1 + 0.3333x_2 \\leq 80\\]  \n3. Overtime labor:  \n   \\[o_1 \\leq 50\\]  \n4. Non-negativity and integer:  \n   \\[x_1, x_2, o_1 \\geq 0\\] and integers.  \n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_1\\): The number of units of product type 1 produced per day.  \n- \\(x_2\\): The number of units of product type 2 produced per day.  \n- \\(y_1\\): The number of overtime hours used for assembly labor.  \n- \\(y_2\\): The number of overtime hours used for testing.  \n\nObjective Function:  \nMaximize profit:  \n\\[\nZ = 9x_1 + 8x_2 - 7y_1 - 7y_2\n\\]\n\nConstraints:  \n1. Assembly labor hours:  \n\\[\n\\frac{1}{4}x_1 + \\frac{1}{3}x_2 + y_1 \\leq 90\n\\]  \n2. Testing hours:  \n\\[\n\\frac{1}{8}x_1 + \\frac{1}{3}x_2 + y_2 \\leq 80\n\\]  \n3. Overtime limits:  \n\\[\ny_1 \\leq 50, \\quad y_2 \\leq 50\n\\]  \n4. Non-negativity and integer:  \n\\[\nx_1, x_2, y_1, y_2 \\geq 0 \\quad \\text{and integer}\n\\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of units of product type 1\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of units of product type 2\ny1 = model.addVar(lb=0, ub=50, vtype=COPT.INTEGER, name=\"y1\")  # Overtime hours used for assembly labor\ny2 = model.addVar(lb=0, ub=50, vtype=COPT.INTEGER, name=\"y2\")  # Overtime hours used for testing\n\n# Add constraints\nmodel.addConstr(0.25*x1 + (1/3)*x2 + y1 <= 90, name=\"AssemblyLaborConstraint\")  # Assembly labor hours\nmodel.addConstr(0.125*x1 + (1/3)*x2 + y2 <= 80, name=\"TestingConstraint\")  # Testing hours\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*y1 - 7*y2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximum daily profit: ${round(model.objval)}\")\n    print(f\"Units of product type 1: {x1.x}\")\n    print(f\"Units of product type 2: {x2.x}\")\n    print(f\"Overtime hours used for assembly labor: {y1.x}\")\n    print(f\"Overtime hours used for testing: {y2.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")  # Number of units of product type 1\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")  # Number of units of product type 2\ny1 = model.addVar(lb=0, ub=50, vtype=COPT.INTEGER, name=\"y1\")  # Overtime hours used for assembly labor\ny2 = model.addVar(lb=0, ub=50, vtype=COPT.INTEGER, name=\"y2\")  # Overtime hours used for testing\n\n# Add constraints\nmodel.addConstr(0.25*x1 + (1/3)*x2 + y1 <= 90, name=\"AssemblyLaborConstraint\")  # Assembly labor hours\nmodel.addConstr(0.125*x1 + (1/3)*x2 + y2 <= 80, name=\"TestingConstraint\")  # Testing hours\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*y1 - 7*y2, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximum daily profit: ${round(model.objval)}\")\n    print(f\"Units of product type 1: {x1.x}\")\n    print(f\"Units of product type 2: {x2.x}\")\n    print(f\"Overtime hours used for assembly labor: {y1.x}\")\n    print(f\"Overtime hours used for testing: {y2.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: f3555acc\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    2 rows, 4 columns and 6 non-zero elements\n    4 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 3240.000000000\nBest bound      : 3240.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximum daily profit: $3240\nUnits of product type 1: 360.0\nUnits of product type 2: 0.0\nOvertime hours used for assembly labor: 0.0\nOvertime hours used for testing: 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Number of units of product type 1 produced daily.\n- \\(x_2\\): Number of units of product type 2 produced daily.\n- \\(o_1\\): Overtime hours for assembly labor.\n\nObjective Function:\nMaximize daily profit:  \n\\(Z = 9x_1 + 8x_2 - 7o_1\\)\n\nConstraints:\n1. Assembly labor: \\(0.25x_1 + 0.333x_2 \\leq 90\\)\n2. Testing labor: \\(0.125x_1 + 0.333x_2 \\leq 80\\)\n3. Overtime assembly labor: \\(o_1 \\leq 50\\)\n4. Non-negativity and integer: \\(x_1, x_2, o_1 \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ProductionOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\no1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"o1\")\n\n# Add constraints\nmodel.addConstr(0.25*x1 + 0.333*x2 <= 90, name=\"AssemblyLabor\")\nmodel.addConstr(0.125*x1 + 0.333*x2 <= 80, name=\"TestingLabor\")\nmodel.addConstr(o1 <= 50, name=\"OvertimeAssemblyLabor\")\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*o1, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized daily profit: ${round(model.objval)}\")\n    print(f\"Optimal production quantities: Product 1: {x1.x}, Product 2: {x2.x}\")\n    print(f\"Optimal overtime hours for assembly: {o1.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ProductionOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x2\")\no1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"o1\")\n\n# Add constraints\nmodel.addConstr(0.25*x1 + 0.333*x2 <= 90, name=\"AssemblyLabor\")\nmodel.addConstr(0.125*x1 + 0.333*x2 <= 80, name=\"TestingLabor\")\nmodel.addConstr(o1 <= 50, name=\"OvertimeAssemblyLabor\")\n\n# Set the objective function\nmodel.setObjective(9*x1 + 8*x2 - 7*o1, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Maximized daily profit: ${round(model.objval)}\")\n    print(f\"Optimal production quantities: Product 1: {x1.x}, Product 2: {x2.x}\")\n    print(f\"Optimal overtime hours for assembly: {o1.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 13db812a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing a MIP problem\n\nThe original problem has:\n    3 rows, 3 columns and 5 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 3240.000000000\nBest bound      : 3240.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMaximized daily profit: $3240\nOptimal production quantities: Product 1: 360.0, Product 2: 0.0\nOptimal overtime hours for assembly: 0.0",
        "pass": true
      }
    ],
    "answer": 15.0,
    "cloze": "A strata-management company is looking into purchasing two types of air conditioners, a low-power and a high-power model. A low-powered air conditioner can cool down ____ housing units and uses ____ units of electricity every day. A high-power model can cool down ____ housing units and uses ____ units of electricity every day. Since the low-powered model is not good for the aesthetics, the strata decided to limit the number of low-powered models to only ____ and ____ ____ high-powered models must be used. If the apartment needs to condition ____ ____ housing units and has ____ units of electricity available, how many of each air conditioner should the strata company buy to ____ the total number of air conditioners?"
  },
  {
    "question": "A company produces two kinds of products. A product of the first type requires 1/4 hours of assembly labor, 1/8 hours of testing, and $1.2 worth of raw materials. A product of the second type requires 1/3 hours of assembly, 1/3 hours of testing, and $0.9 worth of raw materials. Given the current personnel of the company, there can be at most 90 hours of assembly labor and 80 hours of testing each day. Suppose that up to 50 hours of overtime assembly labor can be scheduled, at a cost of $7 per hour. Products of the first and second type have a market value of $9 and $8 respectively. Try to maximize the daily profit of the company. Provide your answer rounded to the nearest dollar.",
    "pass_count": 4,
    "pass_rate": 0.5,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_X\\): Number of vehicles allocated to route X.  \n- \\(x_Y\\): Number of vehicles allocated to route Y.  \n- \\(x_Z\\): Number of vehicles allocated to route Z.  \n\nObjective Function:  \nMinimize total operating cost:  \n\\[\nZ = 10x_X + 15x_Y + 20x_Z\n\\]\n\nConstraints:  \n1. Combined number of vehicles on routes X and Y cannot exceed 1000:  \n   \\[\n   x_X + x_Y \\leq 1000\n   \\]  \n2. Combined number of vehicles on routes Y and Z cannot exceed 800:  \n   \\[\n   x_Y + x_Z \\leq 800\n   \\]  \n3. The sum of vehicles on routes X and Z must be at least 500:  \n   \\[\n   x_X + x_Z \\geq 500\n   \\]  \n4. Route X can accommodate up to 700 vehicles:  \n   \\[\n   x_X \\leq 700\n   \\]  \n5. Route Y can have a maximum of 600 vehicles:  \n   \\[\n   x_Y \\leq 600\n   \\]  \n6. Route Z can only handle up to 400 vehicles:  \n   \\[\n   x_Z \\leq 400\n   \\]  \n7. Non-negativity and integer constraints:  \n   \\[\n   x_X, x_Y, x_Z \\geq 0 \\text{ and integer}\n   \\]  \n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"VehicleAllocation\")\n\n# Define decision variables\nx_X = model.addVar(lb=0, ub=700, vtype=COPT.INTEGER, name=\"x_X\")  # Number of vehicles allocated to route X\nx_Y = model.addVar(lb=0, ub=600, vtype=COPT.INTEGER, name=\"x_Y\")  # Number of vehicles allocated to route Y\nx_Z = model.addVar(lb=0, ub=400, vtype=COPT.INTEGER, name=\"x_Z\")  # Number of vehicles allocated to route Z\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestrictionXY\")  # Combined number of vehicles on routes X and Y cannot exceed 1000\nmodel.addConstr(x_Y + x_Z <= 800, name=\"TrafficRestrictionYZ\")  # Combined number of vehicles on routes Y and Z cannot exceed 800\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevelXZ\")  # The sum of vehicles on routes X and Z must be at least 500\n\n# Set the objective function\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(\"Optimal vehicle allocations:\")\n    print(\"Route X: {} vehicles\".format(x_X.x))\n    print(\"Route Y: {} vehicles\".format(x_Y.x))\n    print(\"Route Z: {} vehicles\".format(x_Z.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"VehicleAllocation\")\n\n# Define decision variables\nx_X = model.addVar(lb=0, ub=700, vtype=COPT.INTEGER, name=\"x_X\")  # Number of vehicles allocated to route X\nx_Y = model.addVar(lb=0, ub=600, vtype=COPT.INTEGER, name=\"x_Y\")  # Number of vehicles allocated to route Y\nx_Z = model.addVar(lb=0, ub=400, vtype=COPT.INTEGER, name=\"x_Z\")  # Number of vehicles allocated to route Z\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestrictionXY\")  # Combined number of vehicles on routes X and Y cannot exceed 1000\nmodel.addConstr(x_Y + x_Z <= 800, name=\"TrafficRestrictionYZ\")  # Combined number of vehicles on routes Y and Z cannot exceed 800\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevelXZ\")  # The sum of vehicles on routes X and Z must be at least 500\n\n# Set the objective function\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(\"Optimal vehicle allocations:\")\n    print(\"Route X: {} vehicles\".format(x_X.x))\n    print(\"Route Y: {} vehicles\".format(x_Y.x))\n    print(\"Route Z: {} vehicles\".format(x_Z.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: e507b3d2\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    3 rows, 3 columns and 6 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 5000.000000000\nBest bound      : 5000.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total operating cost: 5000\nOptimal vehicle allocations:\nRoute X: 500.0 vehicles\nRoute Y: 0.0 vehicles\nRoute Z: 0.0 vehicles",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x\\): Number of vehicles allocated to route X (integer).\n- \\(y\\): Number of vehicles allocated to route Y (integer).\n- \\(z\\): Number of vehicles allocated to route Z (integer).\n\nObjective Function:\nMinimize total operating cost: \\(Z = 10x + 15y + 20z\\)\n\nConstraints:\n1. Traffic and road capacity constraints: \\(x + y \\leq 1000\\)\n2. Traffic and road capacity constraints: \\(y + z \\leq 800\\)\n3. Service level maintenance constraint: \\(x + z \\geq 500\\)\n4. Route capacity limits: \\(x \\leq 700\\), \\(y \\leq 600\\), \\(z \\leq 400\\)\n5. Non-negativity and integer: \\(x, y, z \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Add decision variables\nx = model.addVar(lb=0, ub=700, vtype=COPT.INTEGER, name=\"x\")\ny = model.addVar(lb=0, ub=600, vtype=COPT.INTEGER, name=\"y\")\nz = model.addVar(lb=0, ub=400, vtype=COPT.INTEGER, name=\"z\")\n\n# Add constraints\nmodel.addConstr(x + y <= 1000, name=\"TrafficCapacityXandY\")\nmodel.addConstr(y + z <= 800, name=\"TrafficCapacityYandZ\")\nmodel.addConstr(x + z >= 500, name=\"ServiceLevelMaintenance\")\n\n# Set the objective function\nmodel.setObjective(10*x + 15*y + 20*z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total operating cost: {round(model.objval)}\")\n    print(f\"Optimal allocation: Route X = {x.x}, Route Y = {y.x}, Route Z = {z.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Add decision variables\nx = model.addVar(lb=0, ub=700, vtype=COPT.INTEGER, name=\"x\")\ny = model.addVar(lb=0, ub=600, vtype=COPT.INTEGER, name=\"y\")\nz = model.addVar(lb=0, ub=400, vtype=COPT.INTEGER, name=\"z\")\n\n# Add constraints\nmodel.addConstr(x + y <= 1000, name=\"TrafficCapacityXandY\")\nmodel.addConstr(y + z <= 800, name=\"TrafficCapacityYandZ\")\nmodel.addConstr(x + z >= 500, name=\"ServiceLevelMaintenance\")\n\n# Set the objective function\nmodel.setObjective(10*x + 15*y + 20*z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total operating cost: {round(model.objval)}\")\n    print(f\"Optimal allocation: Route X = {x.x}, Route Y = {y.x}, Route Z = {z.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: e507b3d2\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    3 rows, 3 columns and 6 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 5000.000000000\nBest bound      : 5000.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total operating cost: 5000\nOptimal allocation: Route X = 500.0, Route Y = 0.0, Route Z = 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x\\): Number of vehicles allocated to route X.\n- \\(y\\): Number of vehicles allocated to route Y.\n- \\(z\\): Number of vehicles allocated to route Z.\n\nObjective Function:\nMinimize total operating cost:  \n\\[\nZ = 10x + 15y + 20z\n\\]\n\nConstraints:\n1. \\(x + y \\leq 1000\\)  \n2. \\(y + z \\leq 800\\)  \n3. \\(x + z \\geq 500\\)  \n4. \\(x \\leq 700\\)  \n5. \\(y \\leq 600\\)  \n6. \\(z \\leq 400\\)  \n7. \\(x, y, z \\geq 0\\) and integer.\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- $x\\): Number of vehicles allocated to route \\(X\\).\n- \\(y\\): Number of vehicles allocated to route \\(Y\\).\n- \\(z\\): Number of vehicles allocated to route \\(Z\\).\n\nObjective Function:\nMinimize the total operating cost:\n\\[\nZ = 10x + 15y + 20z\n\\]\n\nConstraints:\n1. Traffic restrictions on routes \\(X\\) and \\(Y\\):\n   \\[\n   x + y \\leq 1000\n   \\]\n2. Traffic restrictions on routes \\(Y\\) and \\(Z\\):\n   \\[\n   y + z \\leq 800\n   \\]\n3. Service level requirement across routes \\(X\\) and \\(Z\\):\n   \\[\n   x + z \\geq 500\n   \\]\n4. Route capacity limits:\n   \\[\n   x \\leq 700\n   \\]\n   \\[\n   y \\leq 600\n   \\]\n   \\[\n   z \\leq 400\n   \\]\n5. Non-negativity and integer constraints:\n   \\[\n   x, y, z \\geq 0 \\quad \\text{and} \\quad x, y, z \\in \\mathbb{Z}\n   \\]\n</model>",
        "code": "",
        "exec_output": "Error: Execution timeout",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_X\\): Number of vehicles allocated to route X.\n- \\(x_Y\\): Number of vehicles allocated to route Y.\n- \\(x_Z\\): Number of vehicles allocated to route Z.\n\nObjective Function:\nMinimize total operating cost:  \n\\(Z = 10x_X + 15x_Y + 20x_Z\\)\n\nConstraints:\n1. Traffic restrictions on routes X and Y:  \n   \\(x_X + x_Y \\leq 1000\\)\n2. Traffic restrictions on routes Y and Z:  \n   \\(x_Y + x_Z \\leq 800\\)\n3. Service level requirement for routes X and Z:  \n   \\(x_X + x_Z \\geq 500\\)\n4. Route capacity limits:  \n   \\(x_X \\leq 700\\),  \n   \\(x_Y \\leq 600\\),  \n   \\(x_Z \\leq 400\\)\n5. Non-negativity and integer constraints:  \n   \\(x_X, x_Y, x_Z \\geq 0\\) and integers.\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x\\): Number of vehicles allocated to route \\(X\\).\n- \\(y\\): Number of vehicles allocated to route \\(Y\\).\n- \\(z\\): Number of vehicles allocated to route \\(Z\\).\n\nObjective Function:\nMinimize total operating cost:  \n\\[\nZ = 10x + 15y + 20z\n\\]\n\nConstraints:\n1. Combined number of vehicles on routes \\(X\\) and \\(Y\\):  \n   \\[\n   x + y \\leq 1000\n   \\]\n2. Combined number of vehicles on routes \\(Y\\) and \\(Z\\):  \n   \\[\n   y + z \\leq 800\n   \\]\n3. Sum of vehicles on routes \\(X\\) and \\(Z\\):  \n   \\[\n   x + z \\geq 500\n   \\]\n4. Route capacity limits:  \n   \\[\n   x \\leq 700, \\quad y \\leq 600, \\quad z \\leq 400\n   \\]\n5. Non-negativity and integer constraints:  \n   \\[\n   x, y, z \\geq 0 \\quad \\text{and integer}\n   \\]\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x\\): Number of vehicles on route X.\n- \\(y\\): Number of vehicles on route Y.\n- \\(z\\): Number of vehicles on route Z.\n\nObjective Function:\n- Minimize total operating cost: \\(Z = 10x + 15y + 20z\\)\n\nConstraints:\n1. Traffic restrictions: \\(x + y \\leq 1000\\)\n2. Road capacity: \\(y + z \\leq 800\\)\n3. Service levels: \\(x + z \\geq 500\\)\n4. Route capacities: \\(x \\leq 700\\), \\(y \\leq 600\\), \\(z \\leq 400\\)\n5. Non-negativity and integer: \\(x, y, z \\geq 0\\) and integers.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")\ny = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y\")\nz = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"z\")\n\n# Add constraints\nmodel.addConstr(x + y <= 1000, name=\"TrafficRestrictions\")\nmodel.addConstr(y + z <= 800, name=\"RoadCapacity\")\nmodel.addConstr(x + z >= 500, name=\"ServiceLevels\")\nmodel.addConstr(x <= 700, name=\"RouteXCapacity\")\nmodel.addConstr(y <= 600, name=\"RouteYCapacity\")\nmodel.addConstr(z <= 400, name=\"RouteZCapacity\")\n\n# Set the objective function\nmodel.setObjective(10*x + 15*y + 20*z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(\"Optimal allocations:\")\n    print(f\"Route X: {x.x}\")\n    print(f\"Route Y: {y.x}\")\n    print(f\"Route Z: {z.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"TransportationOptimization\")\n\n# Add decision variables\nx = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"x\")\ny = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"y\")\nz = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"z\")\n\n# Add constraints\nmodel.addConstr(x + y <= 1000, name=\"TrafficRestrictions\")\nmodel.addConstr(y + z <= 800, name=\"RoadCapacity\")\nmodel.addConstr(x + z >= 500, name=\"ServiceLevels\")\nmodel.addConstr(x <= 700, name=\"RouteXCapacity\")\nmodel.addConstr(y <= 600, name=\"RouteYCapacity\")\nmodel.addConstr(z <= 400, name=\"RouteZCapacity\")\n\n# Set the objective function\nmodel.setObjective(10*x + 15*y + 20*z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(\"Optimal allocations:\")\n    print(f\"Route X: {x.x}\")\n    print(f\"Route Y: {y.x}\")\n    print(f\"Route Z: {z.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 428d8c5a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    6 rows, 3 columns and 9 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 5000.000000000\nBest bound      : 5000.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total operating cost: 5000\nOptimal allocations:\nRoute X: 500.0\nRoute Y: 0.0\nRoute Z: 0.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- $x_i\\): Number of vehicles allocated to route \\(i\\), where \\(i \\in \\{X, Y, Z\\}\\).\n\nObjective Function:\n- Minimize total operating cost:  \n  \\[Z = 10x_X + 15x_Y + 20x_Z\\]\n\nConstraints:\n1. Traffic restrictions on routes X and Y:  \n   \\[x_X + x_Y \\leq 1000\\]\n2. Traffic restrictions on routes Y and Z:  \n   \\[x_Y + x_Z \\leq 800\\]\n3. Service level requirement for routes X and Z:  \n   \\[x_X + x_Z \\geq 500\\]\n4. Route capacity limits:  \n   \\[x_X \\leq 700\\]  \n   \\[x_Y \\leq 600\\]  \n   \\[x_Z \\leq 400\\]\n5. Non-negativity and integer constraints:  \n   \\[x_X, x_Y, x_Z \\geq 0 \\text{ and integers}\\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"TransportationAllocation\")\n\n# Define decision variables\nx_X = model.addVar(vtype=COPT.INTEGER, name=\"x_X\")\nx_Y = model.addVar(vtype=COPT.INTEGER, name=\"x_Y\")\nx_Z = model.addVar(vtype=COPT.INTEGER, name=\"x_Z\")\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestrictionXY\")\nmodel.addConstr(x_Y + x_Z <= 800, name=\"TrafficRestrictionYZ\")\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevelRequirement\")\nmodel.addConstr(x_X <= 700, name=\"CapacityLimitX\")\nmodel.addConstr(x_Y <= 600, name=\"CapacityLimitY\")\nmodel.addConstr(x_Z <= 400, name=\"CapacityLimitZ\")\n\n# Set the objective function\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(\"Optimal vehicle allocations:\")\n    print(f\"Route X: {x_X.x}\")\n    print(f\"Route Y: {x_Y.x}\")\n    print(f\"Route Z: {x_Z.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"TransportationAllocation\")\n\n# Define decision variables\nx_X = model.addVar(vtype=COPT.INTEGER, name=\"x_X\")\nx_Y = model.addVar(vtype=COPT.INTEGER, name=\"x_Y\")\nx_Z = model.addVar(vtype=COPT.INTEGER, name=\"x_Z\")\n\n# Add constraints\nmodel.addConstr(x_X + x_Y <= 1000, name=\"TrafficRestrictionXY\")\nmodel.addConstr(x_Y + x_Z <= 800, name=\"TrafficRestrictionYZ\")\nmodel.addConstr(x_X + x_Z >= 500, name=\"ServiceLevelRequirement\")\nmodel.addConstr(x_X <= 700, name=\"CapacityLimitX\")\nmodel.addConstr(x_Y <= 600, name=\"CapacityLimitY\")\nmodel.addConstr(x_Z <= 400, name=\"CapacityLimitZ\")\n\n# Set the objective function\nmodel.setObjective(10*x_X + 15*x_Y + 20*x_Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total operating cost: {:.0f}\".format(model.objval))\n    print(\"Optimal vehicle allocations:\")\n    print(f\"Route X: {x_X.x}\")\n    print(f\"Route Y: {x_Y.x}\")\n    print(f\"Route Z: {x_Z.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 428d8c5a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    6 rows, 3 columns and 9 non-zero elements\n    3 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 5000.000000000\nBest bound      : 5000.000000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total operating cost: 5000\nOptimal vehicle allocations:\nRoute X: 500.0\nRoute Y: 0.0\nRoute Z: 0.0",
        "pass": true
      }
    ],
    "answer": 4018.0,
    "cloze": "A company produces two kinds of products. A product of the first type requires ____ hours of assembly labor, ____ hours of testing, and $____ worth of raw materials. A product of the second type requires ____ hours of assembly, ____ hours of testing, and $____ worth of raw materials. Given the current personnel of the company, there can be ____ ____ hours of assembly labor and ____ hours of testing each day. Suppose that ____ ____ hours of overtime assembly labor can be scheduled, at a cost of $____ per hour. Products of the first and second type have a market value of $____ and $____ respectively. Try to ____ the daily profit of the company. Provide your answer rounded to the nearest dollar."
  },
  {
    "question": "A manufacturing company produces three types of electronic components: A, B, and C. The company has four different production lines, each capable of producing these components with varying efficiencies. The company needs to produce at least 1000 units of component A, 800 units of component B, and 1200 units of component C daily. The production lines can only be operated if at least 5 workers are assigned. Please determine the minimum production time to meet the daily demand. The production rates for each component by each worker on different lines are given in the following Table.\n\n| Line | Component A | Component B | Component C |\n|------|-------------|-------------|-------------|\n| 1    | 10 units/hr | 5 units/hr  | 15 units/hr |\n| 2    | 8 units/hr  | 10 units/hr | 12 units/hr |\n| 3    | 12 units/hr | 6 units/hr  | 10 units/hr |\n| 4    | 15 units/hr | 8 units/hr  | 5 units/hr  |\n\nThere are total 50 workers available. Each production line can be utilized by up to 15 workers at a time. Each production line must have at least 5 workers to operate. The objective function is to minimize the maximum production time for components A, B, and C, which is defined as:\n- The production time for component A: T_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n- The production time for component B: T_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n- The production time for component C: T_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n- The objective is to minimize max(T_A, T_B, T_C).\n",
    "pass_count": 4,
    "pass_rate": 0.5,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_1\\): Fraction of investment 1 purchased by Star Oil.  \n- \\(x_2\\): Fraction of investment 2 purchased by Star Oil.  \n- \\(x_3\\): Fraction of investment 3 purchased by Star Oil.  \n- \\(x_4\\): Fraction of investment 4 purchased by Star Oil.  \n- \\(x_5\\): Fraction of investment 5 purchased by Star Oil.  \n\nObjective Function:  \n- Maximize the total net present value (NPV) that can be obtained:  \n  \\[Z = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\\]  \n\nConstraints:  \n1. Investment budget at time 0:  \n   \\[11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\\]  \n2. Investment budget at time 1:  \n   \\[3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\\]  \n3. Non-negativity:  \n   \\[x_1, x_2, x_3, x_4, x_5 \\geq 0\\]  \n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- Let \\(x_i\\) represent the fraction of investment opportunity \\(i\\) (where \\(i = 1, 2, 3, 4, 5\\)) that Star Oil decides to purchase. Each \\(x_i\\) is a non-negative real number.\n\nObjective Function:\n- Maximize the total net present value (NPV):\n  \\[\n  Z = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\n  \\]\n\nConstraints:\n1. Time 0 cash outflow constraint:\n   \\[\n   11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\n   \\]\n2. Time 1 cash outflow constraint:\n   \\[\n   3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\n   \\]\n3. Non-negativity constraints:\n   \\[\n   x_i \\geq 0 \\quad \\text{for all } i\n   \\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"StarOilInvestment\")\n\n# Decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Fraction of Investment 1\nx2 = model.addVar(lb=0, name=\"x2\")  # Fraction of Investment 2\nx3 = model.addVar(lb=0, name=\"x3\")  # Fraction of Investment 3\nx4 = model.addVar(lb=0, name=\"x4\")  # Fraction of Investment 4\nx5 = model.addVar(lb=0, name=\"x5\")  # Fraction of Investment 5\n\n# Objective function: Maximize NPV\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0CashOutflow\")  # Time 0 cash outflow constraint\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1CashOutflow\")  # Time 1 cash outflow constraint\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total net present value: {:.2f} million dollars\".format(model.objval))\n    print(f\"Fraction of Investment 1: {x1.x:.2f}\")\n    print(f\"Fraction of Investment 2: {x2.x:.2f}\")\n    print(f\"Fraction of Investment 3: {x3.x:.2f}\")\n    print(f\"Fraction of Investment 4: {x4.x:.2f}\")\n    print(f\"Fraction of Investment 5: {x5.x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"StarOilInvestment\")\n\n# Decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Fraction of Investment 1\nx2 = model.addVar(lb=0, name=\"x2\")  # Fraction of Investment 2\nx3 = model.addVar(lb=0, name=\"x3\")  # Fraction of Investment 3\nx4 = model.addVar(lb=0, name=\"x4\")  # Fraction of Investment 4\nx5 = model.addVar(lb=0, name=\"x5\")  # Fraction of Investment 5\n\n# Objective function: Maximize NPV\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0CashOutflow\")  # Time 0 cash outflow constraint\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1CashOutflow\")  # Time 1 cash outflow constraint\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized total net present value: {:.2f} million dollars\".format(model.objval))\n    print(f\"Fraction of Investment 1: {x1.x:.2f}\")\n    print(f\"Fraction of Investment 2: {x2.x:.2f}\")\n    print(f\"Fraction of Investment 3: {x3.x:.2f}\")\n    print(f\"Fraction of Investment 4: {x4.x:.2f}\")\n    print(f\"Fraction of Investment 5: {x5.x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: bf03dec4\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    2 rows, 5 columns and 10 non-zero elements\nThe presolved problem has:\n    2 rows, 5 columns and 10 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    2.5977644480e+02            2           0       0.00s\nDual             2    1.1800074236e+02            0           0       0.00s\nPostsolving\nDual             2    1.1800000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.1800000000e+02  Iterations: 2  Time: 0.00s\nMaximized total net present value: 118.00 million dollars\nFraction of Investment 1: 0.00\nFraction of Investment 2: 0.00\nFraction of Investment 3: 3.00\nFraction of Investment 4: 5.00\nFraction of Investment 5: 0.00",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): The fraction of investment opportunity \\(i\\) (where \\(i = 1, 2, 3, 4, 5\\)) purchased by Star Oil. The value of \\(x_i\\) ranges from 0 to 1, as only fractional shares of each investment can be purchased.\n\nObjective Function:\n- Maximize the total NPV:  \n  \\[Z = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\\]\n\nConstraints:\n1. Time 0 cash outflow constraint:  \n   \\[11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\\]  \n   This constraint ensures that the total cash outflow at time 0 does not exceed the available funds of $40 million.\n2. Time 1 cash outflow constraint:  \n   \\[3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\\]  \n   This constraint ensures that the total cash outflow at time 1 does not exceed the estimated available funds of $20 million.\n3. Non-negativity constraint:  \n   \\[x_i \\geq 0 \\quad \\forall i = 1, 2, 3, 4, 5\\]  \n   This constraint ensures that the fractions of investments purchased are non-negative.\n4. Upper bound constraint:  \n   \\[x_i \\leq 1 \\quad \\forall i = 1, 2, 3, 4, 5\\]  \n   This constraint ensures that Star Oil cannot purchase more than 100% of any investment.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model for the Star Oil investment problem\nmodel = env.createModel(\"StarOilInvestmentProblem\")\n\n# Define the investment opportunities and their cash outflows and net present values\ninvestments = [1, 2, 3, 4, 5]\ncash_outflows_time_0 = [11, 53, 5, 5, 29]\ncash_outflows_time_1 = [3, 6, 5, 1, 34]\nnpvs = [13, 16, 16, 14, 39]\n\n# Add decision variables\nx = {i: model.addVar(lb=0, ub=1, name=f\"x_{i}\") for i in investments}\n\n# Add constraints\nmodel.addConstr(cp.quicksum(cash_outflows_time_0[i] * x[i] for i in investments) <= 40, name=\"Time0CashOutflow\")\nmodel.addConstr(cp.quicksum(cash_outflows_time_1[i] * x[i] for i in investments) <= 20, name=\"Time1CashOutflow\")\n\n# Set the objective function to maximize total NPV\nmodel.setObjective(cp.quicksum(npvs[i] * x[i] for i in investments), sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum NPV (in million dollars): {}\".format(round(model.objval, 2)))\n    print(\"Fraction of each investment opportunity purchased:\")\n    for i in investments:\n        print(f\"Investment {i}: {x[i].x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model for the Star Oil investment problem\nmodel = env.createModel(\"StarOilInvestmentProblem\")\n\n# Define the investment opportunities and their cash outflows and net present values\ninvestments = [1, 2, 3, 4, 5]\ncash_outflows_time_0 = [11, 53, 5, 5, 29]\ncash_outflows_time_1 = [3, 6, 5, 1, 34]\nnpvs = [13, 16, 16, 14, 39]\n\n# Add decision variables\nx = {i: model.addVar(lb=0, ub=1, name=f\"x_{i}\") for i in investments}\n\n# Add constraints\nmodel.addConstr(cp.quicksum(cash_outflows_time_0[i] * x[i] for i in investments) <= 40, name=\"Time0CashOutflow\")\nmodel.addConstr(cp.quicksum(cash_outflows_time_1[i] * x[i] for i in investments) <= 20, name=\"Time1CashOutflow\")\n\n# Set the objective function to maximize total NPV\nmodel.setObjective(cp.quicksum(npvs[i] * x[i] for i in investments), sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Analyze the solution\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum NPV (in million dollars): {}\".format(round(model.objval, 2)))\n    print(\"Fraction of each investment opportunity purchased:\")\n    for i in investments:\n        print(f\"Investment {i}: {x[i].x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "[Error: HTTPConnectionPool(host='47.98.187.25', port=8000): Read timed out. (read timeout=30)]",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_i\\): Fraction of investment \\(i\\) to be made, where \\(i \\in \\{1, 2, 3, 4, 5\\}\\).  \n\nObjective Function:  \nMaximize the total NPV:  \n\\[\nZ = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\n\\]  \n\nConstraints:  \n1. Budget constraint at time 0:  \n\\[\n11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\n\\]  \n2. Budget constraint at time 1:  \n\\[\n3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\n\\]  \n3. Non-negativity constraints:  \n\\[\nx_i \\geq 0 \\quad \\forall i \\in \\{1, 2, 3, 4, 5\\}\n\\]  \n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- x_i: The fraction of investment i that Star Oil should purchase for i ∈ {1, 2, 3, 4, 5}.\n\nObjective Function:\n- Maximize Z = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5 (NPV in million dollars).\n\nConstraints:\n1. Time 0 cash outflow constraint: 11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 ≤ 40.\n2. Time 1 cash outflow constraint: 3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 ≤ 20.\n3. Non-negativity and boundedness: 0 ≤ x_i ≤ 1 for all i ∈ {1, 2, 3, 4, 5}.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"StarOilInvestmentOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, ub=1, name=\"x1\")  # Fraction of investment 1\nx2 = model.addVar(lb=0, ub=1, name=\"x2\")  # Fraction of investment 2\nx3 = model.addVar(lb=0, ub=1, name=\"x3\")  # Fraction of investment 3\nx4 = model.addVar(lb=0, ub=1, name=\"x4\")  # Fraction of investment 4\nx5 = model.addVar(lb=0, ub=1, name=\"x5\")  # Fraction of investment 5\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0CashOutflowConstraint\")  # Time 0 cash outflow constraint\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1CashOutflowConstraint\")  # Time 1 cash outflow constraint\n\n# Set the objective function\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized NPV: {:.2f} million dollars\".format(model.objval))\n    print(\"Optimal investment fractions:\")\n    print(f\"Investment 1: {x1.x:.2f}\")\n    print(f\"Investment 2: {x2.x:.2f}\")\n    print(f\"Investment 3: {x3.x:.2f}\")\n    print(f\"Investment 4: {x4.x:.2f}\")\n    print(f\"Investment 5: {x5.x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"StarOilInvestmentOptimization\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, ub=1, name=\"x1\")  # Fraction of investment 1\nx2 = model.addVar(lb=0, ub=1, name=\"x2\")  # Fraction of investment 2\nx3 = model.addVar(lb=0, ub=1, name=\"x3\")  # Fraction of investment 3\nx4 = model.addVar(lb=0, ub=1, name=\"x4\")  # Fraction of investment 4\nx5 = model.addVar(lb=0, ub=1, name=\"x5\")  # Fraction of investment 5\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0CashOutflowConstraint\")  # Time 0 cash outflow constraint\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1CashOutflowConstraint\")  # Time 1 cash outflow constraint\n\n# Set the objective function\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized NPV: {:.2f} million dollars\".format(model.objval))\n    print(\"Optimal investment fractions:\")\n    print(f\"Investment 1: {x1.x:.2f}\")\n    print(f\"Investment 2: {x2.x:.2f}\")\n    print(f\"Investment 3: {x3.x:.2f}\")\n    print(f\"Investment 4: {x4.x:.2f}\")\n    print(f\"Investment 5: {x5.x:.2f}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 79f1f97a\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    2 rows, 5 columns and 10 non-zero elements\nThe presolved problem has:\n    2 rows, 5 columns and 10 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    7.8239291006e+01            2           0       0.00s\nDual             2    5.7449654763e+01            0           0       0.00s\nPostsolving\nDual             2    5.7449017199e+01            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 5.7449017199e+01  Iterations: 2  Time: 0.00s\nMaximized NPV: 57.45 million dollars\nOptimal investment fractions:\nInvestment 1: 1.00\nInvestment 2: 0.20\nInvestment 3: 1.00\nInvestment 4: 1.00\nInvestment 5: 0.29",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): The proportion of investment \\(i\\) that Star Oil Company purchases, where \\(i = 1, 2, 3, 4, 5\\). This represents the fraction of each investment that Star Oil decides to invest in.\n\nObjective Function:\nMaximize the total net present value (NPV) of the investments:\n\\[\nZ = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\n\\]\n\nConstraints:\n1. Time 0 cash outflow constraint:\n\\[\n11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\n\\]\n2. Time 1 cash outflow constraint:\n\\[\n3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\n\\]\n3. Non-negativity constraint:\n\\[\nx_i \\geq 0 \\quad \\text{for all } i\n\\]\n4. Proportionality constraint:\n\\[\nx_i \\leq 1 \\quad \\text{for all } i\n\\]\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): The fraction of investment \\(i\\) (for \\(i = 1, 2, 3, 4, 5\\)) that Star Oil decides to purchase. These are continuous variables representing the proportion of each investment made.\n\nObjective Function:\nMaximize total Net Present Value (NPV):\n\\[\nZ = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\n\\]\n\nConstraints:\n1. Available funds at time 0: \n   \\[\n   11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\n   \\]\n2. Available funds at time 1: \n   \\[\n   3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\n   \\]\n3. Non-negativity constraints:\n   \\[\n   x_i \\geq 0 \\quad \\text{for all } i\n   \\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model for the Star Oil Company investment problem\nmodel = env.createModel(\"StarOilInvestment\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Fraction of investment 1\nx2 = model.addVar(lb=0, name=\"x2\")  # Fraction of investment 2\nx3 = model.addVar(lb=0, name=\"x3\")  # Fraction of investment 3\nx4 = model.addVar(lb=0, name=\"x4\")  # Fraction of investment 4\nx5 = model.addVar(lb=0, name=\"x5\")  # Fraction of investment 5\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0Funds\")\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1Funds\")\n\n# Set the objective function\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized NPV: {:.2f} million dollars\".format(model.objval))\n    print(\"Optimal investment fractions:\")\n    print(\"Investment 1: {:.2f}\".format(x1.x))\n    print(\"Investment 2: {:.2f}\".format(x2.x))\n    print(\"Investment 3: {:.2f}\".format(x3.x))\n    print(\"Investment 4: {:.2f}\".format(x4.x))\n    print(\"Investment 5: {:.2f}\".format(x5.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model for the Star Oil Company investment problem\nmodel = env.createModel(\"StarOilInvestment\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Fraction of investment 1\nx2 = model.addVar(lb=0, name=\"x2\")  # Fraction of investment 2\nx3 = model.addVar(lb=0, name=\"x3\")  # Fraction of investment 3\nx4 = model.addVar(lb=0, name=\"x4\")  # Fraction of investment 4\nx5 = model.addVar(lb=0, name=\"x5\")  # Fraction of investment 5\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0Funds\")\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1Funds\")\n\n# Set the objective function\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximized NPV: {:.2f} million dollars\".format(model.objval))\n    print(\"Optimal investment fractions:\")\n    print(\"Investment 1: {:.2f}\".format(x1.x))\n    print(\"Investment 2: {:.2f}\".format(x2.x))\n    print(\"Investment 3: {:.2f}\".format(x3.x))\n    print(\"Investment 4: {:.2f}\".format(x4.x))\n    print(\"Investment 5: {:.2f}\".format(x5.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: bf03dec4\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    2 rows, 5 columns and 10 non-zero elements\nThe presolved problem has:\n    2 rows, 5 columns and 10 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    2.5977644480e+02            2           0       0.00s\nDual             2    1.1800074236e+02            0           0       0.00s\nPostsolving\nDual             2    1.1800000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.1800000000e+02  Iterations: 2  Time: 0.00s\nMaximized NPV: 118.00 million dollars\nOptimal investment fractions:\nInvestment 1: 0.00\nInvestment 2: 0.00\nInvestment 3: 3.00\nInvestment 4: 5.00\nInvestment 5: 0.00",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\(x_i\\): the fraction of investment opportunity \\(i\\) (for \\(i = 1, 2, 3, 4, 5\\)) that Star Oil will invest in, where \\(x_i \\geq 0\\).\n\nObjective Function:  \n- Maximize the net present value (NPV) of the investments:  \n  \\[Z = 13x_1 + 16x_2 + 16x_3 + 14x_4 + 39x_5\\]\n\nConstraints:  \n1. Cash outflow at time 0 cannot exceed the available funds at time 0:  \n   \\[11x_1 + 53x_2 + 5x_3 + 5x_4 + 29x_5 \\leq 40\\]\n2. Cash outflow at time 1 cannot exceed the available funds at time 1:  \n   \\[3x_1 + 6x_2 + 5x_3 + 1x_4 + 34x_5 \\leq 20\\]\n3. Non-negativity constraints:  \n   \\[x_i \\geq 0 \\quad \\text{for all } i = 1, 2, 3, 4, 5\\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"StarOilInvestment\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Fraction of investment opportunity 1\nx2 = model.addVar(lb=0, name=\"x2\")  # Fraction of investment opportunity 2\nx3 = model.addVar(lb=0, name=\"x3\")  # Fraction of investment opportunity 3\nx4 = model.addVar(lb=0, name=\"x4\")  # Fraction of investment opportunity 4\nx5 = model.addVar(lb=0, name=\"x5\")  # Fraction of investment opportunity 5\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0Constraint\")  # Cash outflow at time 0\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1Constraint\")  # Cash outflow at time 1\n\n# Set the objective function\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum NPV: {:.2f} million dollars\".format(model.objval))\n    print(\"Investment allocation:\")\n    print(\"Investment 1: {:.2f}\".format(x1.x))\n    print(\"Investment 2: {:.2f}\".format(x2.x))\n    print(\"Investment 3: {:.2f}\".format(x3.x))\n    print(\"Investment 4: {:.2f}\".format(x4.x))\n    print(\"Investment 5: {:.2f}\".format(x5.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"StarOilInvestment\")\n\n# Add decision variables\nx1 = model.addVar(lb=0, name=\"x1\")  # Fraction of investment opportunity 1\nx2 = model.addVar(lb=0, name=\"x2\")  # Fraction of investment opportunity 2\nx3 = model.addVar(lb=0, name=\"x3\")  # Fraction of investment opportunity 3\nx4 = model.addVar(lb=0, name=\"x4\")  # Fraction of investment opportunity 4\nx5 = model.addVar(lb=0, name=\"x5\")  # Fraction of investment opportunity 5\n\n# Add constraints\nmodel.addConstr(11*x1 + 53*x2 + 5*x3 + 5*x4 + 29*x5 <= 40, name=\"Time0Constraint\")  # Cash outflow at time 0\nmodel.addConstr(3*x1 + 6*x2 + 5*x3 + 1*x4 + 34*x5 <= 20, name=\"Time1Constraint\")  # Cash outflow at time 1\n\n# Set the objective function\nmodel.setObjective(13*x1 + 16*x2 + 16*x3 + 14*x4 + 39*x5, sense=COPT.MAXIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Maximum NPV: {:.2f} million dollars\".format(model.objval))\n    print(\"Investment allocation:\")\n    print(\"Investment 1: {:.2f}\".format(x1.x))\n    print(\"Investment 2: {:.2f}\".format(x2.x))\n    print(\"Investment 3: {:.2f}\".format(x3.x))\n    print(\"Investment 4: {:.2f}\".format(x4.x))\n    print(\"Investment 5: {:.2f}\".format(x5.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: bf03dec4\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMaximizing an LP problem\n\nThe original problem has:\n    2 rows, 5 columns and 10 non-zero elements\nThe presolved problem has:\n    2 rows, 5 columns and 10 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    2.5977644480e+02            2           0       0.00s\nDual             2    1.1800074236e+02            0           0       0.00s\nPostsolving\nDual             2    1.1800000000e+02            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 1.1800000000e+02  Iterations: 2  Time: 0.00s\nMaximum NPV: 118.00 million dollars\nInvestment allocation:\nInvestment 1: 0.00\nInvestment 2: 0.00\nInvestment 3: 3.00\nInvestment 4: 5.00\nInvestment 5: 0.00",
        "pass": true
      }
    ],
    "answer": 2.18,
    "cloze": "A manufacturing company produces three types of electronic components: A, B, and C. The company has four different production lines, each capable of producing these components with varying efficiencies. The company needs to produce ____ ____ units of component A, ____ units of component B, and ____ units of component C daily. The production lines can only be operated if at least ____ workers are assigned. Please determine the ____ production time to meet the daily demand. The production rates for each component by each worker on different lines are given in the following Table.\n\n| Line | Component A | Component B | Component C |\n|------|-------------|-------------|-------------|\n| 1    | ____ units/hr | ____ units/hr  | ____ units/hr |\n| 2    | ____ units/hr  | ____ units/hr | ____ units/hr |\n| 3    | ____ units/hr | ____ units/hr  | ____ units/hr |\n| 4    | ____ units/hr | ____ units/hr  | ____ units/hr |\n\nThere are total ____ workers available. Each production line can be utilized by ____ ____ workers at a time. Each production line must have ____ ____ workers to operate. The objective function is to ____ the maximum production time for components A, B, and C, which is defined as:\n- The production time for component A: T_A = ____ / (____ * W1 + ____ * W2 + ____ * W3 + ____ * W4)\n- The production time for component B: T_B = ____ / (____ * W1 + ____ * W2 + ____ * W3 + ____ * W4)\n- The production time for component C: T_C = ____ / (____ * W1 + ____ * W2 + ____ * W3 + ____ * W4)\n- The objective is to ____ max(T_A, T_B, T_C)."
  },
  {
    "question": "A bubble tea shop sells mango and lychee bubble tea. Each mango bubble tea requires 4 units of mango juice and 8 units of tea. Each lychee bubble tea requires 6 units of lychee juice and 6 units of tea. The shop has available 2000 units of mango juice and 3000 units of lychee juice. At least 40% of the bubble teas made must be lychee flavored. However, mango bubble tea sells better and thus the number of mango bubble teas made must be large than the number of lychee bubble teas made. How many of each bubble tea flavor should be made to minimize the total amount of tea needed?",
    "pass_count": 4,
    "pass_rate": 0.5,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- \\(X1\\): Investment amount in asset X1, an integer.\n- \\(X2\\): Investment amount in asset X2, an integer.\n- \\(X3\\): Investment amount in asset X3, an integer.\n- \\(X4\\): Investment amount in asset X4, an integer.\n\nObjective Function:\nMinimize total investment cost:\n\\(Z = 0.05 \\times X1 + 0.08 \\times X2 + 0.12 \\times X3 + 0.15 \\times X4\\)\n\nConstraints:\n1. Total investment budget constraint: \\(X1 + X2 + X3 + X4 \\leq 100000\\)\n2. Minimum and maximum investment limits:\n   - \\(10000 \\leq X1 \\leq 60000\\)\n   - \\(20000 \\leq X2 \\leq 80000\\)\n   - \\(15000 \\leq X3 \\leq 50000\\)\n   - \\(X4 \\geq 200\\)\n3. Portfolio diversification constraints:\n   - \\(0.6 \\times X1 - 0.4 \\times X2 \\geq 0\\)\n   - \\(X3 + X4 - (X1 + X2) \\geq -30000\\)\n   - \\(0.7 \\times X3 - 0.5 \\times X4 \\leq 500\\)\n\nNon-negativity and integer constraints:\n- \\(X1, X2, X3, X4 \\geq 0\\) and integers.\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- $x1\\): Investment in asset \\(X1\\), integer.  \n- \\(x2\\): Investment in asset \\(X2\\), integer.  \n- \\(x3\\): Investment in asset \\(X3\\), integer.  \n- \\(x4\\): Investment in asset \\(X4\\), integer.  \n\nObjective Function:  \nMinimize total cost:  \n\\(Z = 0.05 \\times x1 + 0.08 \\times x2 + 0.12 \\times x3 + 0.15 \\times x4\\)\n\nConstraints:  \n1. Budget constraint:  \n   \\(x1 + x2 + x3 + x4 \\leq 100000\\)  \n2. Investment range constraints:  \n   \\(10000 \\leq x1 \\leq 60000\\)  \n   \\(20000 \\leq x2 \\leq 80000\\)  \n   \\(15000 \\leq x3 \\leq 50000\\)  \n   \\(x4 \\geq 200\\)  \n3. Non-negativity and integer constraints:  \n   \\(x1, x2, x3, x4 \\geq 0\\) and integer.  \n4. Additional constraints:  \n   \\(0.6 \\times x1 - 0.4 \\times x2 \\geq 0\\)  \n   \\(x3 + x4 - x1 - x2 \\geq -30000\\)  \n   \\(0.7 \\times x3 - 0.5 \\times x4 \\leq 500\\)\n</model>",
        "code": "",
        "exec_output": "Error: Execution timeout",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_1\\): Investment amount in asset \\(X1\\), integer.\n- \\(x_2\\): Investment amount in asset \\(X2\\), integer.\n- \\(x_3\\): Investment amount in asset \\(X3\\), integer.\n- \\(x_4\\): Investment amount in asset \\(X4\\), integer.\n\nObjective Function:\n- Minimize total cost:  \n  \\[Z = 0.05x_1 + 0.08x_2 + 0.12x_3 + 0.15x_4\\]\n\nConstraints:\n1. Total investment limit:  \n   \\[x_1 + x_2 + x_3 + x_4 \\leq 100000\\]\n2. Investment range for asset \\(X1\\):  \n   \\[10000 \\leq x_1 \\leq 60000\\]\n3. Investment range for asset \\(X2\\):  \n   \\[20000 \\leq x_2 \\leq 80000\\]\n4. Investment range for asset \\(X3\\):  \n   \\[15000 \\leq x_3 \\leq 50000\\]\n5. Investment range for asset \\(X4\\):  \n   \\[x_4 \\geq 200\\]\n6. Condition on investment differences:  \n   \\[0.6x_1 - 0.4x_2 \\geq 0\\]\n7. Condition on investment sum:  \n   \\[x_3 + x_4 \\geq x_1 + x_2 - 30000\\]\n8. Condition on investment differences:  \n   \\[0.7x_3 - 0.5x_4 \\leq 500\\]\n\nNon-negativity and Integer Constraints:  \n- \\(x_1, x_2, x_3, x_4 \\geq 0\\) and integer.\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x_i\\): The amount of investment in asset \\(i\\), where \\(i \\in \\{X1, X2, X3, X4\\}\\).\n\nObjective Function:\n- Minimize total cost: \\(Z = 0.05x_{X1} + 0.08x_{X2} + 0.12x_{X3} + 0.15x_{X4}\\).\n\nConstraints:\n1. Budget constraint: \\(x_{X1} + x_{X2} + x_{X3} + x_{X4} \\leq 100000\\).\n2. Minimum investment in asset \\(X1\\): \\(x_{X1} \\geq 10000\\).\n3. Maximum investment in asset \\(X1\\): \\(x_{X1} \\leq 60000\\).\n4. Minimum investment in asset \\(X2\\): \\(x_{X2} \\geq 20000\\).\n5. Maximum investment in asset \\(X2\\): \\(x_{X2} \\leq 80000\\).\n6. Minimum investment in asset \\(X3\\): \\(x_{X3} \\geq 15000\\).\n7. Maximum investment in asset \\(X3\\): \\(x_{X3} \\leq 50000\\).\n8. Minimum investment in asset \\(X4\\): \\(x_{X4} \\geq 200\\).\n9. Non-negativity and integer constraints: \\(x_i \\geq 0\\) and integer for all \\(i\\).\n10. Condition 1: \\(0.6x_{X1} - 0.4x_{X2} \\geq 0\\).\n11. Condition 2: \\(x_{X3} + x_{X4} - x_{X1} - x_{X2} \\geq -30000\\).\n12. Condition 3: \\(0.7x_{X3} - 0.5x_{X4} \\leq 500\\).\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"PortfolioManagement\")\n\n# Add decision variables\nx_X1 = model.addVar(lb=10000, ub=60000, name=\"x_X1\")\nx_X2 = model.addVar(lb=20000, ub=80000, name=\"x_X2\")\nx_X3 = model.addVar(lb=15000, ub=50000, name=\"x_X3\")\nx_X4 = model.addVar(lb=200, name=\"x_X4\")\n\n# Add constraints\nmodel.addConstr(x_X1 + x_X2 + x_X3 + x_X4 <= 100000, name=\"BudgetConstraint\")\nmodel.addConstr(0.6*x_X1 - 0.4*x_X2 >= 0, name=\"Condition1\")\nmodel.addConstr(x_X3 + x_X4 - x_X1 - x_X2 >= -30000, name=\"Condition2\")\nmodel.addConstr(0.7*x_X3 - 0.5*x_X4 <= 500, name=\"Condition3\")\n\n# Set the objective function\nmodel.setObjective(0.05*x_X1 + 0.08*x_X2 + 0.12*x_X3 + 0.15*x_X4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total cost: {:.2f}\".format(model.objval))\n    print(\"Optimal investment amounts:\")\n    print(f\"Asset X1: {x_X1.x}\")\n    print(f\"Asset X2: {x_X2.x}\")\n    print(f\"Asset X3: {x_X3.x}\")\n    print(f\"Asset X4: {x_X4.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"PortfolioManagement\")\n\n# Add decision variables\nx_X1 = model.addVar(lb=10000, ub=60000, name=\"x_X1\")\nx_X2 = model.addVar(lb=20000, ub=80000, name=\"x_X2\")\nx_X3 = model.addVar(lb=15000, ub=50000, name=\"x_X3\")\nx_X4 = model.addVar(lb=200, name=\"x_X4\")\n\n# Add constraints\nmodel.addConstr(x_X1 + x_X2 + x_X3 + x_X4 <= 100000, name=\"BudgetConstraint\")\nmodel.addConstr(0.6*x_X1 - 0.4*x_X2 >= 0, name=\"Condition1\")\nmodel.addConstr(x_X3 + x_X4 - x_X1 - x_X2 >= -30000, name=\"Condition2\")\nmodel.addConstr(0.7*x_X3 - 0.5*x_X4 <= 500, name=\"Condition3\")\n\n# Set the objective function\nmodel.setObjective(0.05*x_X1 + 0.08*x_X2 + 0.12*x_X3 + 0.15*x_X4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total cost: {:.2f}\".format(model.objval))\n    print(\"Optimal investment amounts:\")\n    print(f\"Asset X1: {x_X1.x}\")\n    print(f\"Asset X2: {x_X2.x}\")\n    print(f\"Asset X3: {x_X3.x}\")\n    print(f\"Asset X4: {x_X4.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 52a6e85f\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing an LP problem\n\nThe original problem has:\n    4 rows, 4 columns and 12 non-zero elements\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    7.0668521816e+03            1           0       0.00s\nDual             1    7.0668671817e+03            0           0       0.00s\nPostsolving\nDual             1    7.0666666667e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 7.0666666667e+03  Iterations: 1  Time: 0.00s\nMinimum total cost: 7066.67\nOptimal investment amounts:\nAsset X1: 13333.333333333334\nAsset X2: 20000.0\nAsset X3: 15000.0\nAsset X4: 20000.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- $x1\\): Investment amount in asset X1 (in dollars)\n- \\(x2\\): Investment amount in asset X2 (in dollars)\n- \\(x3\\): Investment amount in asset X3 (in dollars)\n- \\(x4\\): Investment amount in asset X4 (in dollars)\n\nObjective Function:\nMinimize total investment cost: \n\\(Z = 0.05 \\cdot x1 + 0.08 \\cdot x2 + 0.12 \\cdot x3 + 0.15 \\cdot x4\\)\n\nConstraints:\n1. Budget constraint: \\(x1 + x2 + x3 + x4 \\leq 100000\\)\n2. Minimum and maximum investment limits:\n   - \\(10000 \\leq x1 \\leq 60000\\)\n   - \\(20000 \\leq x2 \\leq 80000\\)\n   - \\(15000 \\leq x3 \\leq 50000\\)\n   - \\(x4 \\geq 200\\)\n3. Condition on X1 and X2: \\(0.6 \\cdot x1 - 0.4 \\cdot x2 \\geq 0\\)\n4. Condition on X3 and X4: \\(x3 + x4 - x1 - x2 \\geq -30000\\)\n5. Condition on X3 and X4: \\(0.7 \\cdot x3 - 0.5 \\cdot x4 \\leq 500\\)\n6. Non-negativity and integer constraints: \\(x1, x2, x3, x4 \\geq 0\\) and integer.\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(X1, X2, X3, X4\\): Integer investment amounts in assets \\(X1, X2, X3, X4\\), respectively, in dollars.\n\nObjective Function:\n- Minimize total cost: \\(Z = 0.05X1 + 0.08X2 + 0.12X3 + 0.15X4\\)\n\nConstraints:\n1. Budget constraint: \\(X1 + X2 + X3 + X4 \\leq 100000\\)\n2. Investment range for asset \\(X1\\): \\(10000 \\leq X1 \\leq 60000\\)\n3. Investment range for asset \\(X2\\): \\(20000 \\leq X2 \\leq 80000\\)\n4. Investment range for asset \\(X3\\): \\(15000 \\leq X3 \\leq 50000\\)\n5. Investment range for asset \\(X4\\): \\(200 \\leq X4\\)\n6. Non-negativity constraint for asset investment difference: \\(0.6X1 - 0.4X2 \\geq 0\\)\n7. Investment range constraint for assets \\(X3\\) and \\(X4\\): \\(X3 + X4 \\geq X1 + X2 - 30000\\)\n8. Investment range constraint for assets \\(X3\\) and \\(X4\\): \\(0.7X3 - 0.5X4 \\leq 500\\)\n9. Non-negativity and integer constraints: \\(X1, X2, X3, X4 \\geq 0\\) and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"PortfolioOptimization\")\n\n# Define decision variables\nX1 = model.addVar(lb=10000, ub=60000, name=\"X1\")  # Investment amount in asset X1\nX2 = model.addVar(lb=20000, ub=80000, name=\"X2\")  # Investment amount in asset X2\nX3 = model.addVar(lb=15000, ub=50000, name=\"X3\")  # Investment amount in asset X3\nX4 = model.addVar(lb=200, name=\"X4\")  # Investment amount in asset X4\n\n# Add constraints\nmodel.addConstr(X1 + X2 + X3 + X4 <= 100000, name=\"BudgetConstraint\")  # Budget constraint\nmodel.addConstr(0.6 * X1 - 0.4 * X2 >= 0, name=\"InvestmentDifferenceConstraint\")  # Non-negativity constraint for asset investment difference\nmodel.addConstr(X3 + X4 >= X1 + X2 - 30000, name=\"InvestmentRangeConstraint1\")  # Investment range constraint for assets X3 and X4\nmodel.addConstr(0.7 * X3 - 0.5 * X4 <= 500, name=\"InvestmentRangeConstraint2\")  # Investment range constraint for assets X3 and X4\n\n# Set the objective function\nmodel.setObjective(0.05 * X1 + 0.08 * X2 + 0.12 * X3 + 0.15 * X4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total cost: {:.2f}\".format(model.objval))\n    print(f\"Optimal investment amounts: X1={X1.x}, X2={X2.x}, X3={X3.x}, X4={X4.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"PortfolioOptimization\")\n\n# Define decision variables\nX1 = model.addVar(lb=10000, ub=60000, name=\"X1\")  # Investment amount in asset X1\nX2 = model.addVar(lb=20000, ub=80000, name=\"X2\")  # Investment amount in asset X2\nX3 = model.addVar(lb=15000, ub=50000, name=\"X3\")  # Investment amount in asset X3\nX4 = model.addVar(lb=200, name=\"X4\")  # Investment amount in asset X4\n\n# Add constraints\nmodel.addConstr(X1 + X2 + X3 + X4 <= 100000, name=\"BudgetConstraint\")  # Budget constraint\nmodel.addConstr(0.6 * X1 - 0.4 * X2 >= 0, name=\"InvestmentDifferenceConstraint\")  # Non-negativity constraint for asset investment difference\nmodel.addConstr(X3 + X4 >= X1 + X2 - 30000, name=\"InvestmentRangeConstraint1\")  # Investment range constraint for assets X3 and X4\nmodel.addConstr(0.7 * X3 - 0.5 * X4 <= 500, name=\"InvestmentRangeConstraint2\")  # Investment range constraint for assets X3 and X4\n\n# Set the objective function\nmodel.setObjective(0.05 * X1 + 0.08 * X2 + 0.12 * X3 + 0.15 * X4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total cost: {:.2f}\".format(model.objval))\n    print(f\"Optimal investment amounts: X1={X1.x}, X2={X2.x}, X3={X3.x}, X4={X4.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 52a6e85f\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing an LP problem\n\nThe original problem has:\n    4 rows, 4 columns and 12 non-zero elements\nThe presolved problem has:\n    2 rows, 2 columns and 4 non-zero elements\n\nStarting the simplex solver using up to 4 threads\n\nMethod   Iteration           Objective  Primal.NInf   Dual.NInf        Time\nDual             0    7.0668521816e+03            1           0       0.00s\nDual             1    7.0668671817e+03            0           0       0.00s\nPostsolving\nDual             1    7.0666666667e+03            0           0       0.00s\n\nSolving finished\nStatus: Optimal  Objective: 7.0666666667e+03  Iterations: 1  Time: 0.00s\nMinimum total cost: 7066.67\nOptimal investment amounts: X1=13333.333333333334, X2=20000.0, X3=15000.0, X4=20000.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(x1, x2, x3, x4\\): Integer investments (in dollars) in assets X1, X2, X3, and X4 respectively.\n\nObjective Function:\n- Minimize total cost: \\(Z = 0.05x1 + 0.08x2 + 0.12x3 + 0.15x4\\)\n\nConstraints:\n1. Total investment budget: \\(x1 + x2 + x3 + x4 \\leq 100000\\)\n2. Minimum and maximum investments:\n   - \\(10000 \\leq x1 \\leq 60000\\)\n   - \\(20000 \\leq x2 \\leq 80000\\)\n   - \\(15000 \\leq x3 \\leq 50000\\)\n   - \\(x4 \\geq 200\\)\n3. Investment conditions:\n   - \\(0.6x1 - 0.4x2 \\geq 0\\)\n   - \\(x3 + x4 - x1 - x2 \\geq -30000\\)\n   - \\(0.7x3 - 0.5x4 \\leq 500\\)\n4. Non-negativity and integer: \\(x1, x2, x3, x4 \\geq 0\\) and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"PortfolioManagement\")\n\n# Decision variables\nx1 = model.addVar(lb=10000, ub=60000, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=20000, ub=80000, vtype=COPT.INTEGER, name=\"x2\")\nx3 = model.addVar(lb=15000, ub=50000, vtype=COPT.INTEGER, name=\"x3\")\nx4 = model.addVar(lb=200, vtype=COPT.INTEGER, name=\"x4\")\n\n# Objective function\nmodel.setObjective(0.05*x1 + 0.08*x2 + 0.12*x3 + 0.15*x4, sense=COPT.MINIMIZE)\n\n# Constraints\nmodel.addConstr(x1 + x2 + x3 + x4 <= 100000, name=\"BudgetConstraint\")\nmodel.addConstr(0.6*x1 - 0.4*x2 >= 0, name=\"X1X2Constraint\")\nmodel.addConstr(x3 + x4 - x1 - x2 >= -30000, name=\"X3X4Constraint\")\nmodel.addConstr(0.7*x3 - 0.5*x4 <= 500, name=\"X3X4Constraint2\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total cost: ${:.2f}\".format(model.objval))\n    print(\"Optimal investment allocation:\")\n    print(f\"Asset X1: ${x1.x}\")\n    print(f\"Asset X2: ${x2.x}\")\n    print(f\"Asset X3: ${x3.x}\")\n    print(f\"Asset X4: ${x4.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"PortfolioManagement\")\n\n# Decision variables\nx1 = model.addVar(lb=10000, ub=60000, vtype=COPT.INTEGER, name=\"x1\")\nx2 = model.addVar(lb=20000, ub=80000, vtype=COPT.INTEGER, name=\"x2\")\nx3 = model.addVar(lb=15000, ub=50000, vtype=COPT.INTEGER, name=\"x3\")\nx4 = model.addVar(lb=200, vtype=COPT.INTEGER, name=\"x4\")\n\n# Objective function\nmodel.setObjective(0.05*x1 + 0.08*x2 + 0.12*x3 + 0.15*x4, sense=COPT.MINIMIZE)\n\n# Constraints\nmodel.addConstr(x1 + x2 + x3 + x4 <= 100000, name=\"BudgetConstraint\")\nmodel.addConstr(0.6*x1 - 0.4*x2 >= 0, name=\"X1X2Constraint\")\nmodel.addConstr(x3 + x4 - x1 - x2 >= -30000, name=\"X3X4Constraint\")\nmodel.addConstr(0.7*x3 - 0.5*x4 <= 500, name=\"X3X4Constraint2\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum total cost: ${:.2f}\".format(model.objval))\n    print(\"Optimal investment allocation:\")\n    print(f\"Asset X1: ${x1.x}\")\n    print(f\"Asset X2: ${x2.x}\")\n    print(f\"Asset X3: ${x3.x}\")\n    print(f\"Asset X4: ${x4.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 58fc49af\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 4 columns and 12 non-zero elements\n    4 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 7066.700000000\nBest bound      : 7066.700000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total cost: $7066.70\nOptimal investment allocation:\nAsset X1: $13334.0\nAsset X2: $20000.0\nAsset X3: $15000.0\nAsset X4: $20000.0",
        "pass": true
      },
      {
        "response": "<model>\nDecision Variables:  \n- $x_1\\): The amount of money (in dollars) invested in asset \\(X1\\).  \n- \\(x_2\\): The amount of money (in dollars) invested in asset \\(X2\\).  \n- \\(x_3\\): The amount of money (in dollars) invested in asset \\(X3\\).  \n- \\(x_4\\): The amount of money (in dollars) invested in asset \\(X4\\).  \n\nObjective Function:  \n- Minimize the total cost:  \n  \\[\n  Z = 0.05x_1 + 0.08x_2 + 0.12x_3 + 0.15x_4\n  \\]\n\nConstraints:  \n1. Budget constraint:  \n   \\[\n   x_1 + x_2 + x_3 + x_4 \\leq 100000\n   \\]\n2. Investment range constraints:  \n   \\[\n   10000 \\leq x_1 \\leq 60000\n   \\]\n   \\[\n   20000 \\leq x_2 \\leq 80000\n   \\]\n   \\[\n   15000 \\leq x_3 \\leq 50000\n   \\]\n   \\[\n   x_4 \\geq 200\n   \\]\n3. Investment condition constraints:  \n   \\[\n   0.6x_1 - 0.4x_2 \\geq 0\n   \\]\n   \\[\n   x_3 + x_4 - x_1 - x_2 \\geq -30000\n   \\]\n   \\[\n   0.7x_3 - 0.5x_4 \\leq 500\n   \\]\n4. Non-negativity and integer constraints:  \n   \\[\n   x_1, x_2, x_3, x_4 \\geq 0 \\text{ and integer}\n   \\]\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"PortfolioOptimization\")\n\n# Define the investment amounts for the four assets\nx1 = model.addVar(lb=10000, ub=60000, vtype=COPT.INTEGER, name=\"x1\")  # Investment in asset X1\nx2 = model.addVar(lb=20000, ub=80000, vtype=COPT.INTEGER, name=\"x2\")  # Investment in asset X2\nx3 = model.addVar(lb=15000, ub=50000, vtype=COPT.INTEGER, name=\"x3\")  # Investment in asset X3\nx4 = model.addVar(lb=200, vtype=COPT.INTEGER, name=\"x4\")             # Investment in asset X4\n\n# Add constraints\nmodel.addConstr(x1 + x2 + x3 + x4 <= 100000, name=\"BudgetConstraint\")  # Budget constraint\nmodel.addConstr(0.6*x1 - 0.4*x2 >= 0, name=\"InvestmentCondition1\")   # Investment condition constraint\nmodel.addConstr(x3 + x4 - x1 - x2 >= -30000, name=\"InvestmentCondition2\")  # Investment condition constraint\nmodel.addConstr(0.7*x3 - 0.5*x4 <= 500, name=\"InvestmentCondition3\")  # Investment condition constraint\n\n# Set the objective function\nmodel.setObjective(0.05*x1 + 0.08*x2 + 0.12*x3 + 0.15*x4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total cost: ${round(model.objval, 2)}\")\n    print(f\"Optimal investment allocation:\")\n    print(f\"- Asset X1: ${x1.x}\")\n    print(f\"- Asset X2: ${x2.x}\")\n    print(f\"- Asset X3: ${x3.x}\")\n    print(f\"- Asset X4: ${x4.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"PortfolioOptimization\")\n\n# Define the investment amounts for the four assets\nx1 = model.addVar(lb=10000, ub=60000, vtype=COPT.INTEGER, name=\"x1\")  # Investment in asset X1\nx2 = model.addVar(lb=20000, ub=80000, vtype=COPT.INTEGER, name=\"x2\")  # Investment in asset X2\nx3 = model.addVar(lb=15000, ub=50000, vtype=COPT.INTEGER, name=\"x3\")  # Investment in asset X3\nx4 = model.addVar(lb=200, vtype=COPT.INTEGER, name=\"x4\")             # Investment in asset X4\n\n# Add constraints\nmodel.addConstr(x1 + x2 + x3 + x4 <= 100000, name=\"BudgetConstraint\")  # Budget constraint\nmodel.addConstr(0.6*x1 - 0.4*x2 >= 0, name=\"InvestmentCondition1\")   # Investment condition constraint\nmodel.addConstr(x3 + x4 - x1 - x2 >= -30000, name=\"InvestmentCondition2\")  # Investment condition constraint\nmodel.addConstr(0.7*x3 - 0.5*x4 <= 500, name=\"InvestmentCondition3\")  # Investment condition constraint\n\n# Set the objective function\nmodel.setObjective(0.05*x1 + 0.08*x2 + 0.12*x3 + 0.15*x4, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum total cost: ${round(model.objval, 2)}\")\n    print(f\"Optimal investment allocation:\")\n    print(f\"- Asset X1: ${x1.x}\")\n    print(f\"- Asset X2: ${x2.x}\")\n    print(f\"- Asset X3: ${x3.x}\")\n    print(f\"- Asset X4: ${x4.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Cardinal Optimizer v7.2.9. Build date Jun 20 2025\nCopyright Cardinal Operations 2025. All Rights Reserved\n\nModel fingerprint: 58fc49af\n\nUsing Cardinal Optimizer v7.2.9 on Linux\nHardware has 2 cores and 4 threads. Using instruction set X86_AVX512 (12)\nMinimizing a MIP problem\n\nThe original problem has:\n    4 rows, 4 columns and 12 non-zero elements\n    4 integers\n\nStarting the MIP solver with 4 threads and 8 tasks\n\nPresolving the problem\nProblem was solved during presolve\n\nBest solution   : 7066.700000000\nBest bound      : 7066.700000000\nBest gap        : 0.0000%\nSolve time      : 0.00\nSolve node      : 0\nMIP status      : solved\nSolution status : integer optimal (relative gap limit 0.0001)\n\nViolations      :     absolute     relative\n  bounds        :            0            0\n  rows          :            0            0\n  integrality   :            0\nMinimum total cost: $7066.7\nOptimal investment allocation:\n- Asset X1: $13334.0\n- Asset X2: $20000.0\n- Asset X3: $15000.0\n- Asset X4: $20000.0",
        "pass": true
      }
    ],
    "answer": 0.0,
    "cloze": "A bubble tea shop sells mango and lychee bubble tea. Each mango bubble tea requires ____ units of mango juice and ____ units of tea. Each lychee bubble tea requires ____ units of lychee juice and ____ units of tea. The shop has available ____ units of mango juice and ____ units of lychee juice. ____ ____ ____ of the bubble teas made must be lychee flavored. However, mango bubble tea sells better and thus the number of mango bubble teas made must be ____ the number of lychee bubble teas made. How many of each bubble tea flavor should be made to ____ the total amount of tea needed?"
  },
  {
    "question": "A school is organizing a field trip to a science center and wants to hire small buses and large buses. A small bus can carry 20 students while a large bus can carry 50 students.  The school needs to provide transportation for at least 500 students.  In addition, since the parking lot is rather small, a maximum of 20% of the buses can be large buses. How many of each type of bus should be hired to minimize the total number of buses?",
    "pass_count": 0,
    "pass_rate": 0.0,
    "rollouts": [
      {
        "response": "<model>\nDecision Variables:\n- W1, W2, W3, W4: The number of workers assigned to production lines 1, 2, 3, and 4, respectively. These are non-negative integers.\n\nObjective Function:\n- Minimize the maximum production time for components A, B, and C, defined as:\n  - T_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n  - T_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n  - T_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n  - Objective: Minimize max(T_A, T_B, T_C)\n\nConstraints:\n1. Total worker availability: W1 + W2 + W3 + W4 ≤ 50\n2. Worker limits per production line: W1 ≤ 15, W2 ≤ 15, W3 ≤ 15, W4 ≤ 15\n3. Minimum worker requirement for production lines: W1 ≥ 5, W2 ≥ 5, W3 ≥ 5, W4 ≥ 5\n4. Non-negativity and integer: W1, W2, W3, W4 ≥ 0 and integers\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W1: Number of workers assigned to production line 1.\n- W2: Number of workers assigned to production line 2.\n- W3: Number of workers assigned to production line 3.\n- W4: Number of workers assigned to production line 4.\n- T: Maximum production time to meet the daily demand for components A, B, and C.\n\nObjective Function:\n- Minimize T.\n\nConstraints:\n1. W1 + W2 + W3 + W4 ≤ 50\n2. W1 ≥ 5\n3. W2 ≥ 5\n4. W3 ≥ 5\n5. W4 ≥ 5\n6. W1 ≤ 15\n7. W2 ≤ 15\n8. W3 ≤ 15\n9. W4 ≤ 15\n10. T ≥ 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n11. T ≥ 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n12. T ≥ 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n13. W1, W2, W3, W4 ≥ 0 and integer.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ManufacturingOptimization\")\n\n# Define decision variables\nW1 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W1\")\nW2 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W2\")\nW3 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W3\")\nW4 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W4\")\nT = model.addVar(lb=0, vtype=COPT.CONTINUOUS, name=\"T\")\n\n# Set the objective function\nmodel.setObjective(T, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkersLimit\")\nmodel.addConstr(W1 >= 5, name=\"Line1MinWorkers\")\nmodel.addConstr(W2 >= 5, name=\"Line2MinWorkers\")\nmodel.addConstr(W3 >= 5, name=\"Line3MinWorkers\")\nmodel.addConstr(W4 >= 5, name=\"Line4MinWorkers\")\nmodel.addConstr(W1 <= 15, name=\"Line1MaxWorkers\")\nmodel.addConstr(W2 <= 15, name=\"Line2MaxWorkers\")\nmodel.addConstr(W3 <= 15, name=\"Line3MaxWorkers\")\nmodel.addConstr(W4 <= 15, name=\"Line4MaxWorkers\")\nmodel.addConstr(T >= 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4), name=\"ComponentALimit\")\nmodel.addConstr(T >= 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4), name=\"ComponentBLimit\")\nmodel.addConstr(T >= 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4), name=\"ComponentCLimit\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum production time to meet the daily demand: {:.2f} hours\".format(T.x))\n    print(\"Number of workers assigned to production line 1: {}\".format(W1.x))\n    print(\"Number of workers assigned to production line 2: {}\".format(W2.x))\n    print(\"Number of workers assigned to production line 3: {}\".format(W3.x))\n    print(\"Number of workers assigned to production line 4: {}\".format(W4.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ManufacturingOptimization\")\n\n# Define decision variables\nW1 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W1\")\nW2 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W2\")\nW3 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W3\")\nW4 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W4\")\nT = model.addVar(lb=0, vtype=COPT.CONTINUOUS, name=\"T\")\n\n# Set the objective function\nmodel.setObjective(T, sense=COPT.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkersLimit\")\nmodel.addConstr(W1 >= 5, name=\"Line1MinWorkers\")\nmodel.addConstr(W2 >= 5, name=\"Line2MinWorkers\")\nmodel.addConstr(W3 >= 5, name=\"Line3MinWorkers\")\nmodel.addConstr(W4 >= 5, name=\"Line4MinWorkers\")\nmodel.addConstr(W1 <= 15, name=\"Line1MaxWorkers\")\nmodel.addConstr(W2 <= 15, name=\"Line2MaxWorkers\")\nmodel.addConstr(W3 <= 15, name=\"Line3MaxWorkers\")\nmodel.addConstr(W4 <= 15, name=\"Line4MaxWorkers\")\nmodel.addConstr(T >= 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4), name=\"ComponentALimit\")\nmodel.addConstr(T >= 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4), name=\"ComponentBLimit\")\nmodel.addConstr(T >= 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4), name=\"ComponentCLimit\")\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum production time to meet the daily demand: {:.2f} hours\".format(T.x))\n    print(\"Number of workers assigned to production line 1: {}\".format(W1.x))\n    print(\"Number of workers assigned to production line 2: {}\".format(W2.x))\n    print(\"Number of workers assigned to production line 3: {}\".format(W3.x))\n    print(\"Number of workers assigned to production line 4: {}\".format(W4.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Error: unsupported operand type(s) for /: 'int' and 'ExprBuilder'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- \\(W_i\\): Integer representing the number of workers assigned to production line \\(i\\), where \\(i \\in \\{1, 2, 3, 4\\}\\).\n\nObjective Function:\n- Minimize the maximum production time for components A, B, and C, defined as:\n  - \\(T_A = \\frac{1000}{10 \\cdot W_1 + 8 \\cdot W_2 + 12 \\cdot W_3 + 15 \\cdot W_4}\\)\n  - \\(T_B = \\frac{800}{5 \\cdot W_1 + 10 \\cdot W_2 + 6 \\cdot W_3 + 8 \\cdot W_4}\\)\n  - \\(T_C = \\frac{1200}{15 \\cdot W_1 + 12 \\cdot W_2 + 10 \\cdot W_3 + 5 \\cdot W_4}\\)\n  - Objective: Minimize \\(Z = \\max(T_A, T_B, T_C)\\)\n\nConstraints:\n1. Total worker constraint: \\(W_1 + W_2 + W_3 + W_4 \\leq 50\\)\n2. Worker limit constraint: \\(0 \\leq W_i \\leq 15\\) for all \\(i\\)\n3. Minimum worker requirement: \\(W_i \\geq 5\\) for all \\(i\\)\n4. Integer constraints: \\(W_i \\in \\mathbb{Z}^+\\)\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ProductionLineOptimization\")\n\n# Define production lines\nlines = [1, 2, 3, 4]\n\n# Define component production rates per worker\nrate_A = {1: 10, 2: 8, 3: 12, 4: 15}\nrate_B = {1: 5, 2: 10, 3: 6, 4: 8}\nrate_C = {1: 15, 2: 12, 3: 10, 4: 5}\n\n# Define daily demand\ndemand_A = 1000\ndemand_B = 800\ndemand_C = 1200\n\n# Define total workers and worker limit per line\ntotal_workers = 50\nworkers_per_line = 15\n\n# Add decision variables\nW = {i: model.addVar(lb=0, ub=workers_per_line, vtype=COPT.INTEGER, name=f\"W_{i}\") for i in lines}\n\n# Add constraints\nmodel.addConstr(cp.quicksum(W[i] for i in lines) <= total_workers, name=\"TotalWorkersConstraint\")\nmodel.addConstr(W[i] >= 5 for i in lines)\n\n# Define objective function\nT_A = demand_A / (rate_A[1] * W[1] + rate_A[2] * W[2] + rate_A[3] * W[3] + rate_A[4] * W[4])\nT_B = demand_B / (rate_B[1] * W[1] + rate_B[2] * W[2] + rate_B[3] * W[3] + rate_B[4] * W[4])\nT_C = demand_C / (rate_C[1] * W[1] + rate_C[2] * W[2] + rate_C[3] * W[3] + rate_C[4] * W[4])\nmodel.setObjective(cp.quicksum([T_A, T_B, T_C]), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum production time: {model.objval:.2f} hours\")\n    for i in lines:\n        print(f\"Number of workers assigned to production line {i}: {W[i].x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a COPT model\nmodel = env.createModel(\"ProductionLineOptimization\")\n\n# Define production lines\nlines = [1, 2, 3, 4]\n\n# Define component production rates per worker\nrate_A = {1: 10, 2: 8, 3: 12, 4: 15}\nrate_B = {1: 5, 2: 10, 3: 6, 4: 8}\nrate_C = {1: 15, 2: 12, 3: 10, 4: 5}\n\n# Define daily demand\ndemand_A = 1000\ndemand_B = 800\ndemand_C = 1200\n\n# Define total workers and worker limit per line\ntotal_workers = 50\nworkers_per_line = 15\n\n# Add decision variables\nW = {i: model.addVar(lb=0, ub=workers_per_line, vtype=COPT.INTEGER, name=f\"W_{i}\") for i in lines}\n\n# Add constraints\nmodel.addConstr(cp.quicksum(W[i] for i in lines) <= total_workers, name=\"TotalWorkersConstraint\")\nmodel.addConstr(W[i] >= 5 for i in lines)\n\n# Define objective function\nT_A = demand_A / (rate_A[1] * W[1] + rate_A[2] * W[2] + rate_A[3] * W[3] + rate_A[4] * W[4])\nT_B = demand_B / (rate_B[1] * W[1] + rate_B[2] * W[2] + rate_B[3] * W[3] + rate_B[4] * W[4])\nT_C = demand_C / (rate_C[1] * W[1] + rate_C[2] * W[2] + rate_C[3] * W[3] + rate_C[4] * W[4])\nmodel.setObjective(cp.quicksum([T_A, T_B, T_C]), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(f\"Minimum production time: {model.objval:.2f} hours\")\n    for i in lines:\n        print(f\"Number of workers assigned to production line {i}: {W[i].x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Error: name 'model' is not defined",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W1, W2, W3, W4: The number of workers assigned to production lines 1, 2, 3, and 4, respectively.\n\nObjective Function:\n- Minimize the maximum production time: Z = max(T_A, T_B, T_C)\n  - T_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n  - T_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n  - T_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\nConstraints:\n1. Production line capacity: W1 ≤ 15, W2 ≤ 15, W3 ≤ 15, W4 ≤ 15\n2. Minimum workers per production line: W1 ≥ 5, W2 ≥ 5, W3 ≥ 5, W4 ≥ 5\n3. Total workers: W1 + W2 + W3 + W4 ≤ 50\n4. Non-negativity and integer: W1, W2, W3, W4 ≥ 0 and integer\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionLineOptimization\")\n\n# Define decision variables\nW1 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W1\")  # Number of workers assigned to production line 1\nW2 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W2\")  # Number of workers assigned to production line 2\nW3 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W3\")  # Number of workers assigned to production line 3\nW4 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W4\")  # Number of workers assigned to production line 4\n\n# Add constraints\nmodel.addConstr(W1 >= 5, name=\"MinWorkers1\")  # Minimum workers per production line\nmodel.addConstr(W2 >= 5, name=\"MinWorkers2\")\nmodel.addConstr(W3 >= 5, name=\"MinWorkers3\")\nmodel.addConstr(W4 >= 5, name=\"MinWorkers4\")\n\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkers\")  # Total workers available\n\n# Objective function: Minimize the maximum production time\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\nZ = cp.quicksum([T_A, T_B, T_C]) / 3  # Average production time\nmodel.setObjective(Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum average production time: {:.2f} hours\".format(model.objval))\n    print(\"Number of workers assigned to production lines:\")\n    print(f\"Line 1: {W1.x}\")\n    print(f\"Line 2: {W2.x}\")\n    print(f\"Line 3: {W3.x}\")\n    print(f\"Line 4: {W4.x}\")\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionLineOptimization\")\n\n# Define decision variables\nW1 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W1\")  # Number of workers assigned to production line 1\nW2 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W2\")  # Number of workers assigned to production line 2\nW3 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W3\")  # Number of workers assigned to production line 3\nW4 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W4\")  # Number of workers assigned to production line 4\n\n# Add constraints\nmodel.addConstr(W1 >= 5, name=\"MinWorkers1\")  # Minimum workers per production line\nmodel.addConstr(W2 >= 5, name=\"MinWorkers2\")\nmodel.addConstr(W3 >= 5, name=\"MinWorkers3\")\nmodel.addConstr(W4 >= 5, name=\"MinWorkers4\")\n\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkers\")  # Total workers available\n\n# Objective function: Minimize the maximum production time\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\nZ = cp.quicksum([T_A, T_B, T_C]) / 3  # Average production time\nmodel.setObjective(Z, sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum average production time: {:.2f} hours\".format(model.objval))\n    print(\"Number of workers assigned to production lines:\")\n    print(f\"Line 1: {W1.x}\")\n    print(f\"Line 2: {W2.x}\")\n    print(f\"Line 3: {W3.x}\")\n    print(f\"Line 4: {W4.x}\")\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Error: unsupported operand type(s) for /: 'int' and 'ExprBuilder'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W1, W2, W3, W4: the number of workers assigned to production lines 1, 2, 3, and 4 respectively.\n\nObjective Function:\n- Minimize the maximum production time for components A, B, and C, defined as:\n  - T_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n  - T_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n  - T_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n  - Objective: minimize max(T_A, T_B, T_C)\n\nConstraints:\n1. Daily production demand for component A: 10 * W1 + 8 * W2 + 12 * W3 + 15 * W4 ≥ 1000\n2. Daily production demand for component B: 5 * W1 + 10 * W2 + 6 * W3 + 8 * W4 ≥ 800\n3. Daily production demand for component C: 15 * W1 + 12 * W2 + 10 * W3 + 5 * W4 ≥ 1200\n4. Maximum number of workers available: W1 + W2 + W3 + W4 ≤ 50\n5. Minimum number of workers per production line: W1 ≥ 5, W2 ≥ 5, W3 ≥ 5, W4 ≥ 5\n6. Non-negativity and integer constraints: W1, W2, W3, W4 ≥ 0 and integers\n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:  \n- \\( W_i \\): The number of workers assigned to production line \\( i \\) for \\( i \\in \\{1, 2, 3, 4\\} \\).\n\nObjective Function:  \n- Minimize the maximum production time:  \n  \\[ Z = \\max\\left(\\frac{1000}{10W_1 + 8W_2 + 12W_3 + 15W_4}, \\frac{800}{5W_1 + 10W_2 + 6W_3 + 8W_4}, \\frac{1200}{15W_1 + 12W_2 + 10W_3 + 5W_4}\\right) \\]\n\nConstraints:  \n1. Demand satisfaction for component A:  \n   \\[ 10W_1 + 8W_2 + 12W_3 + 15W_4 \\geq 1000 \\]  \n2. Demand satisfaction for component B:  \n   \\[ 5W_1 + 10W_2 + 6W_3 + 8W_4 \\geq 800 \\]  \n3. Demand satisfaction for component C:  \n   \\[ 15W_1 + 12W_2 + 10W_3 + 5W_4 \\geq 1200 \\]  \n4. Worker capacity for each production line:  \n   \\[ W_i \\leq 15 \\quad \\text{for all } i \\in \\{1, 2, 3, 4\\} \\]  \n5. Minimum workers per production line:  \n   \\[ W_i \\geq 5 \\quad \\text{for all } i \\in \\{1, 2, 3, 4\\} \\]  \n6. Total worker limit:  \n   \\[ W_1 + W_2 + W_3 + W_4 \\leq 50 \\]  \n7. Non-negativity:  \n   \\[ W_i \\geq 0 \\quad \\text{for all } i \\in \\{1, 2, 3, 4\\} \\]  \n8. Integer:  \n   \\[ W_i \\in \\mathbb{Z}^+ \\quad \\text{for all } i \\in \\{1, 2, 3, 4\\} \\]  \n</model>",
        "code": "",
        "exec_output": "Executed (no output)",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W1, W2, W3, W4: The number of workers assigned to production lines 1, 2, 3, and 4, respectively. These are integer decision variables.\n\nObjective Function:\n- Minimize Z = max(T_A, T_B, T_C), where:\n  - T_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n  - T_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n  - T_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\nConstraints:\n1. Production line availability: W1 + W2 + W3 + W4 ≤ 50 (total number of workers available)\n2. Minimum number of workers for operation: W1 ≥ 5, W2 ≥ 5, W3 ≥ 5, W4 ≥ 5\n3. Non-negativity: W1, W2, W3, W4 ≥ 0\n4. Integer: W1, W2, W3, W4 are integers\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ElectronicComponentProduction\")\n\n# Add decision variables\nW1 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W1\")\nW2 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W2\")\nW3 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W3\")\nW4 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W4\")\n\n# Add constraints\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkersConstraint\")\nmodel.addConstr(W1 >= 5, name=\"MinWorkersLine1\")\nmodel.addConstr(W2 >= 5, name=\"MinWorkersLine2\")\nmodel.addConstr(W3 >= 5, name=\"MinWorkersLine3\")\nmodel.addConstr(W4 >= 5, name=\"MinWorkersLine4\")\n\n# Objective function: minimize the maximum production time\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\nmodel.setObjective(cp.quicksum([T_A, T_B, T_C]), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum maximum production time: {:.2f} hours\".format(model.objval))\n    print(\"Workers assigned to production lines:\")\n    print(\"Line 1: {} workers\".format(W1.x))\n    print(\"Line 2: {} workers\".format(W2.x))\n    print(\"Line 3: {} workers\".format(W3.x))\n    print(\"Line 4: {} workers\".format(W4.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ElectronicComponentProduction\")\n\n# Add decision variables\nW1 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W1\")\nW2 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W2\")\nW3 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W3\")\nW4 = model.addVar(lb=0, ub=15, vtype=COPT.INTEGER, name=\"W4\")\n\n# Add constraints\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkersConstraint\")\nmodel.addConstr(W1 >= 5, name=\"MinWorkersLine1\")\nmodel.addConstr(W2 >= 5, name=\"MinWorkersLine2\")\nmodel.addConstr(W3 >= 5, name=\"MinWorkersLine3\")\nmodel.addConstr(W4 >= 5, name=\"MinWorkersLine4\")\n\n# Objective function: minimize the maximum production time\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\nmodel.setObjective(cp.quicksum([T_A, T_B, T_C]), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum maximum production time: {:.2f} hours\".format(model.objval))\n    print(\"Workers assigned to production lines:\")\n    print(\"Line 1: {} workers\".format(W1.x))\n    print(\"Line 2: {} workers\".format(W2.x))\n    print(\"Line 3: {} workers\".format(W3.x))\n    print(\"Line 4: {} workers\".format(W4.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Error: unsupported operand type(s) for /: 'int' and 'ExprBuilder'",
        "pass": false
      },
      {
        "response": "<model>\nDecision Variables:\n- W1: Number of workers assigned to production line 1.\n- W2: Number of workers assigned to production line 2.\n- W3: Number of workers assigned to production line 3.\n- W4: Number of workers assigned to production line 4.\n\nObjective Function:\n- Minimize the maximum production time for components A, B, and C, defined as:\n  - T_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\n  - T_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\n  - T_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n- The objective is to minimize max(T_A, T_B, T_C).\n\nConstraints:\n1. Production line 1 can only be operated if at least 5 workers are assigned: W1 >= 5.\n2. Production line 2 can only be operated if at least 5 workers are assigned: W2 >= 5.\n3. Production line 3 can only be operated if at least 5 workers are assigned: W3 >= 5.\n4. Production line 4 can only be operated if at least 5 workers are assigned: W4 >= 5.\n5. Total number of workers assigned across all production lines is limited to 50: W1 + W2 + W3 + W4 <= 50.\n6. Each production line can be utilized by up to 15 workers at a time: W1 <= 15, W2 <= 15, W3 <= 15, W4 <= 15.\n7. Non-negativity and integer constraints: W1, W2, W3, W4 are integers >= 0.\n</model>\n<code>\nimport coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionLineOptimization\")\n\n# Define production rates\nproduction_rates = {\n    ('Line1', 'ComponentA'): 10,\n    ('Line1', 'ComponentB'): 5,\n    ('Line1', 'ComponentC'): 15,\n    ('Line2', 'ComponentA'): 8,\n    ('Line2', 'ComponentB'): 10,\n    ('Line2', 'ComponentC'): 12,\n    ('Line3', 'ComponentA'): 12,\n    ('Line3', 'ComponentB'): 6,\n    ('Line3', 'ComponentC'): 10,\n    ('Line4', 'ComponentA'): 15,\n    ('Line4', 'ComponentB'): 8,\n    ('Line4', 'ComponentC'): 5\n}\n\n# Define demand\ndemand = {\n    'ComponentA': 1000,\n    'ComponentB': 800,\n    'ComponentC': 1200\n}\n\n# Add decision variables\nW1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"W1\")\nW2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"W2\")\nW3 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"W3\")\nW4 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"W4\")\n\n# Set lower bounds for production lines\nmodel.addConstr(W1 >= 5, name=\"MinWorkersLine1\")\nmodel.addConstr(W2 >= 5, name=\"MinWorkersLine2\")\nmodel.addConstr(W3 >= 5, name=\"MinWorkersLine3\")\nmodel.addConstr(W4 >= 5, name=\"MinWorkersLine4\")\n\n# Set upper bounds for production lines\nmodel.addConstr(W1 <= 15, name=\"MaxWorkersLine1\")\nmodel.addConstr(W2 <= 15, name=\"MaxWorkersLine2\")\nmodel.addConstr(W3 <= 15, name=\"MaxWorkersLine3\")\nmodel.addConstr(W4 <= 15, name=\"MaxWorkersLine4\")\n\n# Set total worker limit\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkersLimit\")\n\n# Set the objective function\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\nmodel.setObjective(max(T_A, T_B, T_C), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum maximum production time: {:.2f} hours\".format(model.objval))\n    print(\"Optimal worker assignment:\")\n    print(\"Line 1: {} workers\".format(W1.x))\n    print(\"Line 2: {} workers\".format(W2.x))\n    print(\"Line 3: {} workers\".format(W3.x))\n    print(\"Line 4: {} workers\".format(W4.x))\nelse:\n    print(\"No optimal solution found.\")\n</code>",
        "code": "import coptpy as cp\nfrom coptpy import COPT\n\n# Create a COPT environment\nenv = cp.Envr()\n\n# Create a model\nmodel = env.createModel(\"ProductionLineOptimization\")\n\n# Define production rates\nproduction_rates = {\n    ('Line1', 'ComponentA'): 10,\n    ('Line1', 'ComponentB'): 5,\n    ('Line1', 'ComponentC'): 15,\n    ('Line2', 'ComponentA'): 8,\n    ('Line2', 'ComponentB'): 10,\n    ('Line2', 'ComponentC'): 12,\n    ('Line3', 'ComponentA'): 12,\n    ('Line3', 'ComponentB'): 6,\n    ('Line3', 'ComponentC'): 10,\n    ('Line4', 'ComponentA'): 15,\n    ('Line4', 'ComponentB'): 8,\n    ('Line4', 'ComponentC'): 5\n}\n\n# Define demand\ndemand = {\n    'ComponentA': 1000,\n    'ComponentB': 800,\n    'ComponentC': 1200\n}\n\n# Add decision variables\nW1 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"W1\")\nW2 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"W2\")\nW3 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"W3\")\nW4 = model.addVar(lb=0, vtype=COPT.INTEGER, name=\"W4\")\n\n# Set lower bounds for production lines\nmodel.addConstr(W1 >= 5, name=\"MinWorkersLine1\")\nmodel.addConstr(W2 >= 5, name=\"MinWorkersLine2\")\nmodel.addConstr(W3 >= 5, name=\"MinWorkersLine3\")\nmodel.addConstr(W4 >= 5, name=\"MinWorkersLine4\")\n\n# Set upper bounds for production lines\nmodel.addConstr(W1 <= 15, name=\"MaxWorkersLine1\")\nmodel.addConstr(W2 <= 15, name=\"MaxWorkersLine2\")\nmodel.addConstr(W3 <= 15, name=\"MaxWorkersLine3\")\nmodel.addConstr(W4 <= 15, name=\"MaxWorkersLine4\")\n\n# Set total worker limit\nmodel.addConstr(W1 + W2 + W3 + W4 <= 50, name=\"TotalWorkersLimit\")\n\n# Set the objective function\nT_A = 1000 / (10 * W1 + 8 * W2 + 12 * W3 + 15 * W4)\nT_B = 800 / (5 * W1 + 10 * W2 + 6 * W3 + 8 * W4)\nT_C = 1200 / (15 * W1 + 12 * W2 + 10 * W3 + 5 * W4)\n\nmodel.setObjective(max(T_A, T_B, T_C), sense=COPT.MINIMIZE)\n\n# Solve the model\nmodel.solve()\n\n# Output the results\nif model.status == COPT.OPTIMAL:\n    print(\"Minimum maximum production time: {:.2f} hours\".format(model.objval))\n    print(\"Optimal worker assignment:\")\n    print(\"Line 1: {} workers\".format(W1.x))\n    print(\"Line 2: {} workers\".format(W2.x))\n    print(\"Line 3: {} workers\".format(W3.x))\n    print(\"Line 4: {} workers\".format(W4.x))\nelse:\n    print(\"No optimal solution found.\")",
        "exec_output": "Error: unsupported operand type(s) for /: 'int' and 'ExprBuilder'",
        "pass": false
      }
    ],
    "answer": 20.0,
    "cloze": "A school is organizing a field trip to a science center and wants to hire small buses and large buses. A small bus can carry ____ students while a large bus can carry ____ students. The school needs to provide transportation for ____ ____ students. In addition, since the parking lot is rather small, ____ ____ ____ of the buses can be large buses. How many of each type of bus should be hired to ____ the total number of buses?"
  }
]